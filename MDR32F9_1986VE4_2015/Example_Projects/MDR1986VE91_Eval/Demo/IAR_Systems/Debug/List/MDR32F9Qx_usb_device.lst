###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     22/Sep/2015  17:25:59 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Libraries\MDR32F9Qx_St #
#                    dPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c    #
#    Command line =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Libraries\MDR32F9Qx_St #
#                    dPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c    #
#                    --preprocess C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_P #
#                    rojects\MDR1986VE91_Eval\Demo\IAR_Systems\Debug\List\    #
#                    -lCN C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\ #
#                    MDR1986VE91_Eval\Demo\IAR_Systems\Debug\List\ -lB        #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -o              #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\ --debug          #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Proj #
#                    ects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\config\ -I  #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\ -I                            #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\USB_Library\ -I                #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CMSIS #
#                    \CM3\CoreSupport\ -I C:\WORK\Milandr.MDR1986BExx.1.4.0\E #
#                    xample_Projects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\ #
#                    ..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\   #
#                    -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MD #
#                    R1986VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CM #
#                    SIS\CM3\DeviceSupport\MDR32F9Qx\startup\iar\ -I          #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Example_Project #
#                    s\MDR1986VE91_Eval\inc\ -Ohz                             #
#    List file    =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\MDR32F9Qx_usb_de #
#                    vice.lst                                                 #
#    Object file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\MDR32F9Qx_usb_dev #
#                    ice.o                                                    #
#                                                                             #
#                                                                             #
###############################################################################

C:\WORK\Milandr.MDR1986BExx.1.4.0\Libraries\MDR32F9Qx_StdPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c
      1          /**
      2            ******************************************************************************
      3            * @file    USB_Library\MDR32F9Qx_usb_device.c
      4            * @author  Phyton Application Team
      5            * @version V1.4.0
      6            * @date    21/02/2011
      7            * @brief   This file contains implementation of the EndPoint and Device basic
      8            *          functionality as of USB Specification Rev.2 Chapter 9.
      9            ******************************************************************************
     10            * <br><br>
     11            *
     12            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     14            * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT
     15            * OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     16            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     17            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18            *
     19            * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
     20            ******************************************************************************
     21            * FILE MDR32F9Qx_usb_device.c
     22            */
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          /* Includes ------------------------------------------------------------------*/
     26          #include "MDR32F9Qx_config.h"
     27          #include "MDR32F9Qx_rst_clk.h"
     28          #include "MDR32F9Qx_usb_handlers.h"
     29          
     30          #define ASSERT_INFO_FILE_ID FILEID__MDR32F9X_USB_DEVICE_C
     31          
     32          /** @addtogroup __MDR32F9Qx_StdPeriph_Driver MDR32F9Qx Standard Peripherial Driver
     33            * @{
     34            */
     35          
     36          /** @addtogroup USB_DEVICE_AND_CDC USB DEVICE AND CDC
     37            * @{
     38            */
     39          
     40          /** @defgroup USB_Device_Framework_Private_Types USB Device Framework Private Types
     41            * @{
     42            */
     43          
     44          /** @} */ /* End of group USB_Device_Framework_Private_Types */
     45          
     46          /** @defgroup USB_EndPoint USB EndPoint
     47            * @{
     48            */
     49          
     50          /** @defgroup USB_EndPoint_Private_Types USB EndPoint Private Types
     51            * @{
     52            */
     53          
     54          /**
     55            * @brief EndPoint States
     56            */
     57          
     58          typedef enum
     59          {
     60            USB_EP_NAK,
     61            USB_EP_IDLE,
     62            USB_EP_IN,
     63            USB_EP_OUT,
     64            USB_EP_SETUP,
     65            USB_EP_STALL
     66          }USB_EPState_TypeDef;
     67          
     68          /**
     69            * @brief EndPoint State Machine Context type
     70            */
     71          
     72          typedef struct
     73          {
     74            USB_EPState_TypeDef EP_State;
     75            USB_StallType EP_Halt;
     76            struct
     77            {
     78              struct
     79              {
     80                /* IN-OUT transactions buffer */
     81                uint8_t *pBuffer;
     82                uint32_t length, offset;
     83                uint32_t bytesToAck;        /* number of bytes sent to host in
     84                                               IN transaction but not acknowledged yet */
     85              }IO_Buffer;
     86              /* SETUP-transaction */
     87              USB_SetupPacket_TypeDef *pSetupPacket;
     88            }Buffer;
     89            FlagStatus EP_WasScdone;
     90            FlagStatus EP_WaitOut, EP_WaitSetup;
     91            USB_EP_IO_Handler InHandler;
     92            USB_EP_IO_Handler OutHandler;
     93            USB_EP_Setup_Handler SetupHandler;
     94            USB_EP_Error_Handler ErrorHandler;
     95          }USB_EPContext_TypeDef;
     96          
     97          /**
     98            * @brief DATA bit change control
     99            */
    100          
    101          typedef enum
    102          {
    103            USB_DATA_BIT_KEEP,
    104            USB_DATA_BIT_TOGGLE,
    105            USB_DATA_BIT_DATA1,
    106          }USB_EPData_Bit_TypeDef;
    107          
    108          /** @} */ /* End of group USB_EndPoint_Private_Types */
    109          
    110          /** @defgroup USB_EndPoint_Private_Values USB EndPoint Private Values
    111            * @{
    112            */
    113          
    114          /**
    115            * @brief EndPoint State Machine Context
    116            */
    117          

   \                                 In section .bss, align 4
    118          USB_EPContext_TypeDef USB_EPContext[Num_USB_EndPoints];
   \                     USB_EPContext:
   \   00000000                      DS8 176
    119          
    120          /** @} */ /* End of group USB_EndPoint_Private_Values */
    121          
    122          /** @defgroup USB_EndPoint_Private_Constants USB EndPoint Private Constants
    123            * @{
    124            */
    125          
    126          /** @} */ /* End of group USB_EndPoint_Private_Constants */
    127          
    128          /** @defgroup USB_EndPoint_Private_Macros USB EndPoint Private Macros
    129            * @{
    130            */
    131          
    132          #define TX_FIFO_FORCE_EMPTY(EndPoint)        USB_SetSEPxTXFDC(EndPoint, 1)
    133          #define RX_FIFO_FORCE_EMPTY(EndPoint)        USB_SetSEPxRXFC(EndPoint, 1)
    134          #define EPx_RX_FIFO_DATA(EndPoint)           USB_GetSEPxRXFD(EndPoint)
    135          
    136          /** @} */ /* End of group USB_EndPoint_Private_Macros */
    137          
    138          /** @defgroup USB_EndPoint_Private_FunctionPrototypes USB EndPoint Private Function Prototypes
    139            * @{
    140            */
    141          
    142          static void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange);
    143          static void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val);
    144          
    145          /** @} */ /* End of group USB_EndPoint_Private_FunctionPrototypes */
    146          
    147          /** @defgroup USB_EndPoint_Private_Functions USB EndPoint Private Functions
    148            * @{
    149            */
    150          
    151          /**
    152            * @brief  Initial EndPoint setup
    153            *
    154            * @param  EPx: USB EndPoint number.
    155            *         This parameter can be one of the following values:
    156            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    157            * @param  USB_EP_Ctrl: Value, controlling EPISOEN, EPDATASEQ bits
    158            *         of corresponding USB_SEPx.CTRL register.
    159            * @param  onError: User's handler to be called on any error with data transmitting
    160            *                   via this End Point (may be 0).
    161            *
    162            * @retval USB_Result status (USB_SUCCESS or USB_ERROR).
    163            */
    164          

   \                                 In section .text, align 2, keep-with-next
    165          USB_Result USB_EP_Init(USB_EP_TypeDef EPx, uint32_t USB_EP_Ctrl, USB_EP_Error_Handler onError)
    166          {
   \                     USB_EP_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
    167            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    168          
    169            /* EndPoint context preparation */
    170            ep->Buffer.IO_Buffer.pBuffer    = 0;
   \                     ??CrossCallReturnLabel_3:
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x605C             STR      R4,[R3, #+4]
    171            ep->Buffer.IO_Buffer.length     = 0;
   \   0000000A   0x609C             STR      R4,[R3, #+8]
    172            ep->Buffer.IO_Buffer.bytesToAck = 0;
   \   0000000C   0x611C             STR      R4,[R3, #+16]
    173            ep->Buffer.IO_Buffer.offset     = 0;
   \   0000000E   0x60DC             STR      R4,[R3, #+12]
    174            ep->Buffer.pSetupPacket         = 0;
   \   00000010   0x615C             STR      R4,[R3, #+20]
    175            ep->InHandler                   = 0;
   \   00000012   0x61DC             STR      R4,[R3, #+28]
    176            ep->OutHandler                  = 0;
   \   00000014   0x621C             STR      R4,[R3, #+32]
    177            ep->SetupHandler                = 0;
   \   00000016   0x625C             STR      R4,[R3, #+36]
    178            ep->ErrorHandler                = onError;
   \   00000018   0x629A             STR      R2,[R3, #+40]
    179            ep->EP_Halt                     = USB_STALL_PROTO;
   \   0000001A   0x705C             STRB     R4,[R3, #+1]
    180            ep->EP_State                    = USB_EP_NAK;
   \   0000001C   0x701C             STRB     R4,[R3, #+0]
    181            ep->EP_WasScdone                = RESET;
   \   0000001E   0x761C             STRB     R4,[R3, #+24]
    182          
    183            USB_SetSEPxCTRL(EPx, USB_EP_Ctrl);
   \   00000020   0x.... 0x....      BL       USB_SetSEPxCTRL
    184          
    185            return USB_SUCCESS;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    186          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x232C             MOVS     R3,#+44
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable13
   \   00000006   0xFB03 0x4300      MLA      R3,R3,R0,R4
   \   0000000A   0x4770             BX       LR
    187          
    188          /**
    189            * @brief  Resets the EndPoint to NAK state
    190            *
    191            * @param  EPx: USB EndPoint number.
    192            *         This parameter can be one of the following values:
    193            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    194            *
    195            * @retval USB_Result.
    196            */
    197          

   \                                 In section .text, align 2, keep-with-next
    198          USB_Result USB_EP_Reset(USB_EP_TypeDef EPx)
    199          {
   \                     USB_EP_Reset:
   \   00000000   0xB580             PUSH     {R7,LR}
    200            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000002   0x212C             MOVS     R1,#+44
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable13
   \   00000008   0xFB01 0x2100      MLA      R1,R1,R0,R2
    201          
    202            ep->EP_State = USB_EP_NAK;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x700A             STRB     R2,[R1, #+0]
    203            ep->EP_WasScdone = RESET;
   \   00000010   0x760A             STRB     R2,[R1, #+24]
    204          
    205            USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPISOEN_Reset  |                           /* Reset Isohronic */
    206                                 USB_SEPx_CTRL_EPRDY_NotReady |                           /* Reset READY */
    207                                 USB_SEPx_CTRL_EPEN_Enable);                              /* Set ENABLE */
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x120001
   \   00000016   0x.... 0x....      BL       USB_SetSEPxCTRL
    208          
    209            return USB_SUCCESS;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
    210          }
    211          
    212          /**
    213            * @brief  Switches the EndPoint to IDLE (wait for transaction) or NAK state
    214            *
    215            * @param  EPx: USB EndPoint number.
    216            *         This parameter can be one of the following values:
    217            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    218            *
    219            * @retval USB_Result.
    220            *
    221            * @note   IDLE state and EPRDY bit are set if OUT/SETUP transaction is expected.
    222            *         Otherwise, this function switches to NAK state.
    223            */
    224          

   \                                 In section .text, align 2, keep-with-next
    225          USB_Result USB_EP_Idle(USB_EP_TypeDef EPx)
    226          {
   \                     USB_EP_Idle:
   \   00000000   0xB580             PUSH     {R7,LR}
    227            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000002   0x212C             MOVS     R1,#+44
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable13
   \   00000008   0xFB01 0x2200      MLA      R2,R1,R0,R2
    228            uint32_t val = USB_SEPx_CTRL_EPSSTALL_NotReply;                               /* Reset STALL reply */
   \   0000000C   0xF44F 0x2100      MOV      R1,#+524288
    229          
    230            if (ep->EP_WaitOut || ep->EP_WaitSetup)
   \   00000010   0x7E53             LDRB     R3,[R2, #+25]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xBF07             ITTEE    EQ 
   \   00000016   0x7E93             LDRBEQ   R3,[R2, #+26]
   \   00000018   0x2B00             CMPEQ    R3,#+0
   \   0000001A   0x2301             MOVNE    R3,#+1
   \   0000001C   0x.... 0x....      LDRNE.W  R1,??DataTable13_2  ;; 0x80002
    231            {
    232              ep->EP_State = USB_EP_IDLE;
    233              val |= USB_SEPx_CTRL_EPRDY_Ready;                                           /* Set READY */
    234            }
    235            else
    236            {
    237              ep->EP_State = USB_EP_NAK;
   \   00000020   0x7013             STRB     R3,[R2, #+0]
    238            }
    239            ep->EP_Halt = USB_STALL_PROTO;
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x7053             STRB     R3,[R2, #+1]
    240          
    241            USB_EP_SetReady(EPx, val);
   \   00000026   0x.... 0x....      BL       USB_EP_SetReady
    242          
    243            return USB_SUCCESS;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD02             POP      {R1,PC}          ;; return
    244          }
    245          
    246          /**
    247            * @brief  Switches the EndPoint to STALL state (protocol stall
    248            *         or halt) or NAK state, if STALL is prohibited.
    249            *
    250            * @param  EPx: USB EndPoint number.
    251            *         This parameter can be one of the following values:
    252            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    253            *
    254            * @param  bHalt: Specifies whether the STALL state is a HALT
    255            *         This parameter can be: USB_STALL_PROTO or USB_STALL_HALT.
    256            *
    257            * @retval USB_Result.
    258            *
    259            * @note   If protocol stall is ordered, but the EndPoint doesn't accept
    260            *         SETUP transactions, EndPoint is switched to NAK state.
    261            */
    262          

   \                                 In section .text, align 2, keep-with-next
    263          USB_Result USB_EP_Stall(USB_EP_TypeDef EPx, USB_StallType bHalt)
    264          {
   \                     USB_EP_Stall:
   \   00000000   0xB510             PUSH     {R4,LR}
    265            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000002   0x222C             MOVS     R2,#+44
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable13
   \   00000008   0xFB02 0x3300      MLA      R3,R2,R0,R3
    266            uint32_t val = 0;
   \   0000000C   0x2200             MOVS     R2,#+0
    267          
    268            if (bHalt == USB_STALL_HALT && EPx == USB_EP0)
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD102             BNE.N    ??USB_EP_Stall_0
   \   00000012   0xB918             CBNZ.N   R0,??USB_EP_Stall_1
    269            {
    270              /* No functional stall for Default Control Pipe */
    271              return USB_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    272            }
    273          
    274            if (bHalt == USB_STALL_HALT || ep->EP_WaitSetup)
   \                     ??USB_EP_Stall_0:
   \   00000018   0x7E9C             LDRB     R4,[R3, #+26]
   \   0000001A   0xB11C             CBZ.N    R4,??USB_EP_Stall_2
    275            {
    276              ep->EP_Halt  = bHalt;
   \                     ??USB_EP_Stall_1:
   \   0000001C   0x7059             STRB     R1,[R3, #+1]
    277              ep->EP_State = USB_EP_STALL;
   \   0000001E   0x2105             MOVS     R1,#+5
   \   00000020   0x7019             STRB     R1,[R3, #+0]
    278              val = USB_SEPx_CTRL_EPSSTALL_Reply |                                          /* Set STALL reply */
    279                    USB_SEPx_CTRL_EPRDY_Ready;                                              /* Set READY */
   \   00000022   0x220A             MOVS     R2,#+10
    280            }
    281          
    282            USB_EP_SetReady(EPx, val);
   \                     ??USB_EP_Stall_2:
   \   00000024   0x4611             MOV      R1,R2
   \   00000026   0x.... 0x....      BL       USB_EP_SetReady
    283          
    284            return USB_SUCCESS;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    285          }
    286          
    287          /**
    288            * @brief  Indicates that there is data to be sent to the host by this
    289            *         EndPoint with one or several IN-transactions.
    290            *
    291            * @param  EPx: USB EndPoint number.
    292            *         This parameter can be one of the following values:
    293            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    294            *
    295            * @param  Buffer: Pointer to the user's buffer with data to be sent.
    296            *
    297            * @param  Length: Length of data.
    298            *
    299            * @param  onInDone: User's handler to be called when data transfer is
    300            *                   successfully complete (may be 0).
    301            *
    302            * @retval USB_Result.
    303            */
    304          

   \                                 In section .text, align 2, keep-with-next
    305          USB_Result USB_EP_doDataIn(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onInDone)
    306          {
   \                     USB_EP_doDataIn:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    307            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000002   0x242C             MOVS     R4,#+44
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable13
   \   00000008   0xFB04 0x5500      MLA      R5,R4,R0,R5
    308            /* Setup IN Data stage starts with DATA1 */
    309            USB_EPData_Bit_TypeDef StartInStage = (ep->EP_WaitSetup ? USB_DATA_BIT_DATA1 : USB_DATA_BIT_TOGGLE);
   \   0000000C   0x7EAC             LDRB     R4,[R5, #+26]
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xBF14             ITE      NE 
   \   00000012   0x2402             MOVNE    R4,#+2
   \   00000014   0x2401             MOVEQ    R4,#+1
    310          
    311            /* Set EndPoint context */
    312            ep->Buffer.IO_Buffer.pBuffer    = Buffer;
   \   00000016   0x6069             STR      R1,[R5, #+4]
    313            ep->Buffer.IO_Buffer.length     = Length;
   \   00000018   0x60AA             STR      R2,[R5, #+8]
    314            ep->Buffer.IO_Buffer.bytesToAck = MAX_PACKET_SIZE;
   \   0000001A   0x2120             MOVS     R1,#+32
   \   0000001C   0x6129             STR      R1,[R5, #+16]
    315            ep->Buffer.IO_Buffer.offset     = 0;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x60E9             STR      R1,[R5, #+12]
    316            ep->InHandler                   = onInDone;
   \   00000022   0x61EB             STR      R3,[R5, #+28]
    317            ep->EP_State                    = USB_EP_IN;
   \   00000024   0x2102             MOVS     R1,#+2
   \   00000026   0x7029             STRB     R1,[R5, #+0]
    318          
    319            /* Send first data portion */
    320            USB_EP_sendInDataPortion(EPx, StartInStage);
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x.... 0x....      BL       USB_EP_sendInDataPortion
    321          
    322            return USB_SUCCESS;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    323          }
    324          
    325          /**
    326            * @brief  Indicates that we are willing to receive Length or more bytes of data
    327            *         from the host to this EndPoint with OUT transaction(s).
    328            *
    329            * @param  EPx: USB EndPoint number.
    330            *         This parameter can be one of the following values:
    331            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    332            *
    333            * @param  Buffer: Pointer to the user's buffer to place received data to.
    334            *                 The total buffer size should be equal or greater then
    335            *                 ((Length / MAX_PACKET_LENGTH) + 1) * MAX_PACKET_LENGTH)
    336            *
    337            * @param  Length: The minimal data length to receive before the transfer is
    338            *                 treated as complete.
    339            *
    340            * @param  onOutDone: User's handler to be called after Length or more bytes of
    341            *                    data is successfully received (may be 0).
    342            *
    343            * @retval USB_Result.
    344            */
    345          

   \                                 In section .text, align 2, keep-with-next
    346          USB_Result USB_EP_doDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onOutDone)
    347          {
   \                     USB_EP_doDataOut:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    348            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000002   0x242C             MOVS     R4,#+44
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable13
   \   00000008   0xFB04 0x5400      MLA      R4,R4,R0,R5
    349          
    350            /* Set EndPoint context */
    351            ep->Buffer.IO_Buffer.pBuffer    = Buffer;
   \   0000000C   0x6061             STR      R1,[R4, #+4]
    352            ep->Buffer.IO_Buffer.length     = Length;
   \   0000000E   0x60A2             STR      R2,[R4, #+8]
    353            ep->Buffer.IO_Buffer.bytesToAck = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6121             STR      R1,[R4, #+16]
    354            ep->Buffer.IO_Buffer.offset     = 0;
   \   00000014   0x60E1             STR      R1,[R4, #+12]
    355            ep->OutHandler                  = onOutDone;
   \   00000016   0x6223             STR      R3,[R4, #+32]
    356            ep->EP_WaitOut                  = SET;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7661             STRB     R1,[R4, #+25]
    357          
    358            /* Start awaiting for OUT transaction */
    359            USB_EP_Idle(EPx);
   \   0000001C   0x.... 0x....      BL       USB_EP_Idle
    360          
    361            return USB_SUCCESS;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    362          }
    363          
    364          /**
    365            * @brief  Indicates that we are willing to receive (repeatedly) Setup Control
    366            *         Transactions with this EndPoint.
    367            *
    368            * @param  EPx: USB EndPoint number.
    369            *         This parameter can be one of the following values:
    370            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    371            *
    372            * @param  USB_SetupPacket: Pointer to the user's buffer to place
    373            *         received setup packet.
    374            *
    375            * @param  onSetupPacket: User's handler to be called when setup packet
    376            *         is received.
    377            *
    378            * @retval USB_Result.
    379            */
    380          

   \                                 In section .text, align 2, keep-with-next
    381          USB_Result USB_EP_setSetupHandler(USB_EP_TypeDef EPx, USB_SetupPacket_TypeDef* USB_SetupPacket, USB_EP_Setup_Handler onSetupPacket)
    382          {
   \                     USB_EP_setSetupHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
    383            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000002   0x.... 0x....      BL       ?Subroutine2
    384          
    385            /* Set EndPoint context */
    386            ep->Buffer.pSetupPacket         = USB_SetupPacket;
   \                     ??CrossCallReturnLabel_4:
   \   00000006   0x6159             STR      R1,[R3, #+20]
    387            ep->Buffer.IO_Buffer.length     = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6099             STR      R1,[R3, #+8]
    388            ep->Buffer.IO_Buffer.bytesToAck = 0;
   \   0000000C   0x6119             STR      R1,[R3, #+16]
    389            ep->Buffer.IO_Buffer.offset     = 0;
   \   0000000E   0x60D9             STR      R1,[R3, #+12]
    390            ep->SetupHandler                = onSetupPacket;
   \   00000010   0x625A             STR      R2,[R3, #+36]
    391            ep->EP_WaitSetup                = onSetupPacket ? SET : RESET;
   \   00000012   0xB102             CBZ.N    R2,??USB_EP_setSetupHandler_0
   \   00000014   0x2101             MOVS     R1,#+1
   \                     ??USB_EP_setSetupHandler_0:
   \   00000016   0x7699             STRB     R1,[R3, #+26]
    392          
    393            /* Start awaiting for SETUP transaction */
    394            USB_EP_Idle(EPx);
   \   00000018   0x.... 0x....      BL       USB_EP_Idle
    395          
    396            return USB_SUCCESS;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    397          }
    398          
    399          /**
    400            * @brief  EndPoint state machine implementation.
    401            *
    402            * @param  EPx: USB EndPoint number.
    403            *         This parameter can be one of the following values:
    404            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    405            *
    406            * @param  USB_IT: SLAVE controller interrupt flags (USB_SIS register value).
    407            *
    408            * @retval USB_Result.
    409            *
    410            * @note   This function should be called at appropriate rate to handle possible
    411            *         EndPoint events.
    412            */
    413          

   \                                 In section .text, align 4, keep-with-next
    414          USB_Result USB_EP_dispatchEvent(USB_EP_TypeDef EPx, uint32_t USB_IT)
    415          {
   \                     USB_EP_dispatchEvent:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460F             MOV      R7,R1
    416            FlagStatus nextIteration = RESET;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    417            USB_Result result = USB_SUCCESS;
   \   0000000E   0x2600             MOVS     R6,#+0
    418            uint32_t tmpSTS, tmpTS, tmpCTRL;
    419            uint32_t i, count;
    420            USB_EPContext_TypeDef *ep;
    421          
    422            tmpSTS = USB_GetSEPxSTS(EPx);
   \   00000010   0x4640             MOV      R0,R8
   \   00000012   0x.... 0x....      BL       USB_GetSEPxSTS
   \   00000016   0x4681             MOV      R9,R0
    423            tmpTS  = (USB_GetSEPxTS(EPx) & USB_SEPx_TS_SCTTYPE_Msk);
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0x.... 0x....      BL       USB_GetSEPxTS
   \   0000001E   0xF000 0x0A03      AND      R10,R0,#0x3
    424            tmpCTRL = USB_GetSEPxCTRL(EPx);
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x.... 0x....      BL       USB_GetSEPxCTRL
   \   00000028   0x4604             MOV      R4,R0
    425          
    426            ep = USB_EPContext + EPx;
   \   0000002A   0x202C             MOVS     R0,#+44
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000030   0xFB00 0x1508      MLA      R5,R0,R8,R1
    427          
    428            /* Remember SCDONE event in the EndPoint context */
    429            if (USB_IT & USB_SIS_SCTDONE)
   \   00000034   0x07F8             LSLS     R0,R7,#+31
   \   00000036   0xBF44             ITT      MI 
   \   00000038   0x2001             MOVMI    R0,#+1
   \   0000003A   0x7628             STRBMI   R0,[R5, #+24]
    430            {
    431              ep->EP_WasScdone = SET;
    432            }
    433          
    434            do
    435            {
    436              switch (ep->EP_State)
   \                     ??USB_EP_dispatchEvent_1:
   \   0000003C   0x7828             LDRB     R0,[R5, #+0]
   \   0000003E   0x2805             CMP      R0,#+5
   \   00000040   0xD856             BHI.N    ??USB_EP_dispatchEvent_2
   \   00000042   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??USB_EP_dispatchEvent_0:
   \   00000046   0x03 0x05          DC8      0x3,0x5,0x1F,0x5D
   \              0x1F 0x5D    
   \   0000004A   0x91 0xB9          DC8      0x91,0xB9
    437              {
    438                /* USB_EP_NAK */
    439                case USB_EP_NAK:
    440                {
    441                  /* Fast return if EndPoint in the NAK state */
    442                  return USB_SUCCESS;
   \                     ??USB_EP_dispatchEvent_3:
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE0C6             B.N      ??USB_EP_dispatchEvent_4
    443                }
    444          
    445                /* USB_EP_IDLE */
    446                case USB_EP_IDLE:
    447                {
    448                  if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
   \                     ??USB_EP_dispatchEvent_5:
   \   00000050   0x07A0             LSLS     R0,R4,#+30
   \   00000052   0xD454             BMI.N    ??USB_EP_dispatchEvent_6
   \   00000054   0x7E28             LDRB     R0,[R5, #+24]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD051             BEQ.N    ??USB_EP_dispatchEvent_6
    449                  {
    450                    /* EPRDY dropped - event for this End Point */
    451                    if ((tmpTS == USB_SEPx_TS_SCTTYPE_Outdata) && ep->EP_WaitOut)
   \   0000005A   0xF1BA 0x0F02      CMP      R10,#+2
   \   0000005E   0xD106             BNE.N    ??USB_EP_dispatchEvent_7
   \   00000060   0x7E68             LDRB     R0,[R5, #+25]
   \   00000062   0xB160             CBZ.N    R0,??USB_EP_dispatchEvent_8
    452                    {
    453                      /* OUT transaction started: switch into the OUT state and continue processing there */
    454                      ep->EP_State = USB_EP_OUT;
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x7028             STRB     R0,[R5, #+0]
    455                      ep->EP_WaitOut = RESET;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x7668             STRB     R0,[R5, #+25]
    456                      nextIteration = SET;
   \   0000006C   0xE04D             B.N      ??USB_EP_dispatchEvent_9
    457                    }
    458                    else if ((tmpTS == USB_SEPx_TS_SCTTYPE_Setup) && ep->EP_WaitSetup)
   \                     ??USB_EP_dispatchEvent_7:
   \   0000006E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000072   0xD104             BNE.N    ??USB_EP_dispatchEvent_8
   \   00000074   0x7EA8             LDRB     R0,[R5, #+26]
   \   00000076   0xB110             CBZ.N    R0,??USB_EP_dispatchEvent_8
    459                    {
    460                      /* SETUP transaction started: switch into the SETUP state and continue processing there */
    461                      ep->EP_State = USB_EP_SETUP;
   \   00000078   0x2004             MOVS     R0,#+4
   \   0000007A   0x7028             STRB     R0,[R5, #+0]
    462                      nextIteration = SET;
   \   0000007C   0xE077             B.N      ??USB_EP_dispatchEvent_10
    463                    }
    464                    else
    465                    {
    466                      /* Unexpected transaction: switch into STALL/NAK state and return error */
    467                      result = USB_ERROR;
   \                     ??USB_EP_dispatchEvent_8:
   \   0000007E   0x2601             MOVS     R6,#+1
    468                      USB_EP_Stall(EPx, USB_STALL_PROTO);
    469                    }
    470                  }
    471                  break;
    472                }
    473          
    474                /* USB_EP_IN */
    475                case USB_EP_IN:
    476                {
    477                  /* Analyze event type */
    478                  if ((!(tmpCTRL & USB_SEP_CTRL_EPRDY)) && ep->EP_WasScdone &&
    479                      (tmpTS == USB_SEPx_TS_SCTTYPE_In) && (tmpSTS & USB_SEP_STS_SCACKRXED))
    480                  {
    481                    /* 1. ACK event */
    482                    ep->Buffer.IO_Buffer.offset += ep->Buffer.IO_Buffer.bytesToAck;
    483                    if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
    484                    {
    485                      /* If offset >= length (transfer is over), indicate it with NAK state
    486                       * and call handler (if present) */
    487                      ep->EP_State = USB_EP_NAK;
    488                      if (ep->InHandler != 0)
    489                      {
    490                        result = ep->InHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.length);
    491                      }
    492          
    493                      if (result == USB_SUCCESS)
    494                      {
    495                        /* If no other transaction is ordered by user or no data stage of SETUP
    496                         * packet (state isn't changed), go to NAK/IDLE state */
    497                        if (ep->EP_State == USB_EP_NAK)
    498                        {
    499                          USB_EP_Idle(EPx);
    500                        }
    501                      }
    502                      else
    503                      {
    504                        /* If user's handler indicated error, go to STALL/NAK state */
    505                        USB_EP_Stall(EPx, USB_STALL_PROTO);
    506                      }
    507                    }
    508                    else
    509                    {
    510                      /* If there is any data to send remaining, send next portion */
    511                      USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_TOGGLE);
    512                    }
    513                  }
    514                  else if (tmpSTS & (USB_SEP_STS_SCRXOF
    515                                   | USB_SEP_STS_SCCRCERR
    516                                   | USB_SEP_STS_SCBSERR
    517                                   | USB_SEP_STS_SCRXTO))
    518                  {
    519                    /* 2. Error events - call error handler (if present). Switch temporarily to NAK
    520                     * to check if user orders another transaction */
    521                    ep->EP_State = USB_EP_NAK;
    522                    if (ep->ErrorHandler != 0)
    523                    {
    524                      result = ep->ErrorHandler(EPx, tmpSTS, tmpTS, tmpCTRL);
    525                    }
    526                    if (result == USB_SUCCESS)
    527                    {
    528                      if (ep->EP_State == USB_EP_NAK)
    529                      {
    530                        /* If there is no user's handler or USB_SUCCESS returned and no other transaction
    531                         * is started, retry with current data portion */
    532                        ep->EP_State = USB_EP_IN;
    533                        USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_KEEP);
    534                      }
    535                    }
    536                    else
    537                    {
    538                      /* If user's handler indicated error, go to STALL/NAK state */
    539                      USB_EP_Stall(EPx, USB_STALL_PROTO);
    540                    }
    541                  }
    542                  break;
    543                }
    544          
    545                /* USB_EP_OUT */
    546                case USB_EP_OUT:
    547                {
    548                  /* Check for event */
    549                  if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
    550                  {
    551                    nextIteration = RESET;
    552          
    553                    /* Read data packet */
    554                    count = USB_GetSEPxRXFDC(EPx);
    555                    for (i = 0; i < count; i++)
    556                    {
    557                      ep->Buffer.IO_Buffer.pBuffer[ep->Buffer.IO_Buffer.offset + i] = EPx_RX_FIFO_DATA(EPx);
    558                    }
    559                    RX_FIFO_FORCE_EMPTY(EPx);
    560                    ep->Buffer.IO_Buffer.offset += count;
    561          
    562                    /* If offset >= length (transfer is over), indicate it with NAK state
    563                     * and call handler (if present) */
    564                    if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
    565                    {
    566                      ep->EP_State = USB_EP_NAK;
    567                      if (ep->OutHandler != 0)
    568                      {
    569                        result = ep->OutHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.offset);
    570                      }
    571          
    572                      if (result == USB_SUCCESS)
    573                      {
    574                        /* If no other transaction is ordered by user or no data stage of SETUP
    575                         * packet (state isn't changed), go to NAK/IDLE state */
    576                        if (ep->EP_State == USB_EP_NAK)
    577                        {
    578                          USB_EP_Idle(EPx);
    579                        }
    580                      }
    581                      else
    582                      {
    583                        /* If user's handler indicated error, go to STALL/NAK state */
    584                        USB_EP_Stall(EPx, USB_STALL_PROTO);
   \                     ??USB_EP_dispatchEvent_11:
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xE09F             B.N      ??USB_EP_dispatchEvent_12
    585                      }
   \                     ??USB_EP_dispatchEvent_13:
   \   00000084   0x07A0             LSLS     R0,R4,#+30
   \   00000086   0xD41F             BMI.N    ??USB_EP_dispatchEvent_14
   \   00000088   0x7E28             LDRB     R0,[R5, #+24]
   \   0000008A   0xB1E8             CBZ.N    R0,??USB_EP_dispatchEvent_14
   \   0000008C   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000090   0xD11A             BNE.N    ??USB_EP_dispatchEvent_14
   \   00000092   0xEA5F 0x6049      LSLS     R0,R9,#+25
   \   00000096   0xD517             BPL.N    ??USB_EP_dispatchEvent_14
   \   00000098   0x68E8             LDR      R0,[R5, #+12]
   \   0000009A   0x6929             LDR      R1,[R5, #+16]
   \   0000009C   0x1808             ADDS     R0,R1,R0
   \   0000009E   0x60E8             STR      R0,[R5, #+12]
   \   000000A0   0x68AA             LDR      R2,[R5, #+8]
   \   000000A2   0x4290             CMP      R0,R2
   \   000000A4   0xD30E             BCC.N    ??USB_EP_dispatchEvent_15
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7028             STRB     R0,[R5, #+0]
   \   000000AA   0x69EB             LDR      R3,[R5, #+28]
   \   000000AC   0x0018             MOVS     R0,R3
   \   000000AE   0xD003             BEQ.N    ??USB_EP_dispatchEvent_16
   \   000000B0   0x6869             LDR      R1,[R5, #+4]
   \   000000B2   0x4640             MOV      R0,R8
   \   000000B4   0x4798             BLX      R3
   \   000000B6   0x4606             MOV      R6,R0
   \                     ??USB_EP_dispatchEvent_16:
   \   000000B8   0x2E00             CMP      R6,#+0
   \   000000BA   0xD1E1             BNE.N    ??USB_EP_dispatchEvent_11
   \   000000BC   0x7828             LDRB     R0,[R5, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD116             BNE.N    ??USB_EP_dispatchEvent_2
   \   000000C2   0xE083             B.N      ??USB_EP_dispatchEvent_17
   \                     ??USB_EP_dispatchEvent_15:
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0xE017             B.N      ??USB_EP_dispatchEvent_18
   \                     ??USB_EP_dispatchEvent_14:
   \   000000C8   0xF019 0x0F0F      TST      R9,#0xF
   \   000000CC   0xD017             BEQ.N    ??USB_EP_dispatchEvent_6
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x7028             STRB     R0,[R5, #+0]
   \   000000D2   0xF8D5 0xC028      LDR      R12,[R5, #+40]
   \   000000D6   0xEA5F 0x000C      MOVS     R0,R12
   \   000000DA   0xD005             BEQ.N    ??USB_EP_dispatchEvent_19
   \   000000DC   0x4623             MOV      R3,R4
   \   000000DE   0x4652             MOV      R2,R10
   \   000000E0   0x4649             MOV      R1,R9
   \   000000E2   0x4640             MOV      R0,R8
   \   000000E4   0x47E0             BLX      R12
   \   000000E6   0x4606             MOV      R6,R0
   \                     ??USB_EP_dispatchEvent_19:
   \   000000E8   0x2E00             CMP      R6,#+0
   \   000000EA   0xD1C9             BNE.N    ??USB_EP_dispatchEvent_11
   \   000000EC   0x7828             LDRB     R0,[R5, #+0]
   \   000000EE   0x2800             CMP      R0,#+0
   \                     ??USB_EP_dispatchEvent_2:
   \   000000F0   0xD16F             BNE.N    ??USB_EP_dispatchEvent_20
   \   000000F2   0x2002             MOVS     R0,#+2
   \   000000F4   0x7028             STRB     R0,[R5, #+0]
   \   000000F6   0x2100             MOVS     R1,#+0
   \                     ??USB_EP_dispatchEvent_18:
   \   000000F8   0x4640             MOV      R0,R8
   \   000000FA   0x.... 0x....      BL       USB_EP_sendInDataPortion
   \                     ??USB_EP_dispatchEvent_6:
   \   000000FE   0xE068             B.N      ??USB_EP_dispatchEvent_20
   \                     ??USB_EP_dispatchEvent_21:
   \   00000100   0x07A0             LSLS     R0,R4,#+30
   \   00000102   0xD466             BMI.N    ??USB_EP_dispatchEvent_20
   \   00000104   0x7E28             LDRB     R0,[R5, #+24]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD063             BEQ.N    ??USB_EP_dispatchEvent_20
   \                     ??USB_EP_dispatchEvent_9:
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000110   0x4640             MOV      R0,R8
   \   00000112   0x.... 0x....      BL       USB_GetSEPxRXFDC
   \   00000116   0x4683             MOV      R11,R0
   \   00000118   0x2700             MOVS     R7,#+0
   \   0000011A   0xE007             B.N      ??USB_EP_dispatchEvent_22
   \                     ??USB_EP_dispatchEvent_23:
   \   0000011C   0x4640             MOV      R0,R8
   \   0000011E   0x.... 0x....      BL       USB_GetSEPxRXFD
   \   00000122   0x68E9             LDR      R1,[R5, #+12]
   \   00000124   0x1879             ADDS     R1,R7,R1
   \   00000126   0x686A             LDR      R2,[R5, #+4]
   \   00000128   0x5488             STRB     R0,[R1, R2]
   \   0000012A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??USB_EP_dispatchEvent_22:
   \   0000012C   0x455F             CMP      R7,R11
   \   0000012E   0xD3F5             BCC.N    ??USB_EP_dispatchEvent_23
   \   00000130   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   00000134   0x68E8             LDR      R0,[R5, #+12]
   \   00000136   0xEB0B 0x0200      ADD      R2,R11,R0
   \   0000013A   0x60EA             STR      R2,[R5, #+12]
   \   0000013C   0x68A8             LDR      R0,[R5, #+8]
   \   0000013E   0x4282             CMP      R2,R0
   \   00000140   0xD30D             BCC.N    ??USB_EP_dispatchEvent_24
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x7028             STRB     R0,[R5, #+0]
   \   00000146   0x6A2B             LDR      R3,[R5, #+32]
   \   00000148   0x0018             MOVS     R0,R3
   \   0000014A   0xD003             BEQ.N    ??USB_EP_dispatchEvent_25
   \   0000014C   0x6869             LDR      R1,[R5, #+4]
   \   0000014E   0x4640             MOV      R0,R8
   \   00000150   0x4798             BLX      R3
   \   00000152   0x4606             MOV      R6,R0
   \                     ??USB_EP_dispatchEvent_25:
   \   00000154   0x2E00             CMP      R6,#+0
   \   00000156   0xD193             BNE.N    ??USB_EP_dispatchEvent_11
   \   00000158   0x7828             LDRB     R0,[R5, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xE01F             B.N      ??USB_EP_dispatchEvent_26
    586                    }
    587                    else
    588                    {
    589                      /* If offset < length, wait for another portion */
    590                      USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
   \                     ??USB_EP_dispatchEvent_24:
   \   0000015E   0x2102             MOVS     R1,#+2
   \   00000160   0x4640             MOV      R0,R8
   \   00000162   0x.... 0x....      BL       USB_EP_SetReady
   \   00000166   0xE039             B.N      ??USB_EP_dispatchEvent_27
    591                    }
    592                  }
    593                  break;
    594                }
    595          
    596                /* USB_EP_SETUP */
    597                case USB_EP_SETUP:
    598                {
    599                  /* Check for event */
    600                  if (ep->EP_WasScdone)
   \                     ??USB_EP_dispatchEvent_28:
   \   00000168   0x7E28             LDRB     R0,[R5, #+24]
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD036             BEQ.N    ??USB_EP_dispatchEvent_27
    601                  {
    602                    assert_param(ep->SetupHandler);
    603          
    604                    /* Read setup packet and check for correct size (8 bytes) */
    605                    count = USB_GetSEPxRXFDC(EPx);
    606                    if (count == 8)
   \                     ??USB_EP_dispatchEvent_10:
   \   0000016E   0x4640             MOV      R0,R8
   \   00000170   0x.... 0x....      BL       USB_GetSEPxRXFDC
   \   00000174   0x2808             CMP      R0,#+8
   \   00000176   0xD117             BNE.N    ??USB_EP_dispatchEvent_29
    607                    {
    608                      for (i = 0; i < count; i++)
   \   00000178   0x2700             MOVS     R7,#+0
    609                      {
    610                        ((uint8_t*)ep->Buffer.pSetupPacket)[i] = EPx_RX_FIFO_DATA(EPx);
   \                     ??USB_EP_dispatchEvent_30:
   \   0000017A   0x4640             MOV      R0,R8
   \   0000017C   0x.... 0x....      BL       USB_GetSEPxRXFD
   \   00000180   0x6969             LDR      R1,[R5, #+20]
   \   00000182   0x5478             STRB     R0,[R7, R1]
    611                      }
   \   00000184   0x1C7F             ADDS     R7,R7,#+1
   \   00000186   0x2F08             CMP      R7,#+8
   \   00000188   0xD3F7             BCC.N    ??USB_EP_dispatchEvent_30
    612                      RX_FIFO_FORCE_EMPTY(EPx);
   \   0000018A   0x.... 0x....      BL       ?Subroutine1
    613          
    614                      /* Call the handler */
    615                      result = ep->SetupHandler(EPx, ep->Buffer.pSetupPacket);
   \                     ??CrossCallReturnLabel_1:
   \   0000018E   0x6969             LDR      R1,[R5, #+20]
   \   00000190   0x4640             MOV      R0,R8
   \   00000192   0x6A6A             LDR      R2,[R5, #+36]
   \   00000194   0x4790             BLX      R2
   \   00000196   0x0006             MOVS     R6,R0
    616          
    617                      if (result == USB_SUCCESS)
   \   00000198   0xD109             BNE.N    ??USB_EP_dispatchEvent_31
    618                      {
    619                        /* If no other transaction is ordered by user or no data stage of SETUP
    620                         * packet (state isn't changed), go to NAK/IDLE state */
    621                        if (ep->EP_State == USB_EP_SETUP)
   \   0000019A   0x7828             LDRB     R0,[R5, #+0]
   \   0000019C   0x2804             CMP      R0,#+4
   \                     ??USB_EP_dispatchEvent_26:
   \   0000019E   0xD11D             BNE.N    ??USB_EP_dispatchEvent_27
    622                        {
    623                          USB_EP_Idle(EPx);
   \   000001A0   0x4640             MOV      R0,R8
   \   000001A2   0x.... 0x....      BL       USB_EP_Idle
   \   000001A6   0xE019             B.N      ??USB_EP_dispatchEvent_27
    624                        }
    625                      }
    626                      else
    627                      {
    628                        /* If user's handler indicated error, go to STALL/NAK state */
    629                        USB_EP_Stall(EPx, USB_STALL_PROTO);
    630                      }
    631                    }
    632                    else /* Incorrect packet size */
    633                    {
    634                      RX_FIFO_FORCE_EMPTY(EPx);
   \                     ??USB_EP_dispatchEvent_29:
   \   000001A8   0x.... 0x....      BL       ?Subroutine1
    635                      result = USB_ERROR;
   \                     ??CrossCallReturnLabel_0:
   \   000001AC   0x2601             MOVS     R6,#+1
    636                      /* Switch into STALL state */
    637                      USB_EP_Stall(EPx, USB_STALL_PROTO);
   \                     ??USB_EP_dispatchEvent_31:
   \   000001AE   0x2100             MOVS     R1,#+0
   \   000001B0   0x4640             MOV      R0,R8
   \   000001B2   0x.... 0x....      BL       USB_EP_Stall
   \   000001B6   0xE011             B.N      ??USB_EP_dispatchEvent_27
    638                    }
    639                  }
    640                  nextIteration = RESET;
    641                  break;
    642                }
    643          
    644                /* USB_EP_STALL */
    645                case USB_EP_STALL:
    646                {
    647                  if (!(tmpCTRL & USB_SEP_CTRL_EPRDY))
   \                     ??USB_EP_dispatchEvent_32:
   \   000001B8   0x07A0             LSLS     R0,R4,#+30
   \   000001BA   0xD40A             BMI.N    ??USB_EP_dispatchEvent_20
    648                  {
    649                    /* EPRDY dropped - event for this End Point */
    650                    if (ep->EP_Halt == USB_STALL_HALT)
   \   000001BC   0x7868             LDRB     R0,[R5, #+1]
   \   000001BE   0x2801             CMP      R0,#+1
   \   000001C0   0xD104             BNE.N    ??USB_EP_dispatchEvent_17
    651                    {
    652                      USB_EP_Stall(EPx, USB_STALL_HALT);
   \   000001C2   0x2101             MOVS     R1,#+1
   \                     ??USB_EP_dispatchEvent_12:
   \   000001C4   0x4640             MOV      R0,R8
   \   000001C6   0x.... 0x....      BL       USB_EP_Stall
   \   000001CA   0xE002             B.N      ??USB_EP_dispatchEvent_20
    653                    }
    654                    else
    655                    {
    656                      USB_EP_Idle(EPx);
   \                     ??USB_EP_dispatchEvent_17:
   \   000001CC   0x4640             MOV      R0,R8
   \   000001CE   0x.... 0x....      BL       USB_EP_Idle
    657                    }
    658                  }
    659                  break;
    660                }
    661              }
    662            } while (nextIteration);
   \                     ??USB_EP_dispatchEvent_20:
   \   000001D2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001D6   0x2800             CMP      R0,#+0
   \   000001D8   0xF47F 0xAF30      BNE.W    ??USB_EP_dispatchEvent_1
    663          
    664            return result;
   \                     ??USB_EP_dispatchEvent_27:
   \   000001DC   0x4630             MOV      R0,R6
   \                     ??USB_EP_dispatchEvent_4:
   \   000001DE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    665          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x4640             MOV      R0,R8
   \   00000004   0x.... 0x....      B.W      USB_SetSEPxRXFC
    666          
    667          /**
    668            * @brief  Prepares EndPoint for IN transaction accepting (service function).
    669            *
    670            * @param  EPx: USB EndPoint number.
    671            *         This parameter can be one of the following values:
    672            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    673            *
    674            * @param  DataBitChange: DATA bit handling.
    675            *         This parameter can be one of the following values:
    676            *           @arg USB_DATA_BIT_KEEP: Don't change DATA bit.
    677            *           @arg USB_DATA_BIT_TOGGLE: Toggle DATA0/DATA1.
    678            *           @arg USB_DATA_BIT_DATA1: Set DATA1.
    679            *
    680            * @retval USB_Result.
    681            */
    682          

   \                                 In section .text, align 2, keep-with-next
    683          static void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange)
    684          {
   \                     USB_EP_sendInDataPortion:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    685            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
   \   00000006   0x202C             MOVS     R0,#+44
   \   00000008   0x....             LDR.N    R1,??DataTable13
   \   0000000A   0xFB00 0x1604      MLA      R6,R0,R4,R1
    686            uint32_t i, total;
    687          
    688            assert_param(ep->EP_State == USB_EP_IN);
    689          
    690            /* Clean TX FIFO buffer */
    691            TX_FIFO_FORCE_EMPTY(EPx);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       USB_SetSEPxTXFDC
    692          
    693            /* Adjust DATA bit */
    694            switch (DataBitChange)
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD006             BEQ.N    ??USB_EP_sendInDataPortion_0
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xBF02             ITTT     EQ 
   \   0000001E   0x2104             MOVEQ    R1,#+4
   \   00000020   0x4620             MOVEQ    R0,R4
   \   00000022   0x.... 0x....      BLEQ     USB_SetSEPxCTRL
   \   00000026   0xE002             B.N      ??USB_EP_sendInDataPortion_1
    695            {
    696              case USB_DATA_BIT_KEEP:
    697                break;
    698              case USB_DATA_BIT_TOGGLE:
    699                USB_SEPxToggleEPDATASEQ(EPx);
   \                     ??USB_EP_sendInDataPortion_0:
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       USB_SEPxToggleEPDATASEQ
    700                break;
    701              case USB_DATA_BIT_DATA1:
    702                USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPDATASEQ_Data1);
    703                break;
    704            }
    705          
    706            /* Copy data portion into TX FIFO buffer */
    707            total = (ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck < ep->Buffer.IO_Buffer.length ?
    708                      ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck : ep->Buffer.IO_Buffer.length);
   \                     ??USB_EP_sendInDataPortion_1:
   \   0000002E   0x68F5             LDR      R5,[R6, #+12]
   \   00000030   0x6930             LDR      R0,[R6, #+16]
   \   00000032   0x1947             ADDS     R7,R0,R5
   \   00000034   0x68B0             LDR      R0,[R6, #+8]
   \   00000036   0x4287             CMP      R7,R0
   \   00000038   0xD907             BLS.N    ??USB_EP_sendInDataPortion_2
   \   0000003A   0x4607             MOV      R7,R0
    709            for (i = ep->Buffer.IO_Buffer.offset; i < total; i++)
   \   0000003C   0xE005             B.N      ??USB_EP_sendInDataPortion_2
    710            {
    711              USB_SetSEPxTXFD(EPx, ep->Buffer.IO_Buffer.pBuffer[i]);
   \                     ??USB_EP_sendInDataPortion_3:
   \   0000003E   0x6870             LDR      R0,[R6, #+4]
   \   00000040   0x5C29             LDRB     R1,[R5, R0]
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       USB_SetSEPxTXFD
    712            };
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
   \                     ??USB_EP_sendInDataPortion_2:
   \   0000004A   0x42BD             CMP      R5,R7
   \   0000004C   0xD3F7             BCC.N    ??USB_EP_sendInDataPortion_3
    713          
    714            /* Set EPRDY bit */
    715            USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
   \   0000004E   0x2102             MOVS     R1,#+2
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   00000056                      REQUIRE USB_EP_SetReady
   \   00000056                      ;; // Fall through to label USB_EP_SetReady
    716          }
    717          
    718          
    719          /**
    720            * @brief  Sets EPRDY and STALL bits (service function).
    721            *
    722            * @param  EPx: USB EndPoint number.
    723            *         This parameter can be one of the following values:
    724            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
    725            *
    726            * @param  val: Value for SEPxCTRL register.
    727            *
    728            * @retval USB_Result.
    729            *
    730            * @note   Before setting EPRDY, the function clears pending
    731            *         bits (especially SCTDONE), to indicate that previous
    732            *         transaction is complete.
    733            */
    734          

   \                                 In section .text, align 2, keep-with-next
    735          static void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val)
    736          {
   \                     USB_EP_SetReady:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    737            USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
    738          
    739            /* Clear pending bits */
    740            USB_SetSIS(USB_SIS_Msk);
   \   00000006   0x201F             MOVS     R0,#+31
   \   00000008   0x.... 0x....      BL       USB_SetSIS
    741          
    742            ep->EP_WasScdone = RESET;
   \   0000000C   0x202C             MOVS     R0,#+44
   \   0000000E   0x....             LDR.N    R1,??DataTable13
   \   00000010   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7601             STRB     R1,[R0, #+24]
    743          
    744            /* Set CTRL bits */
    745            USB_SetSEPxCTRL(EPx, val);
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000020   0x.... 0x....      B.W      USB_SetSEPxCTRL
    746          }
    747          
    748          /** @} */ /* End of group USB_EndPoint_Private_Functions */
    749          
    750          /** @} */ /* End of group USB_EndPoint */
    751          
    752          /** @defgroup USB_Device USB Device
    753            * @{
    754            */
    755          
    756          /** @defgroup USB_Device_Private_Types USB Device Private Types
    757            * @{
    758            */
    759          
    760          /** @} */ /* End of group USB_Device_Private_Types */
    761          
    762          /** @defgroup USB_Device_Private_Constants USB Device Private Constants
    763            * @{
    764            */
    765          
    766          /** @} */ /* End of group USB_Device_Private_Constants */
    767          
    768          /** @defgroup USB_Device_Private_Variables USB Device Private Variables
    769            * @{
    770            */
    771          
    772          USB_SetupPacket_TypeDef USB_CurrentSetupPacket;
    773          USB_DeviceContext_TypeDef USB_DeviceContext;
    774          static uint8_t SetupPacketData[2];
    775          
    776          /** @} */ /* End of group USB_Device_Private_Variables */
    777          
    778          /** @defgroup USB_Device_Private_Macros USB Device Private Macros
    779            * @{
    780            */
    781          
    782          /** @} */ /* End of group USB_Device_Private_Macros */
    783          
    784          /** @defgroup USB_Device_Private_FunctionPrototypes USB Device Private Function Prototypes
    785            * @{
    786            */
    787          
    788          static USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length);
    789          
    790          /** @} */ /* End of group USB_Device_Private_FunctionPrototypes */
    791          
    792          /** @defgroup USB_Device_Private_Functions USB Device Private Functions
    793            * @{
    794            */
    795          
    796          /**
    797            * @brief  Initializes the USB peripheral according to the specified
    798            *         parameters in the USB_Clock_InitStruct.
    799            * @param  USB_Clock_InitStruct: pointer to a USB_Clock_TypeDef structure
    800            *         that contains the configuration information for the USB Clock.
    801            *
    802            * @param  USB_DeviceBUSParam: pointer to a USB_DeviceBUSParam_TypeDef structure
    803            *         that contains the configuration information for the USB BUS
    804            *
    805            * @retval USB_Result.
    806            */
    807          

   \                                 In section .text, align 2, keep-with-next
    808          USB_Result USB_DeviceInit(const USB_Clock_TypeDef* USB_Clock_InitStruct, USB_DeviceBUSParam_TypeDef* USB_DeviceBUSParam)
    809          {
   \                     USB_DeviceInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    810            /* Check the parameters */
    811            assert_param(IS_USB_PULL(USB_DeviceBUSParam->PULL));
    812            assert_param(IS_USB_SPEED(USB_DeviceBUSParam->SPEED));
    813            assert_param(IS_USB_MODE(USB_DeviceBUSParam->MODE));
    814          
    815            /* Set USB clocks perform controller reset */
    816            USB_BRGInit(USB_Clock_InitStruct);
   \   00000004   0x.... 0x....      BL       USB_BRGInit
    817            USB_Reset();
   \   00000008   0x.... 0x....      BL       USB_Reset
    818            /* Set pulls and Device mode */
    819            USB_SetHSCR(USB_HSCR_HOST_MODE_Device);
   \   0000000C   0xF44F 0x3080      MOV      R0,#+65536
   \   00000010   0x.... 0x....      BL       USB_SetHSCR
    820            USB_SetHSCR(USB_DeviceBUSParam->PULL);
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       USB_SetHSCR
    821            /* Set speed, polarity and enable end points */
    822            USB_SetSC(USB_DeviceBUSParam->SPEED | USB_DeviceBUSParam->MODE | USB_SC_SCGEN_Set);
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x4308             ORRS     R0,R1,R0
   \   00000020   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000024   0x.... 0x....      BL       USB_SetSC
    823            /* Setup EP0 */
    824            USB_EP_Init(USB_EP0, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1, 0);
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x2105             MOVS     R1,#+5
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      BL       USB_EP_Init
    825            USB_EP_setSetupHandler(USB_EP0, &USB_CurrentSetupPacket, USB_DEVICE_HANDLE_SETUP);
   \   00000032   0x....             LDR.N    R4,??DataTable13_3
   \   00000034   0x.... 0x....      ADR.W    R2,USB_DeviceSetupPacket
   \   00000038   0xF104 0x0114      ADD      R1,R4,#+20
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       USB_EP_setSetupHandler
    826          
    827            USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7120             STRB     R0,[R4, #+4]
    828            USB_DeviceContext.Address = 0;
   \   00000046   0x60E0             STR      R0,[R4, #+12]
    829          
    830            return USB_SUCCESS;
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    831          }
    832          
    833          /**
    834            * @brief  Enables the USB peripheral.
    835            *
    836            * @param  None
    837            *
    838            * @retval USB_Result.
    839            */
    840          

   \                                 In section .text, align 2, keep-with-next
    841          USB_Result USB_DevicePowerOn(void)
    842          {
   \                     USB_DevicePowerOn:
   \   00000000   0xB580             PUSH     {R7,LR}
    843            USB_SetHSCR(USB_HSCR_EN_RX_Set | USB_HSCR_EN_TX_Set);
   \   00000002   0x200C             MOVS     R0,#+12
   \   00000004   0x.... 0x....      BL       USB_SetHSCR
    844            USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_POWERED;
   \   00000008   0x....             LDR.N    R0,??DataTable13_3
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x....             B.N      ?Subroutine0
    845          
    846            return USB_SUCCESS;
    847          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x7101             STRB     R1,[R0, #+4]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xBD02             POP      {R1,PC}          ;; return
    848          
    849          /**
    850            * @brief  Disables the USB peripheral.
    851            *
    852            * @param  None
    853            *
    854            * @retval USB_Result.
    855            */
    856          

   \                                 In section .text, align 2, keep-with-next
    857          USB_Result USB_DevicePowerOff(void)
    858          {
   \                     USB_DevicePowerOff:
   \   00000000   0xB580             PUSH     {R7,LR}
    859            USB_SetHSCR(USB_HSCR_EN_RX_Reset);
   \   00000002   0xF44F 0x2000      MOV      R0,#+524288
   \   00000006   0x.... 0x....      BL       USB_SetHSCR
    860            USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
   \   0000000A   0x....             LDR.N    R0,??DataTable13_3
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E                      REQUIRE ?Subroutine0
   \   0000000E                      ;; // Fall through to label ?Subroutine0
    861          
    862            return USB_SUCCESS;
    863          }
    864          
    865          #ifdef USB_REMOTE_WAKEUP_SUPPORTED
    866          /**
    867            * @brief  Initiates host remote wakeup
    868            *
    869            * @param  None
    870            *
    871            * @retval USB_Result.
    872            */
    873          
    874          USB_Result USB_DeviceRemoteWakeUp(void)
    875          {
    876            return USB_SUCCESS;
    877          }
    878          #endif /* USB_REMOTE_WAKEUP_SUPPORTED */
    879          
    880          /** @defgroup USB_Device_Private_Handlers USB Device Handlers implementation
    881            * @{
    882            */
    883          
    884          /**
    885            * @brief  Reset bus handler
    886            *
    887            * @param  None
    888            *
    889            * @retval USB_Result.
    890            */
    891          

   \                                 In section .text, align 2, keep-with-next
    892          USB_Result USB_DeviceReset(void)
    893          {
    894            USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_DEFAULT;
   \                     USB_DeviceReset:
   \   00000000   0x....             LDR.N    R0,??DataTable13_3
   \   00000002   0x2103             MOVS     R1,#+3
   \   00000004   0x7101             STRB     R1,[R0, #+4]
    895            return USB_SUCCESS;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
    896          }
    897          
    898          /**
    899            * @brief  Performs all necessary actions on entering to SUSPENDED state
    900            *
    901            * @param  None
    902            *
    903            * @retval USB_Result.
    904            */
    905          

   \                                 In section .text, align 2, keep-with-next
    906          USB_Result USB_DeviceSuspend(void)
    907          {
    908            return USB_SUCCESS;
   \                     USB_DeviceSuspend:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    909          }
    910          
    911          /**
    912            * @brief  Performs all necessary actions on exit from SUSPENDED state
    913            *
    914            * @param  None
    915            *
    916            * @retval USB_Result.
    917            */
    918          

   \                                 In section .text, align 2, keep-with-next
    919          USB_Result USB_DeviceResume(void)
    920          {
    921            return USB_SUCCESS;
   \                     USB_DeviceResume:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    922          }
    923          
    924          /**
    925            * @brief  Control Setup Packet processing dispatcher (set as EP0 setup
    926            *         packet handler).
    927            *
    928            * @param  EPx: USB Control EndPoint (EP0) number.
    929            *
    930            * @param  USB_SetupPacket: Pointer to a USB_SetupPacket_TypeDef structure
    931            *         that contains received setup packet contents (on success)
    932            *
    933            * @retval USB_Result.
    934            *
    935            * @note   This function interface reflects EndPoint setup packet handler
    936            *         requirements. Request setup packet data is placed into
    937            *         USB_CurrentSetupPacket variable to be accessible from the
    938            *         specific request type handlers.
    939            */
    940          

   \                                 In section .text, align 4, keep-with-next
    941          USB_Result USB_DeviceSetupPacket(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket)
    942          {
   \                     USB_DeviceSetupPacket:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x460E             MOV      R6,R1
    943            USB_RequestType_TypeDef requestType;
    944            USB_RequestTypeDT_TypeDef requestDirection;
    945          
    946            USB_Result result = USB_SUCCESS;
   \   00000008   0x2000             MOVS     R0,#+0
    947            uint16_t wValue, wIndex, wLength;
    948          
    949            /* Check the parameters */
    950            assert_param(IS_USB_ENDPOINT(EPx));
    951          
    952            /* Determine request type */
    953            requestType = (USB_RequestType_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_TYPE_Msk);
    954            requestDirection = (USB_RequestTypeDT_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_DT_Msk);
   \   0000000A   0x7831             LDRB     R1,[R6, #+0]
   \   0000000C   0xF001 0x0E80      AND      LR,R1,#0x80
    955          
    956            /* Process request */
    957            switch (requestType)
   \   00000010   0xF011 0x0260      ANDS     R2,R1,#0x60
   \   00000014   0xD005             BEQ.N    ??USB_DeviceSetupPacket_1
   \   00000016   0x2A20             CMP      R2,#+32
   \   00000018   0xF000 0x8099      BEQ.W    ??USB_DeviceSetupPacket_2
   \   0000001C   0x2A40             CMP      R2,#+64
   \   0000001E   0xD01E             BEQ.N    ??USB_DeviceSetupPacket_3
   \                     ??USB_DeviceSetupPacket_4:
   \   00000020   0xE09B             B.N      ??USB_DeviceSetupPacket_5
    958            {
    959              /* Standard request */
    960              case USB_TYPE_STANDARD: {
    961                USB_RequestRecipient_TypeDef recipient;
    962                USB_EP_IO_Handler statusAckHandler = 0;
   \                     ??USB_DeviceSetupPacket_1:
   \   00000022   0x2700             MOVS     R7,#+0
    963          
    964                wValue = USB_SetupPacket->wValue;
   \   00000024   0x8874             LDRH     R4,[R6, #+2]
    965                wIndex = USB_SetupPacket->wIndex;
   \   00000026   0xF8B6 0xC004      LDRH     R12,[R6, #+4]
    966                wLength = USB_SetupPacket->wLength;
   \   0000002A   0xF8B6 0x8006      LDRH     R8,[R6, #+6]
    967          
    968                /* Recipient check */
    969                recipient = (USB_RequestRecipient_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_RECIPIENT_TYPE_Msk);
   \   0000002E   0xF001 0x031F      AND      R3,R1,#0x1F
    970                if (!IS_VALID_USB_RECIPIENT(recipient)) {
   \   00000032   0x2B04             CMP      R3,#+4
   \   00000034   0xD2F4             BCS.N    ??USB_DeviceSetupPacket_4
    971                  result = USB_ERR_INV_REQ;
    972                  break;
    973                }
    974                /* Specific requests */
    975                switch (USB_SetupPacket->bRequest)
   \   00000036   0x....             LDR.N    R1,??DataTable13_3
   \   00000038   0x7875             LDRB     R5,[R6, #+1]
   \   0000003A   0x2D0C             CMP      R5,#+12
   \   0000003C   0xD8F0             BHI.N    ??USB_DeviceSetupPacket_4
   \   0000003E   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??USB_DeviceSetupPacket_0:
   \   00000042   0x07 0x36          DC8      0x7,0x36,0x8C,0x46
   \              0x8C 0x46    
   \   00000046   0x8C 0x56          DC8      0x8C,0x56,0x5A,0x8A
   \              0x5A 0x8A    
   \   0000004A   0x60 0x69          DC8      0x60,0x69,0x71,0x76
   \              0x71 0x76    
   \   0000004E   0x8A 0x00          DC8      0x8A,0x0
    976                {
    977                  /* GET_STATUS */
    978                  case USB_GET_STATUS:
    979                    if (requestDirection != USB_DEVICE_TO_HOST ||
    980                       (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
    981                        recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
   \                     ??USB_DeviceSetupPacket_6:
   \   00000050   0xF1BE 0x0F80      CMP      LR,#+128
   \   00000054   0xD163             BNE.N    ??USB_DeviceSetupPacket_7
   \   00000056   0x7908             LDRB     R0,[R1, #+4]
   \   00000058   0x2804             CMP      R0,#+4
   \   0000005A   0xD106             BNE.N    ??USB_DeviceSetupPacket_8
   \   0000005C   0x2B01             CMP      R3,#+1
   \                     ??USB_DeviceSetupPacket_3:
   \   0000005E   0xD07A             BEQ.N    ??USB_DeviceSetupPacket_9
   \   00000060   0x2B02             CMP      R3,#+2
   \   00000062   0xD102             BNE.N    ??USB_DeviceSetupPacket_8
   \   00000064   0xF1BC 0x0F04      CMP      R12,#+4
   \   00000068   0xDA75             BGE.N    ??USB_DeviceSetupPacket_9
    982                    {
    983                      result = USB_ERROR;
    984                    }
    985                    else
    986                    {
    987                      /* Give user a chance to set flags in the device context */
    988                      result = USB_DEVICE_HANDLE_GET_STATUS(recipient, wIndex);
    989                      if (result == USB_SUCCESS)
    990                      {
    991                        switch (recipient)
   \                     ??USB_DeviceSetupPacket_8:
   \   0000006A   0xB113             CBZ.N    R3,??USB_DeviceSetupPacket_10
   \   0000006C   0x2B02             CMP      R3,#+2
   \   0000006E   0xD002             BEQ.N    ??USB_DeviceSetupPacket_11
   \   00000070   0xD207             BCS.N    ??USB_DeviceSetupPacket_12
    992                        {
    993                          /* Device - return Self Powered and Remote Wakeup status */
    994                          case USB_RECIPIENT_DEVICE:
    995                            SetupPacketData[0] = 0
    996          #ifdef USB_SELF_POWERED_SUPPORTED
    997                              | USB_DeviceContext.USB_DeviceStatus.SelfPowered
    998          #endif /* USB_SELF_POWERED_SUPPORTED */
    999          #ifdef USB_REMOTE_WAKEUP_SUPPORTED
   1000                              | (USB_DeviceContext.USB_DeviceStatus.RemoteWakeupEnabled << 1)
   1001          #endif /* USB_REMOTE_WAKEUP_SUPPORTED */
   1002                              ;
   1003                            break;
   1004                          /* Interface - return 0 */
   1005                          case USB_RECIPIENT_INTERFACE:
   1006                            SetupPacketData[0] = 0;
   \                     ??USB_DeviceSetupPacket_10:
   \   00000072   0x700F             STRB     R7,[R1, #+0]
   1007                            break;
   \   00000074   0xE005             B.N      ??USB_DeviceSetupPacket_12
   1008                          /* Endpoint - return Halt status */
   1009                          case USB_RECIPIENT_ENDPOINT:
   1010                            SetupPacketData[0] = USB_EPContext[wIndex].EP_Halt;
   \                     ??USB_DeviceSetupPacket_11:
   \   00000076   0x202C             MOVS     R0,#+44
   \   00000078   0x....             LDR.N    R2,??DataTable13
   \   0000007A   0xFB00 0x200C      MLA      R0,R0,R12,R2
   \   0000007E   0x7840             LDRB     R0,[R0, #+1]
   \   00000080   0x7008             STRB     R0,[R1, #+0]
   1011                            break;
   1012                        }
   1013                        SetupPacketData[1] = 0;
   \                     ??USB_DeviceSetupPacket_12:
   \   00000082   0x704F             STRB     R7,[R1, #+1]
   1014                        result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
   \   00000084   0x2300             MOVS     R3,#+0
   \   00000086   0x2202             MOVS     R2,#+2
   \                     ??USB_DeviceSetupPacket_13:
   \   00000088   0x4648             MOV      R0,R9
   \   0000008A   0x.... 0x....      BL       USB_EP_doDataIn
   1015                      }
   1016                    }
   1017                    break;
   1018                  /* CLEAR_FEATURE */
   1019                  case USB_CLEAR_FEATURE:
   1020                    if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
   1021                        (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
   1022                    {
   1023                      result = USB_ERROR;
   1024                    }
   1025                    else
   1026                    {
   1027                      result = USB_DEVICE_HANDLE_CLEAR_FEATURE(recipient, wValue, wIndex);
   1028                    }
   1029                    break;
   1030                  /* SET_FEATURE */
   1031                  case USB_SET_FEATURE:
   1032                    if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
   1033                        (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
   1034                    {
   1035                      result = USB_ERROR;
   1036                    }
   1037                    else
   1038                    {
   1039                      result = USB_DEVICE_HANDLE_SET_FEATURE(recipient, wValue, wIndex);
   1040                    }
   1041                    break;
   1042                  /* SET_ADDRESS */
   1043                  case USB_SET_ADDRESS:
   1044                    result = USB_DEVICE_HANDLE_SET_ADDRESS(wValue);
   1045                    /* Set special Status Stage handler that will actually change the address */
   1046                    USB_DeviceContext.Address = wValue;
   1047                    statusAckHandler = USB_Device_setAddressWork;
   1048                    break;
   1049                  /* GET_DESCRIPTOR */
   1050                  case USB_GET_DESCRIPTOR:
   1051                    result = USB_DEVICE_HANDLE_GET_DESCRIPTOR(wValue, wIndex, wLength);
   1052                    break;
   1053                  /* SET_DESCRIPTOR */
   1054                  case USB_SET_DESCRIPTOR:
   1055                    result = USB_DEVICE_HANDLE_SET_DESCRIPTOR(wValue, wIndex, wLength);
   1056                    break;
   1057                  /* GET_CONFIGURATION */
   1058                  case USB_GET_CONFIGURATION:
   1059                    if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
   1060                    {
   1061                      SetupPacketData[0] = 0;
   1062                    }
   1063                    else
   1064                    {
   1065                      SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_CONFIGURATION;
   1066                    }
   1067                    result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
   1068                    break;
   1069                  /* SET_CONFIGURATION */
   1070                  case USB_SET_CONFIGURATION:
   1071                    if (wValue == 0)
   1072                    {
   1073                      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_ADDRESS;
   1074                    }
   1075                    else
   1076                    {
   1077                      result = USB_DEVICE_HANDLE_SET_CONFIGURATION(wValue);
   1078                      if (result == USB_SUCCESS)
   1079                      {
   1080                        USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_CONFIGURED;
   1081                      }
   1082                    }
   1083                    break;
   1084                  /* GET_INTERFACE */
   1085                  case USB_GET_INTERFACE:
   1086                    if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
   1087                    {
   1088                      result = USB_ERROR;
   1089                    }
   1090                    else
   1091                    {
   1092                      SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_INTERFACE(wIndex);
   1093                      result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
   1094                    }
   1095                    break;
   1096                  /* SET_INTERFACE */
   1097                  case USB_SET_INTERFACE:
   1098                    if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
   1099                    {
   1100                      result = USB_ERROR;
   1101                    }
   1102                    else
   1103                    {
   1104                      result = USB_DEVICE_HANDLE_SET_INTERFACE(wValue, wIndex);
   1105                    }
   1106                    break;
   1107                  /* SYNCH_FRAME */
   1108                  case USB_SYNCH_FRAME:
   1109                    if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
   1110                    {
   1111                      result = USB_ERROR;
   1112                    }
   1113                    else
   1114                    {
   1115                      result = USB_DEVICE_HANDLE_SYNC_FRAME(wIndex, SetupPacketData);
   1116                      if (result == USB_SUCCESS)
   1117                      {
   1118                        result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
   1119                      }
   1120                    }
   1121                    break;
   1122                  default:
   1123                    result = USB_ERR_INV_REQ;
   1124                }
   1125                /* If there were no DATA stage, initiate Status Stage (IN ACK) */
   1126                if (result == USB_SUCCESS && wLength == 0)
   \                     ??USB_DeviceSetupPacket_14:
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD164             BNE.N    ??USB_DeviceSetupPacket_15
   \                     ??USB_DeviceSetupPacket_16:
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD161             BNE.N    ??USB_DeviceSetupPacket_15
   1127                {
   1128                  result = (USB_SetupPacket->mRequestTypeData & 0x80) == USB_DEVICE_TO_HOST ?
   1129                                  USB_EP_doDataOut(EPx, 0, 0, statusAckHandler) :
   1130                                  USB_EP_doDataIn(EPx, 0, 0, statusAckHandler);
   \   00000098   0x7830             LDRB     R0,[R6, #+0]
   \   0000009A   0x0600             LSLS     R0,R0,#+24
   \   0000009C   0x463B             MOV      R3,R7
   \   0000009E   0xD54F             BPL.N    ??USB_DeviceSetupPacket_17
   \   000000A0   0x2200             MOVS     R2,#+0
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0xB001             ADD      SP,SP,#+4
   \   000000A8   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   000000AC   0x....             B.N      USB_EP_doDataOut
   1131                }
   \                     ??USB_DeviceSetupPacket_18:
   \   000000AE   0x7908             LDRB     R0,[R1, #+4]
   \   000000B0   0x2804             CMP      R0,#+4
   \   000000B2   0xD106             BNE.N    ??USB_DeviceSetupPacket_19
   \   000000B4   0x2B01             CMP      R3,#+1
   \   000000B6   0xD04E             BEQ.N    ??USB_DeviceSetupPacket_9
   \   000000B8   0x2B02             CMP      R3,#+2
   \   000000BA   0xD102             BNE.N    ??USB_DeviceSetupPacket_19
   \   000000BC   0xF1BC 0x0F04      CMP      R12,#+4
   \   000000C0   0xDA49             BGE.N    ??USB_DeviceSetupPacket_9
   \                     ??USB_DeviceSetupPacket_19:
   \   000000C2   0x4662             MOV      R2,R12
   \   000000C4   0x4621             MOV      R1,R4
   \   000000C6   0x4618             MOV      R0,R3
   \   000000C8   0x.... 0x....      BL       USB_DeviceClearFeature
   \   000000CC   0xE7DF             B.N      ??USB_DeviceSetupPacket_14
   \                     ??USB_DeviceSetupPacket_20:
   \   000000CE   0x7908             LDRB     R0,[R1, #+4]
   \   000000D0   0x2804             CMP      R0,#+4
   \   000000D2   0xD106             BNE.N    ??USB_DeviceSetupPacket_21
   \   000000D4   0x2B01             CMP      R3,#+1
   \   000000D6   0xD03E             BEQ.N    ??USB_DeviceSetupPacket_9
   \   000000D8   0x2B02             CMP      R3,#+2
   \   000000DA   0xD102             BNE.N    ??USB_DeviceSetupPacket_21
   \   000000DC   0xF1BC 0x0F04      CMP      R12,#+4
   \   000000E0   0xDA39             BGE.N    ??USB_DeviceSetupPacket_9
   \                     ??USB_DeviceSetupPacket_21:
   \   000000E2   0x4662             MOV      R2,R12
   \   000000E4   0x4621             MOV      R1,R4
   \   000000E6   0x4618             MOV      R0,R3
   \   000000E8   0x.... 0x....      BL       USB_DeviceSetFeature
   \   000000EC   0xE7CF             B.N      ??USB_DeviceSetupPacket_14
   \                     ??USB_DeviceSetupPacket_22:
   \   000000EE   0x60CC             STR      R4,[R1, #+12]
   \   000000F0   0x.... 0x....      ADR.W    R7,USB_Device_setAddressWork
   \   000000F4   0xE7CD             B.N      ??USB_DeviceSetupPacket_16
   \                     ??USB_DeviceSetupPacket_23:
   \   000000F6   0x4642             MOV      R2,R8
   \   000000F8   0x4661             MOV      R1,R12
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       USB_CDC_GetDescriptor
   \   00000100   0xE7C5             B.N      ??USB_DeviceSetupPacket_14
   \                     ??USB_DeviceSetupPacket_24:
   \   00000102   0x7908             LDRB     R0,[R1, #+4]
   \   00000104   0x2804             CMP      R0,#+4
   \   00000106   0xBF0E             ITEE     EQ 
   \   00000108   0x700F             STRBEQ   R7,[R1, #+0]
   \   0000010A   0x2001             MOVNE    R0,#+1
   \   0000010C   0x7008             STRBNE   R0,[R1, #+0]
   \                     ??USB_DeviceSetupPacket_25:
   \   0000010E   0x2300             MOVS     R3,#+0
   \   00000110   0x2201             MOVS     R2,#+1
   \   00000112   0xE7B9             B.N      ??USB_DeviceSetupPacket_13
   \                     ??USB_DeviceSetupPacket_26:
   \   00000114   0xB914             CBNZ.N   R4,??USB_DeviceSetupPacket_27
   \   00000116   0x2204             MOVS     R2,#+4
   \                     ??USB_DeviceSetupPacket_28:
   \   00000118   0x710A             STRB     R2,[R1, #+4]
   \   0000011A   0xE7BA             B.N      ??USB_DeviceSetupPacket_16
   \                     ??USB_DeviceSetupPacket_27:
   \   0000011C   0x2C01             CMP      R4,#+1
   \                     ??USB_DeviceSetupPacket_7:
   \   0000011E   0xD11A             BNE.N    ??USB_DeviceSetupPacket_9
   \   00000120   0x2205             MOVS     R2,#+5
   \   00000122   0xE7F9             B.N      ??USB_DeviceSetupPacket_28
   \                     ??USB_DeviceSetupPacket_29:
   \   00000124   0x7908             LDRB     R0,[R1, #+4]
   \   00000126   0x2804             CMP      R0,#+4
   \   00000128   0xD015             BEQ.N    ??USB_DeviceSetupPacket_9
   \   0000012A   0x700F             STRB     R7,[R1, #+0]
   \   0000012C   0xE7EF             B.N      ??USB_DeviceSetupPacket_25
   \                     ??USB_DeviceSetupPacket_30:
   \   0000012E   0x7909             LDRB     R1,[R1, #+4]
   \   00000130   0x2904             CMP      R1,#+4
   \   00000132   0xD010             BEQ.N    ??USB_DeviceSetupPacket_9
   \   00000134   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000138   0xD10D             BNE.N    ??USB_DeviceSetupPacket_9
   \   0000013A   0x2C00             CMP      R4,#+0
   \   0000013C   0xD0A9             BEQ.N    ??USB_DeviceSetupPacket_16
   \   0000013E   0xE00A             B.N      ??USB_DeviceSetupPacket_9
   1132                break;
   1133              }
   \                     ??USB_DeviceSetupPacket_17:
   \   00000140   0x2200             MOVS     R2,#+0
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0x4648             MOV      R0,R9
   \   00000146   0xB001             ADD      SP,SP,#+4
   \   00000148   0xE8BD 0x43F0      POP      {R4-R9,LR}
   \   0000014C   0x....             B.N      USB_EP_doDataIn
   1134              /* Class-specific request */
   1135              case USB_TYPE_CLASS:
   1136                result = USB_DEVICE_HANDLE_CLASS_REQUEST;
   \                     ??USB_DeviceSetupPacket_2:
   \   0000014E   0xE8BD 0x43F1      POP      {R0,R4-R9,LR}
   \   00000152   0x.... 0x....      B.W      USB_CDC_ClassRequest
   1137                break;
   1138              /* Vendor-specific request */
   1139              case USB_TYPE_VENDOR:
   1140                result = USB_DEVICE_HANDLE_VENDOR_REQUEST;
   \                     ??USB_DeviceSetupPacket_9:
   \   00000156   0x2001             MOVS     R0,#+1
   1141                break;
   \   00000158   0xE000             B.N      ??USB_DeviceSetupPacket_15
   1142              default:
   1143                result = USB_ERR_INV_REQ;
   \                     ??USB_DeviceSetupPacket_5:
   \   0000015A   0x2002             MOVS     R0,#+2
   1144            }
   1145            return result;
   \                     ??USB_DeviceSetupPacket_15:
   \   0000015C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1146          }
   1147          
   1148          /** @} */ /* End of group USB_Device_Private_Handlers */
   1149          
   1150          /** @defgroup USB_Device_deviceSetupPacket_Handlers USB Device Standard Request specific handlers
   1151            * @{
   1152            */
   1153          
   1154          /**
   1155            * @brief  Called on CLEAR_FEATURE request (9.4.1).
   1156            *
   1157            * @param  Recipient: Recipient type (from setup packet header).
   1158            *         This parameter can be one of the following values:
   1159            *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
   1160            *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
   1161            *
   1162            * @param  wVALUE: Feature selector.
   1163            *
   1164            * @param  wINDEX: Interface or EndPoint number, if Recipient has
   1165            *         appropriate value.
   1166            *
   1167            * @retval USB_Result.
   1168            *
   1169            * @note   This handler is called in correct state only. This implementation
   1170            *         process ENDPOINT_HALT (calling USB_EP_Ready) and DEVICE_REMOTE_WAKEUP
   1171            *         (clearing RemoteWakeupEnabled context flag) standard features only.
   1172            */
   1173          

   \                                 In section .text, align 2, keep-with-next
   1174          USB_Result USB_DeviceClearFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
   1175          {
   1176            if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
   \                     USB_DeviceClearFeature:
   \   00000000   0x2802             CMP      R0,#+2
   \   00000002   0xD104             BNE.N    ??USB_DeviceClearFeature_0
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xBF04             ITT      EQ 
   \   00000008   0xB2D0             UXTBEQ   R0,R2
   \   0000000A   0x.... 0x....      BEQ.W    USB_EP_Idle
   1177            {
   1178              return USB_EP_Idle((USB_EP_TypeDef)wINDEX);
   1179            }
   1180            else
   1181            {
   1182              return USB_ERROR;
   \                     ??USB_DeviceClearFeature_0:
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR               ;; return
   1183            }
   1184          }
   1185          
   1186          /**
   1187            * @brief  Called on SET_FEATURE request (9.4.9).
   1188            *
   1189            * @param  Recipient: Recipient type (from setup packet header).
   1190            *         This parameter can be one of the following values:
   1191            *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
   1192            *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
   1193            *
   1194            * @param  wVALUE: Feature selector.
   1195            *
   1196            * @param  wINDEX: Interface or EndPoint number, if Recipient has
   1197            *         appropriate value.
   1198            *
   1199            * @retval USB_Result.
   1200            *
   1201            * @note   This handler is called in correct state only. This implementation
   1202            *         process ENDPOINT_HALT (calling USB_EP_Stall) and DEVICE_REMOTE_WAKEUP
   1203            *         (setting RemoteWakeupEnabled context flag) standard features only.
   1204            */
   1205          

   \                                 In section .text, align 2, keep-with-next
   1206          USB_Result USB_DeviceSetFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
   1207          {
   1208            if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
   \                     USB_DeviceSetFeature:
   \   00000000   0x2802             CMP      R0,#+2
   \   00000002   0xBF08             IT       EQ 
   \   00000004   0x2900             CMPEQ    R1,#+0
   \   00000006   0xD102             BNE.N    ??USB_DeviceSetFeature_0
   1209            {
   1210              return USB_EP_Stall((USB_EP_TypeDef)wINDEX, USB_STALL_HALT);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xB2D0             UXTB     R0,R2
   \   0000000C   0x....             B.N      USB_EP_Stall
   1211            }
   1212            else
   1213            {
   1214              return USB_ERROR;
   \                     ??USB_DeviceSetFeature_0:
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR               ;; return
   1215            }
   1216          }
   1217          
   1218          /** @} */ /* End of group USB_Device_deviceSetupPacket_Handlers */
   1219          
   1220          /** @defgroup USB_Device_Status_Stage_Handlers USB Device Service Functions
   1221            * @{
   1222            */
   1223          
   1224          /**
   1225            * @brief Implements Status stage of Setup transaction with OUT data stage
   1226            *        or without data stage. To be used as EndPoint transaction handler.
   1227            *
   1228            * @param  EPx: USB EndPoint number.
   1229            *         This parameter can be one of the following values:
   1230            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
   1231            *
   1232            * @param  Buffer: Pointer to the user's buffer with portion of data
   1233            *                 to be sent
   1234            *
   1235            * @param  Length: Length of data portion
   1236            *
   1237            * @retval USB_Result.
   1238            *
   1239            * @note   This function interface reflects EndPoint data transmitting handler
   1240            *         requirements.
   1241            */
   1242          

   \                                 In section .text, align 2, keep-with-next
   1243          USB_Result USB_DeviceDoStatusInAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
   1244          {
   1245            return USB_SUCCESS;
   \                     USB_DeviceDoStatusInAck:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1246          }
   1247          
   1248          /**
   1249            * @brief Implements Status stage of Setup transaction with IN data stage.
   1250            *        To be used as EndPoint transaction handler.
   1251            *
   1252            * @param  EPx: USB EndPoint number.
   1253            *         This parameter can be one of the following values:
   1254            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
   1255            *
   1256            * @param  Buffer: Pointer to the user's buffer for next portion of data
   1257            *
   1258            * @param  Length: Length of data portion
   1259            *
   1260            * @retval USB_Result.
   1261            *
   1262            * @note   This function interface reflects EndPoint data transmitting handler
   1263            *         requirements.
   1264            */
   1265          

   \                                 In section .text, align 2, keep-with-next
   1266          USB_Result USB_DeviceDoStatusOutAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
   1267          {
   1268            return USB_EP_doDataOut(EPx, 0, 0, 0);
   \                     USB_DeviceDoStatusOutAck:
   \   00000000   0x2300             MOVS     R3,#+0
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4611             MOV      R1,R2
   \   00000006   0x....             B.N      USB_EP_doDataOut
   1269          }
   1270          
   1271          /**
   1272            * @brief Implements Status stage of Setup SET_ADDRESS transaction.
   1273            *        Actually changes the device address. To be used as EndPoint
   1274            *        transaction handler.
   1275            *
   1276            * @param  EPx: USB EndPoint number.
   1277            *         This parameter can be one of the following values:
   1278            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
   1279            *
   1280            * @param  Buffer: Pointer to the user's buffer with portion of data
   1281            *                 to be sent
   1282            *
   1283            * @param  Length: Length of data portion
   1284            *
   1285            * @retval USB_Result.
   1286            *
   1287            * @note   This function interface reflects EndPoint data transmitting handler
   1288            *         requirements.
   1289            */
   1290          

   \                                 In section .text, align 4, keep-with-next
   1291          static USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
   1292          {
   \                     USB_Device_setAddressWork:
   \   00000000   0xB510             PUSH     {R4,LR}
   1293            /* Set address */
   1294            USB_SetSA(USB_DeviceContext.Address);
   \   00000002   0x....             LDR.N    R4,??DataTable13_3
   \   00000004   0x68E0             LDR      R0,[R4, #+12]
   \   00000006   0x.... 0x....      BL       USB_SetSA
   1295            /* Adjust device state */
   1296            USB_DeviceContext.USB_DeviceState = (USB_DeviceContext.Address ? USB_DEV_STATE_ADDRESS : USB_DEV_STATE_DEFAULT);
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x2004             MOVNE    R0,#+4
   \   00000012   0x2003             MOVEQ    R0,#+3
   \   00000014   0x7120             STRB     R0,[R4, #+4]
   1297          
   1298            return USB_SUCCESS;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1299          }
   1300          
   1301          /** @} */ /* End of group USB_Device_Status stage _Handlers */
   1302          
   1303          /**
   1304            * @brief  USB interrupt dispatcher, called from interrupt handler
   1305            *
   1306            * @param  None
   1307            *
   1308            * @retval USB_Result.
   1309            *
   1310            * @note   Handles common events (such as Reset) and calls USB_EP_setSetupHandler
   1311            *         for each EndPoint in use.
   1312            */
   1313          

   \                                 In section .text, align 2, keep-with-next
   1314          USB_Result USB_DeviceDispatchEvent(void)
   1315          {
   \                     USB_DeviceDispatchEvent:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1316            uint32_t i;
   1317            uint32_t USB_IT;
   1318            USB_Result result = USB_SUCCESS;
   1319            static volatile uint32_t bHandling = RESET;
   1320          
   1321            /* Disable USB interrupts */
   1322          #ifdef USB_INT_HANDLE_REQUIRED
   1323            NVIC_DisableIRQ(USB_IRQn);
   \   00000002   0x....             LDR.N    R0,??DataTable13_4  ;; 0xe000e180
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x6001             STR      R1,[R0, #+0]
   1324          #endif /* USB_INT_HANDLE_REQUIRED */
   1325          
   1326            if (!bHandling) {
   \   00000008   0x....             LDR.N    R4,??DataTable13_3
   \   0000000A   0x6920             LDR      R0,[R4, #+16]
   \   0000000C   0xB9C8             CBNZ.N   R0,??USB_DeviceDispatchEvent_0
   1327              bHandling = SET;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x6120             STR      R0,[R4, #+16]
   1328          
   1329              /* Get masked interrupt flags */
   1330              USB_IT = USB_GetSIS();
   \   00000012   0x.... 0x....      BL       USB_GetSIS
   \   00000016   0x4605             MOV      R5,R0
   1331              /* Handle reset */
   1332              if (USB_IT & USB_SIS_SCRESETEV)
   \   00000018   0x0768             LSLS     R0,R5,#+29
   \   0000001A   0xBF44             ITT      MI 
   \   0000001C   0x2003             MOVMI    R0,#+3
   \   0000001E   0x7120             STRBMI   R0,[R4, #+4]
   1333              {
   1334                result = USB_DeviceReset();
   1335              }
   1336          
   1337              /* Invoke End Point dispatchers */
   1338              for (i = USB_EP0; i < Num_USB_EndPoints; i++)
   \   00000020   0x2600             MOVS     R6,#+0
   1339              {
   1340                USB_EP_dispatchEvent((USB_EP_TypeDef)i, USB_IT);
   \                     ??USB_DeviceDispatchEvent_1:
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0xB2F0             UXTB     R0,R6
   \   00000026   0x.... 0x....      BL       USB_EP_dispatchEvent
   1341              }
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0x2E04             CMP      R6,#+4
   \   0000002E   0xD3F8             BCC.N    ??USB_DeviceDispatchEvent_1
   1342          
   1343              /* Clear pending bits, except for SCTDONE */
   1344              USB_SetSIS(USB_IT & (~USB_SIS_SCTDONE_Set));
   \   00000030   0x0868             LSRS     R0,R5,#+1
   \   00000032   0x0040             LSLS     R0,R0,#+1
   \   00000034   0x.... 0x....      BL       USB_SetSIS
   1345          
   1346              bHandling = RESET;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6120             STR      R0,[R4, #+16]
   1347          
   1348              /* Enable USB interrupts (only after the actual work is done) */
   1349          #ifdef USB_INT_HANDLE_REQUIRED
   1350              NVIC_EnableIRQ(USB_IRQn);
   \   0000003C   0x....             LDR.N    R0,??DataTable13_5  ;; 0xe000e100
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x6001             STR      R1,[R0, #+0]
   1351          #endif /* USB_INT_HANDLE_REQUIRED */
   1352            }
   1353            return result;
   \                     ??USB_DeviceDispatchEvent_0:
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
   1354          }

   \                                 In section .bss, align 4
   \                     SetupPacketData:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \                     USB_DeviceContext:
   \   00000004                      DS8 12
   \   00000010                      DS8 4
   \                     USB_CurrentSetupPacket:
   \   00000014                      DS8 8
   1355          
   1356          #ifdef USB_INT_HANDLE_REQUIRED
   1357          /**
   1358            * @brief  Default implementation of USB interrupt handler
   1359            *
   1360            * @param  None
   1361            *
   1362            * @retval None
   1363            *
   1364            * @note   To be overwritten, USB_INT_HANDLE_REQUIRED definition should be
   1365            *         undefined.
   1366            *
   1367            */
   1368          

   \                                 In section .text, align 2, keep-with-next
   1369          void USB_IRQHandler(void)
   1370          {
   1371            USB_DeviceDispatchEvent();
   \                     USB_IRQHandler:
   \   00000000   0x....             B.N      USB_DeviceDispatchEvent
   1372          }
   1373          #endif /* USB_INT_HANDLE_REQUIRED */
   1374          
   1375          
   1376          /** @defgroup USB_Device_Private_Dummy_Functions USB Device Private Handler Samples
   1377            * @{
   1378            */
   1379          
   1380          /**
   1381            * @brief  GET_STATUS standard request handler sample (9.4.5).
   1382            *
   1383            * @param  Recipient: Recipient type (from setup packet header).
   1384            *         This parameter can be one of the following values:
   1385            *         USB_RECIPIENT_DEVICE, USB_RECIPIENT_INTERFACE,
   1386            *         USB_RECIPIENT_ENDPOINT, USB_RECIPIENT_OTHER.
   1387            *
   1388            * @param  wINDEX: Interface or EndPoint number, if Recipient has
   1389            *         appropriate value.
   1390            *
   1391            * @retval USB_Result.
   1392            *
   1393            * @note   Intended to update USB_DeviceStatus field of the device context
   1394            *         before the status to be sent to host. Data stage begins if USB_SUCCESS
   1395            *         is returned.
   1396            */
   1397          

   \                                 In section .text, align 2, keep-with-next
   1398          USB_Result USB_DeviceDummyGetStatus(USB_RequestRecipient_TypeDef Recipient, uint16_t wINDEX)
   1399          {
   1400            return USB_SUCCESS;
   \                     USB_DeviceDummyGetStatus:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1401          }
   1402          
   1403          /**
   1404            * @brief  SET_ADDRESS standard request handler (preparation) sample (9.4.6).
   1405            *
   1406            * @param  wVALUE: New device address
   1407            *
   1408            * @retval USB_Result.
   1409            *
   1410            * @note   Intended to do perform actions while still in setup transaction
   1411            *         (actual address change to be performed after status stage completes).
   1412            *         If value returned is not USB_SUCCESS, transaction is aborted.
   1413            */
   1414          

   \                                 In section .text, align 2, keep-with-next
   1415          USB_Result USB_DeviceDummySetAddress(uint16_t wVALUE)
   1416          {
   1417            return USB_SUCCESS;
   \                     USB_DeviceDummySetAddress:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1418          }
   1419          
   1420          /**
   1421            * @brief  GET_DESCRIPTOR standard request handler sample (9.4.3).
   1422            *
   1423            * @param  wVALUE: Descriptor Type and Descriptor Index
   1424            *
   1425            * @param  wINDEX: Zero or Language ID (see 9.6.7)
   1426            *
   1427            * @param  wLENGTH: Amount of data host is willing to receive.
   1428            *
   1429            * @retval USB_Result.
   1430            *
   1431            * @note   This handler is called in correct state only. It's to be implemented
   1432            *         in any device class. It is expected to either perform data transfer
   1433            *         and status stages on its own (calling USB_EP_doDataIn), or return
   1434            *         value that is not USB_SUCCESS.
   1435            */
   1436          

   \                                 In section .text, align 2, keep-with-next
   1437          USB_Result USB_DeviceDummyGetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
   1438          {
   1439            return USB_ERROR;
   \                     USB_DeviceDummyGetDescriptor:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1440          }
   1441          
   1442          /**
   1443            * @brief  SET_DESCRIPTOR standard request handler sample (9.4.8).
   1444            *
   1445            * @param  wVALUE: Descriptor Type and Descriptor Index
   1446            *
   1447            * @param  wINDEX: Zero or Language ID (see 9.6.7)
   1448            *
   1449            * @param  wLENGTH: Amount of data to be sent by host.
   1450            *
   1451            * @retval USB_Result.
   1452            *
   1453            * @note   This handler is called in correct state only. It's to be implemented
   1454            *         only if the device supports descriptor update by host. It is expected
   1455            *         to either perform data transfer and status stages on its own (calling
   1456            *         USB_EP_doDataOut), or return value that is not USB_SUCCESS.
   1457            */
   1458          

   \                                 In section .text, align 2, keep-with-next
   1459          USB_Result USB_DeviceDummySetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
   1460          {
   1461            return USB_ERROR;
   \                     USB_DeviceDummySetDescriptor:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1462          }
   1463          
   1464          /**
   1465            * @brief  GET_CONFIGURATION standard request handler sample (9.4.2).
   1466            *
   1467            * @param  None
   1468            *
   1469            * @retval Currently selected configuration number or 0 on error.
   1470            *
   1471            * @note   This handler is called in correct state only. It's to be implemented
   1472            *         if the device supports more than one configuration.
   1473            */
   1474          

   \                                 In section .text, align 2, keep-with-next
   1475          uint8_t USB_DeviceDummyGetConfiguration(void)
   1476          {
   1477            return 1;
   \                     USB_DeviceDummyGetConfiguration:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1478          }
   1479          
   1480          /**
   1481            * @brief  SET_CONFIGURATION standard request handler sample (9.4.7).
   1482            *
   1483            * @param  wVALUE: Configuration number
   1484            *
   1485            * @retval USB_Result.
   1486            *
   1487            * @note   This handler is called in correct state only. It's to be implemented
   1488            *         if the device supports more than one configuration.
   1489            */
   1490          

   \                                 In section .text, align 2, keep-with-next
   1491          USB_Result USB_DeviceDummySetConfiguration(uint16_t wVALUE)
   1492          {
   1493            return USB_ERROR;
   \                     USB_DeviceDummySetConfiguration:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1494          }
   1495          
   1496          /**
   1497            * @brief  GET_INTERFACE standard request handler sample (9.4.4).
   1498            *
   1499            * @param  wINDEX: Interface number.
   1500            *
   1501            * @retval Currently selected alternate setting for the specified interface
   1502            *         or 0 in case of error.
   1503            *
   1504            * @note   This handler is called in correct state only. It's to be implemented
   1505            *         if the device supports interfaces with alternate settings.
   1506            */
   1507          

   \                                 In section .text, align 2, keep-with-next
   1508          uint8_t USB_DeviceDummyGetInterface(uint16_t wINDEX)
   1509          {
   1510            return 0;
   \                     USB_DeviceDummyGetInterface:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1511          }
   1512          
   1513          /**
   1514            * @brief  SET_INTERFACE standard request handler sample (9.4.10).
   1515            *
   1516            * @param  wVALUE: Alternate setting to be set.
   1517            *
   1518            * @param  wINDEX: Interface number.
   1519            *
   1520            * @retval USB_Result.
   1521            *
   1522            * @note   This handler is called in correct state only. It's to be implemented
   1523            *         if the device supports interfaces with alternate settings.
   1524            */
   1525          

   \                                 In section .text, align 2, keep-with-next
   1526          USB_Result USB_DeviceDummySetInterface(uint16_t wVALUE, uint16_t wINDEX)
   1527          {
   1528            return USB_SUCCESS;
   \                     USB_DeviceDummySetInterface:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1529          }
   1530          
   1531          /**
   1532            * @brief  SYNC_FRAME standard request handler sample (9.4.11).
   1533            *
   1534            * @param  wINDEX: EndPoint number.
   1535            *
   1536            * @param  DATA: Pointer for frame number.
   1537            *
   1538            * @retval USB_Result.
   1539            *
   1540            * @note   This handler is called in correct state only. It's to be implemented
   1541            *         if some of the device EndPoints support isochronous transfers. It is
   1542            *         expected to place EndPoint synchronization frame number into DATA pointed
   1543            *         location or return value that is not USB_SUCCESS.
   1544            */
   1545          

   \                                 In section .text, align 2, keep-with-next
   1546          USB_Result USB_DeviceDummySyncFrame(uint16_t wINDEX, uint8_t* DATA)
   1547          {
   1548            return USB_ERROR;
   \                     USB_DeviceDummySyncFrame:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1549          }
   1550          
   1551          /**
   1552            * @brief  Class-type setup request handler sample.
   1553            *
   1554            * @param  None
   1555            *
   1556            * @retval USB_Result.
   1557            *
   1558            * @note   This handler is called in correct state only. It's to be implemented
   1559            *         the device supports any class-type requests. Request setup packet data
   1560            *         is accessible by USB_CurrentSetupPacket variable. The overwritten method
   1561            *         should implement both data (if present) and status transfer stages.
   1562            */
   1563          

   \                                 In section .text, align 2, keep-with-next
   1564          USB_Result USB_DeviceDummyClassRequest(void)
   1565          {
   1566            return USB_ERROR;
   \                     USB_DeviceDummyClassRequest:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1567          }
   1568          
   1569          /**
   1570            * @brief  Vendor-type setup request handler sample.
   1571            *
   1572            * @param  None
   1573            *
   1574            * @retval USB_Result.
   1575            *
   1576            * @note   This handler is called in correct state only. It's to be implemented
   1577            *         the device supports any vendor-type requests. Request setup packet data
   1578            *         is accessible by USB_CurrentSetupPacket variable. The overwritten method
   1579            *         should implement both data (if present) and status transfer stages.
   1580            */
   1581          
   1582          

   \                                 In section .text, align 2, keep-with-next
   1583          USB_Result USB_DeviceDummyVendorRequest(void)
   1584          {
   1585            return USB_ERROR;
   \                     USB_DeviceDummyVendorRequest:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1586          }
   1587          
   1588          
   1589          /**
   1590            * @brief  EndPoint error handler sample.
   1591            *
   1592            * @param  EPx: USB EndPoint number.
   1593            *         This parameter can be one of the following values:
   1594            *         USB_EP0, USB_EP1, USB_EP2, USB_EP3.
   1595            *
   1596            * @param  STS: USB_SEPx.STS register value.
   1597            *
   1598            * @param  TS: USB_SEPx.TS register value.
   1599            *
   1600            * @param  CTRL: USB_SEPx.CTRL register value.
   1601            *
   1602            * @retval USB_Result.
   1603            *
   1604            * @note   This function interface reflects EndPoint error handler
   1605            *         requirements. When called on IN transaction error:
   1606            *          - if it hasn't start another transaction and returns USB_SUCCESS,
   1607            *            then retry of data transmission would occur;
   1608            *          - if it returns error code, EndPoint would be switched to
   1609            *            NAK/STALL state.
   1610            */
   1611          

   \                                 In section .text, align 2, keep-with-next
   1612          USB_Result USB_DeviceDummyDataError(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL)
   1613          {
   1614            return USB_ERROR;
   \                     USB_DeviceDummyDataError:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   1615          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     USB_EPContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x00120001         DC32     0x120001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x00080002         DC32     0x80002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     SetupPacketData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0xE000E100         DC32     0xe000e100
   1616          
   1617          /** @} */ /* End of group USB_Device_Private_Dummy_Functions */
   1618          
   1619          
   1620          /** @} */ /* End of group USB_Device_Private_Functions */
   1621          
   1622          /** @} */ /* End of group USB_Device */
   1623          
   1624          /** @} */ /* End of group USB_DEVICE_AND_CDC */
   1625          
   1626          /** @} */ /* End of group MDR32F9Qx_StdPeriph_Driver */
   1627          
   1628          /******************* (C) COPYRIGHT 2011 Phyton *********
   1629          *
   1630          * END OF FILE MDR32F9Qx_usb_device.c */
   1631          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  USB_DeviceClearFeature
              0 -> USB_EP_Idle
       16  USB_DeviceDispatchEvent
             16 -> USB_EP_dispatchEvent
             16 -> USB_GetSIS
             16 -> USB_SetSIS
        0  USB_DeviceDoStatusInAck
        0  USB_DeviceDoStatusOutAck
              0 -> USB_EP_doDataOut
        0  USB_DeviceDummyClassRequest
        0  USB_DeviceDummyDataError
        0  USB_DeviceDummyGetConfiguration
        0  USB_DeviceDummyGetDescriptor
        0  USB_DeviceDummyGetInterface
        0  USB_DeviceDummyGetStatus
        0  USB_DeviceDummySetAddress
        0  USB_DeviceDummySetConfiguration
        0  USB_DeviceDummySetDescriptor
        0  USB_DeviceDummySetInterface
        0  USB_DeviceDummySyncFrame
        0  USB_DeviceDummyVendorRequest
        8  USB_DeviceInit
              8 -> USB_BRGInit
              8 -> USB_EP_Init
              8 -> USB_EP_setSetupHandler
              8 -> USB_Reset
              8 -> USB_SetHSCR
              8 -> USB_SetSC
        8  USB_DevicePowerOff
              8 -> USB_SetHSCR
        8  USB_DevicePowerOn
              8 -> USB_SetHSCR
        0  USB_DeviceReset
        0  USB_DeviceResume
        0  USB_DeviceSetFeature
              0 -> USB_EP_Stall
       32  USB_DeviceSetupPacket
              0 -> USB_CDC_ClassRequest
             32 -> USB_CDC_GetDescriptor
             32 -> USB_DeviceClearFeature
             32 -> USB_DeviceSetFeature
              0 -> USB_EP_doDataIn
             32 -> USB_EP_doDataIn
              0 -> USB_EP_doDataOut
        0  USB_DeviceSuspend
        8  USB_Device_setAddressWork
              8 -> USB_SetSA
        8  USB_EP_Idle
              8 -> USB_EP_SetReady
        8  USB_EP_Init
              8 -> USB_SetSEPxCTRL
        8  USB_EP_Reset
              8 -> USB_SetSEPxCTRL
       16  USB_EP_SetReady
              0 -> USB_SetSEPxCTRL
             16 -> USB_SetSIS
        8  USB_EP_Stall
              8 -> USB_EP_SetReady
       40  USB_EP_dispatchEvent
             40 -- Indirect call
             40 -> USB_EP_Idle
             40 -> USB_EP_SetReady
             40 -> USB_EP_Stall
             40 -> USB_EP_sendInDataPortion
             40 -> USB_GetSEPxCTRL
             40 -> USB_GetSEPxRXFD
             40 -> USB_GetSEPxRXFDC
             40 -> USB_GetSEPxSTS
             40 -> USB_GetSEPxTS
             40 -> USB_SetSEPxRXFC
       16  USB_EP_doDataIn
             16 -> USB_EP_sendInDataPortion
       16  USB_EP_doDataOut
             16 -> USB_EP_Idle
       24  USB_EP_sendInDataPortion
              0 -> USB_EP_SetReady
             24 -> USB_SEPxToggleEPDATASEQ
             24 -> USB_SetSEPxCTRL
             24 -> USB_SetSEPxTXFD
             24 -> USB_SetSEPxTXFDC
        8  USB_EP_setSetupHandler
              8 -> USB_EP_Idle
        0  USB_IRQHandler
              0 -> USB_DeviceDispatchEvent


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       6  ?Subroutine0
       8  ?Subroutine1
      12  ?Subroutine2
      28  SetupPacketData
          USB_DeviceContext
          bHandling
          USB_CurrentSetupPacket
      18  USB_DeviceClearFeature
      70  USB_DeviceDispatchEvent
       4  USB_DeviceDoStatusInAck
       8  USB_DeviceDoStatusOutAck
       4  USB_DeviceDummyClassRequest
       4  USB_DeviceDummyDataError
       4  USB_DeviceDummyGetConfiguration
       4  USB_DeviceDummyGetDescriptor
       4  USB_DeviceDummyGetInterface
       4  USB_DeviceDummyGetStatus
       4  USB_DeviceDummySetAddress
       4  USB_DeviceDummySetConfiguration
       4  USB_DeviceDummySetDescriptor
       4  USB_DeviceDummySetInterface
       4  USB_DeviceDummySyncFrame
       4  USB_DeviceDummyVendorRequest
      74  USB_DeviceInit
      14  USB_DevicePowerOff
      14  USB_DevicePowerOn
      10  USB_DeviceReset
       4  USB_DeviceResume
      18  USB_DeviceSetFeature
     352  USB_DeviceSetupPacket
       4  USB_DeviceSuspend
      26  USB_Device_setAddressWork
     176  USB_EPContext
      46  USB_EP_Idle
      40  USB_EP_Init
      30  USB_EP_Reset
      36  USB_EP_SetReady
      46  USB_EP_Stall
     482  USB_EP_dispatchEvent
      50  USB_EP_doDataIn
      36  USB_EP_doDataOut
      86  USB_EP_sendInDataPortion
      32  USB_EP_setSetupHandler
       2  USB_IRQHandler

 
   204 bytes in section .bss
 1 600 bytes in section .text
 
 1 600 bytes of CODE memory
   204 bytes of DATA memory

Errors: none
Warnings: 1
