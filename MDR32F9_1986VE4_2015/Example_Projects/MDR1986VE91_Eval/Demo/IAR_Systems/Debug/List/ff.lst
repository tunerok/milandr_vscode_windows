###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     22/Sep/2015  17:26:02 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\src_fatfs\ff.c                               #
#    Command line =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\src_fatfs\ff.c --preprocess                  #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -lCN            #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -lB             #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -o              #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\ --debug          #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Proj #
#                    ects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\config\ -I  #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\ -I                            #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\USB_Library\ -I                #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CMSIS #
#                    \CM3\CoreSupport\ -I C:\WORK\Milandr.MDR1986BExx.1.4.0\E #
#                    xample_Projects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\ #
#                    ..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\   #
#                    -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MD #
#                    R1986VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CM #
#                    SIS\CM3\DeviceSupport\MDR32F9Qx\startup\iar\ -I          #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Example_Project #
#                    s\MDR1986VE91_Eval\inc\ -Ohz                             #
#    List file    =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ff.lst           #
#    Object file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\ff.o              #
#                                                                             #
#                                                                             #
###############################################################################

C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR1986VE91_Eval\src_fatfs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following terms.
      7          /
      8          /  Copyright (C) 2011, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) partition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close without write.
     50          /
     51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     52          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     53          /
     54          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     55          /                   Added long file name feature.
     56          /                   Added multiple code page feature.
     57          /                   Added re-entrancy for multitask operation.
     58          /                   Added auto cluster size selection to f_mkfs().
     59          /                   Added rewind option to f_readdir().
     60          /                   Changed result code of critical errors.
     61          /                   Renamed string functions to avoid name collision.
     62          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     63          /                   Added multiple sector size feature.
     64          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     65          /                   Fixed wrong cache control in f_lseek().
     66          /                   Added relative path feature.
     67          /                   Added f_chdir() and f_chdrive().
     68          /                   Added proper case conversion to extended char.
     69          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     70          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     71          /                   Fixed name matching error on the 13 char boundary.
     72          /                   Added a configuration option, _LFN_UNICODE.
     73          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     74          /
     75          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     76          /                   Added file lock feature. (_FS_SHARE)
     77          /                   Added fast seek feature. (_USE_FASTSEEK)
     78          /                   Changed some types on the API, XCHAR->TCHAR.
     79          /                   Changed fname member in the FILINFO structure on Unicode cfg.
     80          /                   String functions support UTF-8 encoding files on Unicode cfg.
     81          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
     82          /                   Added sector erase feature. (_USE_ERASE)
     83          /                   Moved file lock semaphore table from fs object to the bss.
     84          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     85          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     86          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     87          /                   f_lseek() reports required table size on creating CLMP.
     88          /                   Extended format syntax of f_printf function.
     89          /                   Ignores duplicated directory separators in given path names.
     90          /
     91          / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
     92          /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
     93          /---------------------------------------------------------------------------*/
     94          
     95          #include "ff.h"     /* FatFs configurations and declarations */
     96          #include "diskio.h"   /* Declarations of low level disk I/O functions */
     97          
     98          
     99          /*--------------------------------------------------------------------------
    100          
    101             Module Private Definitions
    102          
    103          ---------------------------------------------------------------------------*/
    104          
    105          #if _FATFS != 6502  /* Revision ID */
    106          #error Wrong include file (ff.h).
    107          #endif
    108          
    109          
    110          /* Definitions on sector size */
    111          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    112          #error Wrong sector size.
    113          #endif
    114          #if _MAX_SS != 512
    115          #define SS(fs)  ((fs)->ssize) /* Variable sector size */
    116          #else
    117          #define SS(fs)  512U      /* Fixed sector size */
    118          #endif
    119          
    120          
    121          /* Reentrancy related */
    122          #if _FS_REENTRANT
    123          #if _USE_LFN == 1
    124          #error Static LFN work area must not be used in re-entrant configuration.
    125          #endif
    126          #define ENTER_FF(fs)    { if (!lock_fs(fs)) return FR_TIMEOUT; }
    127          #define LEAVE_FF(fs, res) { unlock_fs(fs, res); return res; }
    128          #else
    129          #define ENTER_FF(fs)
    130          #define LEAVE_FF(fs, res) return res
    131          #endif
    132          
    133          #define ABORT(fs, res)    { fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    134          
    135          
    136          /* File shareing feature */
    137          #if _FS_SHARE
    138          #if _FS_READONLY
    139          #error _FS_SHARE must be 0 on read-only cfg.
    140          #endif
    141          typedef struct {
    142            FATFS *fs;        /* File ID 1, volume (NULL:blank entry) */
    143            DWORD clu;        /* File ID 2, directory */
    144            WORD idx;       /* File ID 3, directory index */
    145            WORD ctr;       /* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    146          } FILESEM;
    147          #endif
    148          
    149          
    150          /* Misc definitions */
    151          #define LD_CLUST(dir) (((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
    152          #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
    153          
    154          
    155          /* DBCS code ranges and SBCS extend char conversion table */
    156          
    157          #if _CODE_PAGE == 932 /* Japanese Shift-JIS */
    158          #define _DF1S 0x81  /* DBC 1st byte range 1 start */
    159          #define _DF1E 0x9F  /* DBC 1st byte range 1 end */
    160          #define _DF2S 0xE0  /* DBC 1st byte range 2 start */
    161          #define _DF2E 0xFC  /* DBC 1st byte range 2 end */
    162          #define _DS1S 0x40  /* DBC 2nd byte range 1 start */
    163          #define _DS1E 0x7E  /* DBC 2nd byte range 1 end */
    164          #define _DS2S 0x80  /* DBC 2nd byte range 2 start */
    165          #define _DS2E 0xFC  /* DBC 2nd byte range 2 end */
    166          
    167          #elif _CODE_PAGE == 936 /* Simplified Chinese GBK */
    168          #define _DF1S 0x81
    169          #define _DF1E 0xFE
    170          #define _DS1S 0x40
    171          #define _DS1E 0x7E
    172          #define _DS2S 0x80
    173          #define _DS2E 0xFE
    174          
    175          #elif _CODE_PAGE == 949 /* Korean */
    176          #define _DF1S 0x81
    177          #define _DF1E 0xFE
    178          #define _DS1S 0x41
    179          #define _DS1E 0x5A
    180          #define _DS2S 0x61
    181          #define _DS2E 0x7A
    182          #define _DS3S 0x81
    183          #define _DS3E 0xFE
    184          
    185          #elif _CODE_PAGE == 950 /* Traditional Chinese Big5 */
    186          #define _DF1S 0x81
    187          #define _DF1E 0xFE
    188          #define _DS1S 0x40
    189          #define _DS1E 0x7E
    190          #define _DS2S 0xA1
    191          #define _DS2E 0xFE
    192          
    193          #elif _CODE_PAGE == 437 /* U.S. (OEM) */
    194          #define _DF1S 0
    195          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    196                  0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    197                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    198                  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    199          
    200          #elif _CODE_PAGE == 720 /* Arabic (OEM) */
    201          #define _DF1S 0
    202          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    203                  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    204                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    205                  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    206          
    207          #elif _CODE_PAGE == 737 /* Greek (OEM) */
    208          #define _DF1S 0
    209          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    210                  0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    211                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    212                  0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    213          
    214          #elif _CODE_PAGE == 775 /* Baltic (OEM) */
    215          #define _DF1S 0
    216          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    217                  0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    218                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    219                  0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    220          
    221          #elif _CODE_PAGE == 850 /* Multilingual Latin 1 (OEM) */
    222          #define _DF1S 0
    223          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    224                  0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    225                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    226                  0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    227          
    228          #elif _CODE_PAGE == 852 /* Latin 2 (OEM) */
    229          #define _DF1S 0
    230          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    231                  0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    232                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    233                  0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    234          
    235          #elif _CODE_PAGE == 855 /* Cyrillic (OEM) */
    236          #define _DF1S 0
    237          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    238                  0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    239                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    240                  0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    241          
    242          #elif _CODE_PAGE == 857 /* Turkish (OEM) */
    243          #define _DF1S 0
    244          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    245                  0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    246                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    247                  0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    248          
    249          #elif _CODE_PAGE == 858 /* Multilingual Latin 1 + Euro (OEM) */
    250          #define _DF1S 0
    251          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    252                  0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    253                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    254                  0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    255          
    256          #elif _CODE_PAGE == 862 /* Hebrew (OEM) */
    257          #define _DF1S 0
    258          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    259                  0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    260                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    261                  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    262          
    263          #elif _CODE_PAGE == 866 /* Russian (OEM) */
    264          #define _DF1S 0
    265          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    266                  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    267                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    268                  0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    269          
    270          #elif _CODE_PAGE == 874 /* Thai (OEM, Windows) */
    271          #define _DF1S 0
    272          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    273                  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    274                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    275                  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    276          
    277          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    278          #define _DF1S 0
    279          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    280                  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    281                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    282                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    283          
    284          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    285          #define _DF1S 0
    286          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    287                  0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    288                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    289                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    290          
    291          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    292          #define _DF1S 0
    293          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    294                  0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    295                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    296                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    297          
    298          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    299          #define _DF1S 0
    300          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    301                  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    302                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    303                  0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    304          
    305          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    306          #define _DF1S 0
    307          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    308                  0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    309                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    310                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    311          
    312          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    313          #define _DF1S 0
    314          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    315                  0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    316                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    317                  0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    318          
    319          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    320          #define _DF1S 0
    321          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    322                  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    323                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    324                  0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    325          
    326          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    327          #define _DF1S 0
    328          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    329                  0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    330                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    331                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    332          
    333          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    334          #define _DF1S 0
    335          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    336                  0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    337                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    338                  0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    339          
    340          #elif _CODE_PAGE == 1 /* ASCII (for only non-LFN cfg) */
    341          #if _USE_LFN
    342          #error Cannot use LFN feature without valid code page.
    343          #endif
    344          #define _DF1S 0
    345          
    346          #else
    347          #error Unknown code page
    348          
    349          #endif
    350          
    351          
    352          /* Character code support macros */
    353          #define IsUpper(c)  (((c)>='A')&&((c)<='Z'))
    354          #define IsLower(c)  (((c)>='a')&&((c)<='z'))
    355          #define IsDigit(c)  (((c)>='0')&&((c)<='9'))
    356          
    357          #if _DF1S   /* Code page is DBCS */
    358          
    359          #ifdef _DF2S  /* Two 1st byte areas */
    360          #define IsDBCS1(c)  (((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    361          #else     /* One 1st byte area */
    362          #define IsDBCS1(c)  ((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    363          #endif
    364          
    365          #ifdef _DS3S  /* Three 2nd byte areas */
    366          #define IsDBCS2(c)  (((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    367          #else     /* Two 2nd byte areas */
    368          #define IsDBCS2(c)  (((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    369          #endif
    370          
    371          #else     /* Code page is SBCS */
    372          
    373          #define IsDBCS1(c)  0
    374          #define IsDBCS2(c)  0
    375          
    376          #endif /* _DF1S */
    377          
    378          
    379          /* Name status flags */
    380          #define NS      11    /* Index of name status byte in fn[] */
    381          #define NS_LOSS   0x01  /* Out of 8.3 format */
    382          #define NS_LFN    0x02  /* Force to create LFN entry */
    383          #define NS_LAST   0x04  /* Last segment */
    384          #define NS_BODY   0x08  /* Lower case flag (body) */
    385          #define NS_EXT    0x10  /* Lower case flag (ext) */
    386          #define NS_DOT    0x20  /* Dot entry */
    387          
    388          
    389          /* FAT sub-type boundaries */
    390          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    391          #define MIN_FAT16 4086  /* Minimum number of clusters for FAT16 */
    392          #define MIN_FAT32 65526 /* Minimum number of clusters for FAT32 */
    393          
    394          
    395          /* FatFs refers the members in the FAT structures as byte array instead of
    396          / structure member because the structure is not binary compatible between
    397          / different platforms */
    398          
    399          #define BS_jmpBoot      0 /* Jump instruction (3) */
    400          #define BS_OEMName      3 /* OEM name (8) */
    401          #define BPB_BytsPerSec    11  /* Sector size [byte] (2) */
    402          #define BPB_SecPerClus    13  /* Cluster size [sector] (1) */
    403          #define BPB_RsvdSecCnt    14  /* Size of reserved area [sector] (2) */
    404          #define BPB_NumFATs     16  /* Number of FAT copies (1) */
    405          #define BPB_RootEntCnt    17  /* Number of root dir entries for FAT12/16 (2) */
    406          #define BPB_TotSec16    19  /* Volume size [sector] (2) */
    407          #define BPB_Media     21  /* Media descriptor (1) */
    408          #define BPB_FATSz16     22  /* FAT size [sector] (2) */
    409          #define BPB_SecPerTrk   24  /* Track size [sector] (2) */
    410          #define BPB_NumHeads    26  /* Number of heads (2) */
    411          #define BPB_HiddSec     28  /* Number of special hidden sectors (4) */
    412          #define BPB_TotSec32    32  /* Volume size [sector] (4) */
    413          #define BS_DrvNum     36  /* Physical drive number (2) */
    414          #define BS_BootSig      38  /* Extended boot signature (1) */
    415          #define BS_VolID      39  /* Volume serial number (4) */
    416          #define BS_VolLab     43  /* Volume label (8) */
    417          #define BS_FilSysType   54  /* File system type (1) */
    418          #define BPB_FATSz32     36  /* FAT size [sector] (4) */
    419          #define BPB_ExtFlags    40  /* Extended flags (2) */
    420          #define BPB_FSVer     42  /* File system version (2) */
    421          #define BPB_RootClus    44  /* Root dir first cluster (4) */
    422          #define BPB_FSInfo      48  /* Offset of FSInfo sector (2) */
    423          #define BPB_BkBootSec   50  /* Offset of backup boot sectot (2) */
    424          #define BS_DrvNum32     64  /* Physical drive number (2) */
    425          #define BS_BootSig32    66  /* Extended boot signature (1) */
    426          #define BS_VolID32      67  /* Volume serial number (4) */
    427          #define BS_VolLab32     71  /* Volume label (8) */
    428          #define BS_FilSysType32   82  /* File system type (1) */
    429          #define FSI_LeadSig     0 /* FSI: Leading signature (4) */
    430          #define FSI_StrucSig    484 /* FSI: Structure signature (4) */
    431          #define FSI_Free_Count    488 /* FSI: Number of free clusters (4) */
    432          #define FSI_Nxt_Free    492 /* FSI: Last allocated cluster (4) */
    433          #define MBR_Table     446 /* MBR: Partition table offset (2) */
    434          #define SZ_PTE        16  /* MBR: Size of a partition table entry */
    435          #define BS_55AA       510 /* Boot sector signature (2) */
    436          
    437          #define DIR_Name      0 /* Short file name (11) */
    438          #define DIR_Attr      11  /* Attribute (1) */
    439          #define DIR_NTres     12  /* NT flag (1) */
    440          #define DIR_CrtTime     14  /* Created time (2) */
    441          #define DIR_CrtDate     16  /* Created date (2) */
    442          #define DIR_FstClusHI   20  /* Higher 16-bit of first cluster (2) */
    443          #define DIR_WrtTime     22  /* Modified time (2) */
    444          #define DIR_WrtDate     24  /* Modified date (2) */
    445          #define DIR_FstClusLO   26  /* Lower 16-bit of first cluster (2) */
    446          #define DIR_FileSize    28  /* File size (4) */
    447          #define LDIR_Ord      0 /* LFN entry order and LLE flag (1) */
    448          #define LDIR_Attr     11  /* LFN attribute (1) */
    449          #define LDIR_Type     12  /* LFN type (1) */
    450          #define LDIR_Chksum     13  /* Sum of corresponding SFN entry */
    451          #define LDIR_FstClusLO    26  /* Filled by zero (0) */
    452          #define SZ_DIR        32    /* Size of a directory entry */
    453          #define LLE         0x40  /* Last long entry flag in LDIR_Ord */
    454          #define DDE         0xE5  /* Deleted directory enrty mark in DIR_Name[0] */
    455          #define NDDE        0x05  /* Replacement of a character collides with DDE */
    456          
    457          
    458          /*------------------------------------------------------------*/
    459          /* Module private work area                                   */
    460          /*------------------------------------------------------------*/
    461          /* Note that uninitialized variables with static duration are
    462          /  zeroed/nulled at start-up. If not, the compiler or start-up
    463          /  routine is out of ANSI-C standard.
    464          */
    465          
    466          #if _VOLUMES
    467          static

   \                                 In section .bss, align 4
    468          FATFS *FatFs[_VOLUMES]; /* Pointer to the file system objects (logical drives) */
    469          #else
    470          #error Number of volumes must not be 0.
    471          #endif
    472          
    473          static
    474          WORD Fsid;        /* File system mount ID */
    475          
    476          #if _FS_RPATH
    477          static
    478          BYTE CurrVol;     /* Current drive */
   \                     CurrVol:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 4
    479          #endif
    480          
    481          #if _FS_SHARE
    482          static
    483          FILESEM Files[_FS_SHARE]; /* File lock semaphores */
    484          #endif
    485          
    486          #if _USE_LFN == 0     /* No LFN feature */
    487          #define DEF_NAMEBUF     BYTE sfn[12]
    488          #define INIT_BUF(dobj)    (dobj).fn = sfn
    489          #define FREE_BUF()
    490          
    491          #elif _USE_LFN == 1     /* LFN feature with static working buffer */
    492          static WCHAR LfnBuf[_MAX_LFN+1];
    493          #define DEF_NAMEBUF     BYTE sfn[12]
    494          #define INIT_BUF(dobj)    { (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    495          #define FREE_BUF()
    496          
    497          #elif _USE_LFN == 2     /* LFN feature with dynamic working buffer on the stack */
    498          #define DEF_NAMEBUF     BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    499          #define INIT_BUF(dobj)    { (dobj).fn = sfn; (dobj).lfn = lbuf; }
    500          #define FREE_BUF()
    501          
    502          #elif _USE_LFN == 3     /* LFN feature with dynamic working buffer on the heap */
    503          #define DEF_NAMEBUF     BYTE sfn[12]; WCHAR *lfn
    504          #define INIT_BUF(dobj)    { lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    505                          if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    506                          (dobj).lfn = lfn; (dobj).fn = sfn; }
    507          #define FREE_BUF()      ff_memfree(lfn)
    508          
    509          #else
    510          #error Wrong LFN configuration.
    511          #endif
    512          
    513          
    514          
    515          
    516          /*--------------------------------------------------------------------------
    517          
    518             Module Private Functions
    519          
    520          ---------------------------------------------------------------------------*/
    521          
    522          
    523          /*-----------------------------------------------------------------------*/
    524          /* String functions                                                      */
    525          /*-----------------------------------------------------------------------*/
    526          
    527          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    528          static
    529          void mem_cpy (void* dst, const void* src, UINT cnt) {
    530            BYTE *d = (BYTE*)dst;
    531            const BYTE *s = (const BYTE*)src;
   \                     mem_cpy:
   \   00000000   0xE003             B.N      ??mem_cpy_0
    532          
    533          #if _WORD_ACCESS == 1
    534            while (cnt >= sizeof(int)) {
    535              *(int*)d = *(int*)s;
    536              d += sizeof(int); s += sizeof(int);
    537              cnt -= sizeof(int);
    538            }
    539          #endif
    540            while (cnt--)
    541              *d++ = *s++;
   \                     ??mem_cpy_1:
   \   00000002   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000006   0xF800 0x3B01      STRB     R3,[R0], #+1
   \                     ??mem_cpy_0:
   \   0000000A   0x4613             MOV      R3,R2
   \   0000000C   0x1E5A             SUBS     R2,R3,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD1F7             BNE.N    ??mem_cpy_1
    542          }
   \   00000012   0x4770             BX       LR               ;; return
    543          
    544          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    545          static
    546          void mem_set (void* dst, int val, UINT cnt) {
   \                     mem_set:
   \   00000000   0x0013             MOVS     R3,R2
    547            BYTE *d = (BYTE*)dst;
    548          
    549            while (cnt--)
   \   00000002   0xD003             BEQ.N    ??mem_set_0
    550              *d++ = (BYTE)val;
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0x4619             MOV      R1,R3
   \   00000008   0x.... 0x....      B.W      __aeabi_memset
    551          }
   \                     ??mem_set_0:
   \   0000000C   0x4770             BX       LR               ;; return
    552          
    553          /* Compare memory to memory */
    554          static
    555          int mem_cmp (const void* dst, const void* src, UINT cnt) {
    556            const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    557            int r = 0;
    558          
    559            while (cnt-- && (r = *d++ - *s++) == 0) ;
    560            return r;
    561          }
    562          
    563          /* Check if chr is contained in the string */
    564          static
    565          int chk_chr (const char* str, int chr) {
    566            while (*str && *str != chr) str++;
    567            return *str;
    568          }
    569          
    570          
    571          
    572          /*-----------------------------------------------------------------------*/
    573          /* Request/Release grant to access the volume                            */
    574          /*-----------------------------------------------------------------------*/
    575          #if _FS_REENTRANT
    576          
    577          static
    578          int lock_fs (
    579            FATFS *fs   /* File system object */
    580          )
    581          {
    582            return ff_req_grant(fs->sobj);
    583          }
    584          
    585          
    586          static
    587          void unlock_fs (
    588            FATFS *fs,    /* File system object */
    589            FRESULT res   /* Result code to be returned */
    590          )
    591          {
    592            if (res != FR_NOT_ENABLED &&
    593              res != FR_INVALID_DRIVE &&
    594              res != FR_INVALID_OBJECT &&
    595              res != FR_TIMEOUT) {
    596              ff_rel_grant(fs->sobj);
    597            }
    598          }
    599          #endif
    600          
    601          
    602          
    603          /*-----------------------------------------------------------------------*/
    604          /* File shareing control functions                                       */
    605          /*-----------------------------------------------------------------------*/
    606          #if _FS_SHARE
    607          
    608          static
    609          FRESULT chk_lock (  /* Check if the file can be accessed */
    610            DIR* dj,    /* Directory object pointing the file to be checked */
    611            int acc     /* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    612          )
    613          {
    614            UINT i, be;
    615          
    616            /* Search file semaphore table */
    617            for (i = be = 0; i < _FS_SHARE; i++) {
    618              if (Files[i].fs) {  /* Existing entry */
    619                if (Files[i].fs == dj->fs &&    /* Check if the file matched with an open file */
    620                  Files[i].clu == dj->sclust &&
    621                  Files[i].idx == dj->index) break;
    622              } else {      /* Blank entry */
    623                be++;
    624              }
    625            }
    626            if (i == _FS_SHARE) /* The file is not opened */
    627              return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES; /* Is there a blank entry for new file? */
    628          
    629            /* The file has been opened. Reject any open against writing file and all write mode open */
    630            return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    631          }
    632          
    633          
    634          static
    635          int enq_lock (void) /* Check if an entry is available for a new file */
    636          {
    637            UINT i;
    638          
    639            for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
    640            return (i == _FS_SHARE) ? 0 : 1;
    641          }
    642          
    643          
    644          static
    645          UINT inc_lock ( /* Increment file open counter and returns its index (0:int error) */
    646            DIR* dj,  /* Directory object pointing the file to register or increment */
    647            int acc   /* Desired access mode (0:Read, !0:Write) */
    648          )
    649          {
    650            UINT i;
    651          
    652          
    653            for (i = 0; i < _FS_SHARE; i++) { /* Find the file */
    654              if (Files[i].fs == dj->fs &&
    655                Files[i].clu == dj->sclust &&
    656                Files[i].idx == dj->index) break;
    657            }
    658          
    659            if (i == _FS_SHARE) {       /* Not opened. Register it as new. */
    660              for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
    661              if (i == _FS_SHARE) return 0; /* No space to register (int err) */
    662              Files[i].fs = dj->fs;
    663              Files[i].clu = dj->sclust;
    664              Files[i].idx = dj->index;
    665              Files[i].ctr = 0;
    666            }
    667          
    668            if (acc && Files[i].ctr) return 0;  /* Access violation (int err) */
    669          
    670            Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;  /* Set semaphore value */
    671          
    672            return i + 1;
    673          }
    674          
    675          
    676          static
    677          FRESULT dec_lock (  /* Decrement file open counter */
    678            UINT i      /* Semaphore index */
    679          )
    680          {
    681            WORD n;
    682            FRESULT res;
    683          
    684          
    685            if (--i < _FS_SHARE) {
    686              n = Files[i].ctr;
    687              if (n == 0x100) n = 0;
    688              if (n) n--;
    689              Files[i].ctr = n;
    690              if (!n) Files[i].fs = 0;
    691              res = FR_OK;
    692            } else {
    693              res = FR_INT_ERR;
    694            }
    695            return res;
    696          }
    697          
    698          
    699          static
    700          void clear_lock ( /* Clear lock entries of the volume */
    701            FATFS *fs
    702          )
    703          {
    704            UINT i;
    705          
    706            for (i = 0; i < _FS_SHARE; i++) {
    707              if (Files[i].fs == fs) Files[i].fs = 0;
    708            }
    709          }
    710          #endif
    711          
    712          
    713          
    714          /*-----------------------------------------------------------------------*/
    715          /* Change window offset                                                  */
    716          /*-----------------------------------------------------------------------*/
    717          

   \                                 In section .text, align 2, keep-with-next
    718          static
    719          FRESULT move_window (
    720            FATFS *fs,    /* File system object */
    721            DWORD sector  /* Sector number to make appearance in the fs->win[] */
    722          )         /* Move to zero only writes back dirty window */
    723          {
   \                     move_window:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    724            DWORD wsect;
    725          
    726          
    727            wsect = fs->winsect;
   \   00000006   0x6B26             LDR      R6,[R4, #+48]
    728            if (wsect != sector) {  /* Changed current window */
   \   00000008   0x42AE             CMP      R6,R5
   \   0000000A   0xD01D             BEQ.N    ??move_window_0
    729          #if !_FS_READONLY
    730              if (fs->wflag) {  /* Write back dirty window if needed */
   \   0000000C   0x7920             LDRB     R0,[R4, #+4]
   \   0000000E   0xB190             CBZ.N    R0,??move_window_1
    731                if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   \   00000010   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   00000014   0xB9A8             CBNZ.N   R0,??move_window_2
    732                  return FR_DISK_ERR;
    733                fs->wflag = 0;
   \   00000016   0x7120             STRB     R0,[R4, #+4]
    734                if (wsect < (fs->fatbase + fs->fsize)) {  /* In FAT area */
   \   00000018   0x6A60             LDR      R0,[R4, #+36]
   \   0000001A   0x6A21             LDR      R1,[R4, #+32]
   \   0000001C   0x1808             ADDS     R0,R1,R0
   \   0000001E   0x4286             CMP      R6,R0
   \   00000020   0xD209             BCS.N    ??move_window_1
    735                  BYTE nf;
    736                  for (nf = fs->n_fats; nf > 1; nf--) { /* Reflect the change to all FAT copies */
   \   00000022   0x78E7             LDRB     R7,[R4, #+3]
   \   00000024   0xE004             B.N      ??move_window_3
    737                    wsect += fs->fsize;
   \                     ??move_window_4:
   \   00000026   0x6A20             LDR      R0,[R4, #+32]
   \   00000028   0x1986             ADDS     R6,R0,R6
    738                    disk_write(fs->drv, fs->win, wsect, 1);
   \   0000002A   0x.... 0x....      BL       ?Subroutine1
    739                  }
   \                     ??CrossCallReturnLabel_3:
   \   0000002E   0x1E7F             SUBS     R7,R7,#+1
   \                     ??move_window_3:
   \   00000030   0xB2FF             UXTB     R7,R7
   \   00000032   0x2F02             CMP      R7,#+2
   \   00000034   0xD2F7             BCS.N    ??move_window_4
    740                }
    741              }
    742          #endif
    743              if (sector) {
   \                     ??move_window_1:
   \   00000036   0xB13D             CBZ.N    R5,??move_window_0
    744                if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   \   00000038   0x2301             MOVS     R3,#+1
   \   0000003A   0x462A             MOV      R2,R5
   \   0000003C   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_10:
   \   00000040   0xB108             CBZ.N    R0,??move_window_5
    745                  return FR_DISK_ERR;
   \                     ??move_window_2:
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}
    746                fs->winsect = sector;
   \                     ??move_window_5:
   \   00000046   0x6325             STR      R5,[R4, #+48]
    747              }
    748            }
    749          
    750            return FR_OK;
   \                     ??move_window_0:
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    751          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x4632             MOV      R2,R6
   \                     ??Subroutine1_0:
   \   00000004   0xF104 0x0134      ADD      R1,R4,#+52
   \   00000008   0x7860             LDRB     R0,[R4, #+1]
   \   0000000A   0x.... 0x....      B.W      disk_write

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0xF104 0x0134      ADD      R1,R4,#+52
   \   00000004   0x7860             LDRB     R0,[R4, #+1]
   \   00000006   0x.... 0x....      B.W      disk_read
    752          
    753          
    754          
    755          
    756          /*-----------------------------------------------------------------------*/
    757          /* Clean-up cached data                                                  */
    758          /*-----------------------------------------------------------------------*/
    759          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    760          static
    761          FRESULT sync (  /* FR_OK: successful, FR_DISK_ERR: failed */
    762            FATFS *fs /* File system object */
    763          )
    764          {
   \                     sync:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    765            FRESULT res;
    766          
    767          
    768            res = move_window(fs, 0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       move_window
   \   0000000A   0x0005             MOVS     R5,R0
    769            if (res == FR_OK) {
   \   0000000C   0xD157             BNE.N    ??sync_0
    770              /* Update FSInfo sector if needed */
    771              if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD14D             BNE.N    ??sync_1
   \   00000014   0x7960             LDRB     R0,[R4, #+5]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD04A             BEQ.N    ??sync_1
    772                fs->winsect = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6320             STR      R0,[R4, #+48]
    773                /* Create FSInfo structure */
    774                mem_set(fs->win, 0, 512);
   \   0000001E   0xF44F 0x7200      MOV      R2,#+512
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000028   0x.... 0x....      BL       mem_set
    775                ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   0000002C   0x2055             MOVS     R0,#+85
   \   0000002E   0xF884 0x0232      STRB     R0,[R4, #+562]
   \   00000032   0x20AA             MOVS     R0,#+170
   \   00000034   0xF884 0x0233      STRB     R0,[R4, #+563]
    776                ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   00000038   0x2052             MOVS     R0,#+82
   \   0000003A   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000003E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000042   0x2061             MOVS     R0,#+97
   \   00000044   0xF884 0x0036      STRB     R0,[R4, #+54]
   \   00000048   0x2041             MOVS     R0,#+65
   \   0000004A   0xF884 0x0037      STRB     R0,[R4, #+55]
    777                ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   0000004E   0x2072             MOVS     R0,#+114
   \   00000050   0xF884 0x0218      STRB     R0,[R4, #+536]
   \   00000054   0xF884 0x0219      STRB     R0,[R4, #+537]
   \   00000058   0x2041             MOVS     R0,#+65
   \   0000005A   0xF884 0x021A      STRB     R0,[R4, #+538]
   \   0000005E   0x2061             MOVS     R0,#+97
   \   00000060   0xF884 0x021B      STRB     R0,[R4, #+539]
    778                ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   00000064   0x6920             LDR      R0,[R4, #+16]
   \   00000066   0xF884 0x021C      STRB     R0,[R4, #+540]
   \   0000006A   0x6920             LDR      R0,[R4, #+16]
   \   0000006C   0x0400             LSLS     R0,R0,#+16
   \   0000006E   0x0E00             LSRS     R0,R0,#+24
   \   00000070   0xF884 0x021D      STRB     R0,[R4, #+541]
   \   00000074   0x6920             LDR      R0,[R4, #+16]
   \   00000076   0x0C00             LSRS     R0,R0,#+16
   \   00000078   0xF884 0x021E      STRB     R0,[R4, #+542]
   \   0000007C   0x6920             LDR      R0,[R4, #+16]
   \   0000007E   0x0E00             LSRS     R0,R0,#+24
   \   00000080   0xF884 0x021F      STRB     R0,[R4, #+543]
    779                ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   00000084   0x68E0             LDR      R0,[R4, #+12]
   \   00000086   0xF884 0x0220      STRB     R0,[R4, #+544]
   \   0000008A   0x68E0             LDR      R0,[R4, #+12]
   \   0000008C   0x0400             LSLS     R0,R0,#+16
   \   0000008E   0x0E00             LSRS     R0,R0,#+24
   \   00000090   0xF884 0x0221      STRB     R0,[R4, #+545]
   \   00000094   0x68E0             LDR      R0,[R4, #+12]
   \   00000096   0x0C00             LSRS     R0,R0,#+16
   \   00000098   0xF884 0x0222      STRB     R0,[R4, #+546]
   \   0000009C   0x68E0             LDR      R0,[R4, #+12]
   \   0000009E   0x0E00             LSRS     R0,R0,#+24
   \   000000A0   0xF884 0x0223      STRB     R0,[R4, #+547]
    780                /* Write it into the FSInfo sector */
    781                disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   000000A4   0x2301             MOVS     R3,#+1
   \   000000A6   0x6962             LDR      R2,[R4, #+20]
   \   000000A8   0x.... 0x....      BL       ??Subroutine1_0
    782                fs->fsi_flag = 0;
   \                     ??CrossCallReturnLabel_2:
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x7160             STRB     R0,[R4, #+5]
    783              }
    784              /* Make sure that no pending write process in the physical drive */
    785              if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_1:
   \   000000B0   0x2200             MOVS     R2,#+0
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0x7860             LDRB     R0,[R4, #+1]
   \   000000B6   0x.... 0x....      BL       disk_ioctl
   \   000000BA   0xB100             CBZ.N    R0,??sync_0
    786                res = FR_DISK_ERR;
   \   000000BC   0x2501             MOVS     R5,#+1
    787            }
    788          
    789            return res;
   \                     ??sync_0:
   \   000000BE   0x4628             MOV      R0,R5
   \   000000C0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    790          }
    791          #endif
    792          
    793          
    794          
    795          
    796          /*-----------------------------------------------------------------------*/
    797          /* Get sector# from cluster#                                             */
    798          /*-----------------------------------------------------------------------*/
    799          
    800          

   \                                 In section .text, align 2, keep-with-next
    801          DWORD clust2sect (  /* !=0: Sector number, 0: Failed - invalid cluster# */
    802            FATFS *fs,    /* File system object */
    803            DWORD clst    /* Cluster# to be converted */
    804          )
    805          {
    806            clst -= 2;
   \                     clust2sect:
   \   00000000   0x1E89             SUBS     R1,R1,#+2
    807            if (clst >= (fs->n_fatent - 2)) return 0;   /* Invalid cluster# */
   \   00000002   0x69C2             LDR      R2,[R0, #+28]
   \   00000004   0x1E92             SUBS     R2,R2,#+2
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD301             BCC.N    ??clust2sect_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    808            return clst * fs->csize + fs->database;
   \                     ??clust2sect_0:
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x6AC0             LDR      R0,[R0, #+44]
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000016   0x4770             BX       LR               ;; return
    809          }
    810          
    811          
    812          
    813          
    814          /*-----------------------------------------------------------------------*/
    815          /* FAT access - Read value of a FAT entry                                */
    816          /*-----------------------------------------------------------------------*/
    817          
    818          

   \                                 In section .text, align 2, keep-with-next
    819          DWORD get_fat ( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
    820            FATFS *fs,  /* File system object */
    821            DWORD clst  /* Cluster# to get the link information */
    822          )
    823          {
   \                     get_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    824            UINT wc, bc;
    825            BYTE *p;
    826          
    827          
    828            if (clst < 2 || clst >= fs->n_fatent) /* Chack range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD302             BCC.N    ??get_fat_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD301             BCC.N    ??get_fat_1
    829              return 1;
   \                     ??get_fat_0:
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
    830          
    831            switch (fs->fs_type) {
   \                     ??get_fat_1:
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ.N    ??get_fat_2
   \   0000001A   0xD348             BCC.N    ??get_fat_3
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD02E             BEQ.N    ??get_fat_4
   \   00000020   0xD31D             BCC.N    ??get_fat_5
   \   00000022   0xE044             B.N      ??get_fat_3
    832            case FS_FAT12 :
    833              bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_2:
   \   00000024   0xEB05 0x0755      ADD      R7,R5,R5, LSR #+1
    834              if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   00000028   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_41:
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD13E             BNE.N    ??get_fat_3
    835              wc = fs->win[bc % SS(fs)]; bc++;
   \   00000030   0x05F8             LSLS     R0,R7,#+23
   \   00000032   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   00000036   0xF890 0x6034      LDRB     R6,[R0, #+52]
   \   0000003A   0x1C7F             ADDS     R7,R7,#+1
    836              if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   0000003C   0x.... 0x....      BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_40:
   \   00000040   0xBBA8             CBNZ.N   R0,??get_fat_3
    837              wc |= fs->win[bc % SS(fs)] << 8;
   \   00000042   0x05F8             LSLS     R0,R7,#+23
   \   00000044   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   00000048   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   0000004C   0xEA46 0x2600      ORR      R6,R6,R0, LSL #+8
    838              return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   \   00000050   0x07E8             LSLS     R0,R5,#+31
   \   00000052   0xD501             BPL.N    ??get_fat_6
   \   00000054   0x0930             LSRS     R0,R6,#+4
   \   00000056   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??get_fat_6:
   \   00000058   0x0530             LSLS     R0,R6,#+20
   \   0000005A   0x0D00             LSRS     R0,R0,#+20
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}
    839          
    840            case FS_FAT16 :
    841              if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   \                     ??get_fat_5:
   \   0000005E   0x6A60             LDR      R0,[R4, #+36]
   \   00000060   0xEB00 0x2115      ADD      R1,R0,R5, LSR #+8
   \   00000064   0x.... 0x....      BL       ??Subroutine11_0
   \                     ??CrossCallReturnLabel_37:
   \   00000068   0xBB08             CBNZ.N   R0,??get_fat_3
    842              p = &fs->win[clst * 2 % SS(fs)];
   \   0000006A   0x0068             LSLS     R0,R5,#+1
   \   0000006C   0x05C0             LSLS     R0,R0,#+23
   \   0000006E   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   00000072   0x3034             ADDS     R0,R0,#+52
    843              return LD_WORD(p);
   \   00000074   0x7841             LDRB     R1,[R0, #+1]
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000007C   0xBDF2             POP      {R1,R4-R7,PC}
    844          
    845            case FS_FAT32 :
    846              if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   \                     ??get_fat_4:
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0xEB00 0x11D5      ADD      R1,R0,R5, LSR #+7
   \   00000084   0x.... 0x....      BL       ??Subroutine11_0
   \                     ??CrossCallReturnLabel_36:
   \   00000088   0xB988             CBNZ.N   R0,??get_fat_3
    847              p = &fs->win[clst * 4 % SS(fs)];
   \   0000008A   0x00A8             LSLS     R0,R5,#+2
   \   0000008C   0x05C0             LSLS     R0,R0,#+23
   \   0000008E   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   00000092   0x3034             ADDS     R0,R0,#+52
    848              return LD_DWORD(p) & 0x0FFFFFFF;
   \   00000094   0x78C1             LDRB     R1,[R0, #+3]
   \   00000096   0x7882             LDRB     R2,[R0, #+2]
   \   00000098   0x0412             LSLS     R2,R2,#+16
   \   0000009A   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   0000009E   0x7842             LDRB     R2,[R0, #+1]
   \   000000A0   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x4308             ORRS     R0,R0,R1
   \   000000A8   0x0100             LSLS     R0,R0,#+4
   \   000000AA   0x0900             LSRS     R0,R0,#+4
   \   000000AC   0xBDF2             POP      {R1,R4-R7,PC}
    849            }
    850          
    851            return 0xFFFFFFFF;  /* An error occurred at the disk I/O layer */
   \                     ??get_fat_3:
   \   000000AE   0xF04F 0x30FF      MOV      R0,#-1
   \   000000B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    852          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11:
   \   00000000   0x6A60             LDR      R0,[R4, #+36]
   \   00000002   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \                     ??Subroutine11_0:
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x....             B.N      move_window
    853          
    854          
    855          
    856          
    857          /*-----------------------------------------------------------------------*/
    858          /* FAT access - Change value of a FAT entry                              */
    859          /*-----------------------------------------------------------------------*/
    860          #if !_FS_READONLY
    861          

   \                                 In section .text, align 2, keep-with-next
    862          FRESULT put_fat (
    863            FATFS *fs,  /* File system object */
    864            DWORD clst, /* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
    865            DWORD val /* New value to mark the cluster */
    866          )
    867          {
   \                     put_fat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    868            UINT bc;
    869            BYTE *p;
    870            FRESULT res;
    871          
    872          
    873            if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
   \   00000008   0x2E02             CMP      R6,#+2
   \   0000000A   0xD302             BCC.N    ??put_fat_0
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD301             BCC.N    ??put_fat_1
    874              res = FR_INT_ERR;
   \                     ??put_fat_0:
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    875          
    876            } else {
    877              switch (fs->fs_type) {
   \                     ??put_fat_1:
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ.N    ??put_fat_2
   \   0000001C   0xD358             BCC.N    ??put_fat_3
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD03D             BEQ.N    ??put_fat_4
   \   00000022   0xD32C             BCC.N    ??put_fat_5
   \   00000024   0xE054             B.N      ??put_fat_3
    878              case FS_FAT12 :
    879                bc = clst; bc += bc / 2;
   \                     ??put_fat_2:
   \   00000026   0xEB06 0x0756      ADD      R7,R6,R6, LSR #+1
    880                res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000002A   0x.... 0x....      BL       ?Subroutine11
    881                if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_39:
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD14F             BNE.N    ??put_fat_6
    882                p = &fs->win[bc % SS(fs)];
   \   00000032   0x05F8             LSLS     R0,R7,#+23
   \   00000034   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   00000038   0xF100 0x0134      ADD      R1,R0,#+52
    883                *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   0000003C   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   00000040   0xBF1D             ITTTE    NE 
   \   00000042   0x7808             LDRBNE   R0,[R1, #+0]
   \   00000044   0xF000 0x000F      ANDNE    R0,R0,#0xF
   \   00000048   0xEA40 0x1005      ORRNE    R0,R0,R5, LSL #+4
   \   0000004C   0x4628             MOVEQ    R0,R5
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    884                bc++;
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
    885                fs->wflag = 1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x7120             STRB     R0,[R4, #+4]
    886                res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00000056   0x.... 0x....      BL       ?Subroutine11
    887                if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_38:
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD139             BNE.N    ??put_fat_6
    888                p = &fs->win[bc % SS(fs)];
   \   0000005E   0x05F9             LSLS     R1,R7,#+23
   \   00000060   0xEB14 0x51D1      ADDS     R1,R4,R1, LSR #+23
   \   00000064   0x3134             ADDS     R1,R1,#+52
    889                *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   00000066   0xB10E             CBZ.N    R6,??put_fat_7
   \   00000068   0x092A             LSRS     R2,R5,#+4
   \   0000006A   0xE006             B.N      ??put_fat_8
   \                     ??put_fat_7:
   \   0000006C   0x780A             LDRB     R2,[R1, #+0]
   \   0000006E   0xF002 0x02F0      AND      R2,R2,#0xF0
   \   00000072   0x0A2B             LSRS     R3,R5,#+8
   \   00000074   0xF003 0x030F      AND      R3,R3,#0xF
   \   00000078   0x431A             ORRS     R2,R3,R2
   \                     ??put_fat_8:
   \   0000007A   0x700A             STRB     R2,[R1, #+0]
    890                break;
   \   0000007C   0xE029             B.N      ??put_fat_6
    891          
    892              case FS_FAT16 :
    893                res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_5:
   \   0000007E   0x6A60             LDR      R0,[R4, #+36]
   \   00000080   0xEB00 0x2116      ADD      R1,R0,R6, LSR #+8
   \   00000084   0x.... 0x....      BL       ??Subroutine11_0
    894                if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_35:
   \   00000088   0xBB18             CBNZ.N   R0,??put_fat_6
    895                p = &fs->win[clst * 2 % SS(fs)];
   \   0000008A   0x0071             LSLS     R1,R6,#+1
   \   0000008C   0x05C9             LSLS     R1,R1,#+23
   \   0000008E   0xEB14 0x51D1      ADDS     R1,R4,R1, LSR #+23
    896                ST_WORD(p, (WORD)val);
   \   00000092   0xF801 0x5F34      STRB     R5,[R1, #+52]!
   \   00000096   0x042D             LSLS     R5,R5,#+16
   \   00000098   0x0E2A             LSRS     R2,R5,#+24
   \   0000009A   0x704A             STRB     R2,[R1, #+1]
    897                break;
   \   0000009C   0xE019             B.N      ??put_fat_6
    898          
    899              case FS_FAT32 :
    900                res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_4:
   \   0000009E   0x6A60             LDR      R0,[R4, #+36]
   \   000000A0   0xEB00 0x11D6      ADD      R1,R0,R6, LSR #+7
   \   000000A4   0x.... 0x....      BL       ??Subroutine11_0
    901                if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_34:
   \   000000A8   0xB998             CBNZ.N   R0,??put_fat_6
    902                p = &fs->win[clst * 4 % SS(fs)];
   \   000000AA   0x00B1             LSLS     R1,R6,#+2
   \   000000AC   0x05C9             LSLS     R1,R1,#+23
   \   000000AE   0xEB14 0x51D1      ADDS     R1,R4,R1, LSR #+23
   \   000000B2   0x3134             ADDS     R1,R1,#+52
    903                val |= LD_DWORD(p) & 0xF0000000;
   \   000000B4   0x78CA             LDRB     R2,[R1, #+3]
   \   000000B6   0x0612             LSLS     R2,R2,#+24
   \   000000B8   0xF002 0x4270      AND      R2,R2,#0xF0000000
   \   000000BC   0x4315             ORRS     R5,R2,R5
    904                ST_DWORD(p, val);
   \   000000BE   0x700D             STRB     R5,[R1, #+0]
   \   000000C0   0x042A             LSLS     R2,R5,#+16
   \   000000C2   0x0E12             LSRS     R2,R2,#+24
   \   000000C4   0x704A             STRB     R2,[R1, #+1]
   \   000000C6   0x0C2A             LSRS     R2,R5,#+16
   \   000000C8   0x708A             STRB     R2,[R1, #+2]
   \   000000CA   0x0E2A             LSRS     R2,R5,#+24
   \   000000CC   0x70CA             STRB     R2,[R1, #+3]
    905                break;
   \   000000CE   0xE000             B.N      ??put_fat_6
    906          
    907              default :
    908                res = FR_INT_ERR;
   \                     ??put_fat_3:
   \   000000D0   0x2002             MOVS     R0,#+2
    909              }
    910              fs->wflag = 1;
   \                     ??put_fat_6:
   \   000000D2   0x2101             MOVS     R1,#+1
   \   000000D4   0x7121             STRB     R1,[R4, #+4]
    911            }
    912          
    913            return res;
   \   000000D6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    914          }
    915          #endif /* !_FS_READONLY */
    916          
    917          
    918          
    919          
    920          /*-----------------------------------------------------------------------*/
    921          /* FAT handling - Remove a cluster chain                                 */
    922          /*-----------------------------------------------------------------------*/
    923          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    924          static
    925          FRESULT remove_chain (
    926            FATFS *fs,      /* File system object */
    927            DWORD clst      /* Cluster# to remove a chain from */
    928          )
    929          {
   \                     remove_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    930            FRESULT res;
    931            DWORD nxt;
    932          #if _USE_ERASE
    933            DWORD scl = clst, ecl = clst, resion[2];
    934          #endif
    935          
    936            if (clst < 2 || clst >= fs->n_fatent) { /* Check range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD30B             BCC.N    ??remove_chain_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD208             BCS.N    ??remove_chain_0
    937              res = FR_INT_ERR;
    938          
    939            } else {
    940              res = FR_OK;
   \   00000010   0x2600             MOVS     R6,#+0
    941              while (clst < fs->n_fatent) {     /* Not a last link? */
    942                nxt = get_fat(fs, clst);      /* Get cluster status */
   \                     ??remove_chain_1:
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       get_fat
   \   0000001A   0x0007             MOVS     R7,R0
    943                if (nxt == 0) break;        /* Empty cluster? */
   \   0000001C   0xD019             BEQ.N    ??remove_chain_2
    944                if (nxt == 1) { res = FR_INT_ERR; break; }  /* Internal error? */
   \   0000001E   0x2F01             CMP      R7,#+1
   \   00000020   0xD101             BNE.N    ??remove_chain_3
   \                     ??remove_chain_0:
   \   00000022   0x2602             MOVS     R6,#+2
   \   00000024   0xE015             B.N      ??remove_chain_2
    945                if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }  /* Disk error? */
   \                     ??remove_chain_3:
   \   00000026   0xF117 0x0F01      CMN      R7,#+1
   \   0000002A   0xD101             BNE.N    ??remove_chain_4
   \   0000002C   0x2601             MOVS     R6,#+1
   \   0000002E   0xE010             B.N      ??remove_chain_2
    946                res = put_fat(fs, clst, 0);     /* Mark the cluster "empty" */
   \                     ??remove_chain_4:
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x.... 0x....      BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_58:
   \   00000036   0x0006             MOVS     R6,R0
    947                if (res != FR_OK) break;
   \   00000038   0xD10B             BNE.N    ??remove_chain_2
    948                if (fs->free_clust != 0xFFFFFFFF) { /* Update FSInfo */
   \   0000003A   0x6920             LDR      R0,[R4, #+16]
   \   0000003C   0xF110 0x0F01      CMN      R0,#+1
   \   00000040   0xD003             BEQ.N    ??remove_chain_5
    949                  fs->free_clust++;
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x6120             STR      R0,[R4, #+16]
    950                  fs->fsi_flag = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x7160             STRB     R0,[R4, #+5]
    951                }
    952          #if _USE_ERASE
    953                if (ecl + 1 == nxt) { /* Next cluster is contiguous */
    954                  ecl = nxt;
    955                } else {        /* End of contiguous clusters */
    956                  resion[0] = clust2sect(fs, scl);          /* Start sector */
    957                  resion[1] = clust2sect(fs, ecl) + fs->csize - 1;  /* End sector */
    958                  disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);   /* Erase the block */
    959                  scl = ecl = nxt;
    960                }
    961          #endif
    962                clst = nxt; /* Next cluster */
   \                     ??remove_chain_5:
   \   0000004A   0x463D             MOV      R5,R7
    963              }
   \   0000004C   0x69E0             LDR      R0,[R4, #+28]
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD3DF             BCC.N    ??remove_chain_1
    964            }
    965          
    966            return res;
   \                     ??remove_chain_2:
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    967          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16:
   \   00000000   0x4629             MOV      R1,R5
   \                     ??Subroutine16_0:
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x....             B.N      put_fat
    968          #endif
    969          
    970          
    971          
    972          
    973          /*-----------------------------------------------------------------------*/
    974          /* FAT handling - Stretch or Create a cluster chain                      */
    975          /*-----------------------------------------------------------------------*/
    976          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    977          static
    978          DWORD create_chain (  /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    979            FATFS *fs,      /* File system object */
    980            DWORD clst      /* Cluster# to stretch. 0 means create a new chain. */
    981          )
    982          {
   \                     create_chain:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    983            DWORD cs, ncl, scl;
    984            FRESULT res;
    985          
    986          
    987            if (clst == 0) {    /* Create a new chain */
   \   00000006   0xD106             BNE.N    ??create_chain_0
    988              scl = fs->last_clust;     /* Get suggested start point */
   \   00000008   0x68E7             LDR      R7,[R4, #+12]
    989              if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000A   0xB117             CBZ.N    R7,??create_chain_1
   \   0000000C   0x69E0             LDR      R0,[R4, #+28]
   \   0000000E   0x4287             CMP      R7,R0
   \   00000010   0xD30B             BCC.N    ??create_chain_2
   \                     ??create_chain_1:
   \   00000012   0x2701             MOVS     R7,#+1
   \   00000014   0xE009             B.N      ??create_chain_2
    990            }
    991            else {          /* Stretch the current chain */
    992              cs = get_fat(fs, clst);     /* Check the cluster status */
   \                     ??create_chain_0:
   \   00000016   0x.... 0x....      BL       get_fat
    993              if (cs < 2) return 1;     /* It is an invalid cluster */
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD201             BCS.N    ??create_chain_3
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    994              if (cs < fs->n_fatent) return cs; /* It is already followed by next cluster */
   \                     ??create_chain_3:
   \   00000022   0x69E1             LDR      R1,[R4, #+28]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD331             BCC.N    ??create_chain_4
    995              scl = clst;
   \   00000028   0x4637             MOV      R7,R6
    996            }
    997          
    998            ncl = scl;        /* Start cluster */
   \                     ??create_chain_2:
   \   0000002A   0x463D             MOV      R5,R7
    999            for (;;) {
   1000              ncl++;              /* Next cluster */
   \                     ??create_chain_5:
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   1001              if (ncl >= fs->n_fatent) {    /* Wrap around */
   \   0000002E   0x69E0             LDR      R0,[R4, #+28]
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD302             BCC.N    ??create_chain_6
   1002                ncl = 2;
   \   00000034   0x2502             MOVS     R5,#+2
   1003                if (ncl > scl) return 0;  /* No free cluster */
   \   00000036   0x2F02             CMP      R7,#+2
   \   00000038   0xD320             BCC.N    ??create_chain_7
   1004              }
   1005              cs = get_fat(fs, ncl);      /* Get the cluster status */
   \                     ??create_chain_6:
   \   0000003A   0x4629             MOV      R1,R5
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       get_fat
   1006              if (cs == 0) break;       /* Found a free cluster */
   \   00000042   0xB9A0             CBNZ.N   R0,??create_chain_8
   1007              if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1008                return cs;
   1009              if (ncl == scl) return 0;   /* No free cluster */
   1010            }
   1011          
   1012            res = put_fat(fs, ncl, 0x0FFFFFFF); /* Mark the new cluster "last link" */
   \   00000044   0xF06F 0x4270      MVN      R2,#-268435456
   \   00000048   0x.... 0x....      BL       ?Subroutine16
   1013            if (res == FR_OK && clst != 0) {
   \                     ??CrossCallReturnLabel_57:
   \   0000004C   0xB920             CBNZ.N   R0,??CrossCallReturnLabel_56
   \   0000004E   0xB126             CBZ.N    R6,??create_chain_9
   1014              res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
   \   00000050   0x462A             MOV      R2,R5
   \   00000052   0x4631             MOV      R1,R6
   \   00000054   0x.... 0x....      BL       ??Subroutine16_0
   1015            }
   1016            if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_56:
   \   00000058   0xB990             CBNZ.N   R0,??create_chain_10
   1017              fs->last_clust = ncl;     /* Update FSINFO */
   \                     ??create_chain_9:
   \   0000005A   0x60E5             STR      R5,[R4, #+12]
   1018              if (fs->free_clust != 0xFFFFFFFF) {
   \   0000005C   0x6920             LDR      R0,[R4, #+16]
   \   0000005E   0xF110 0x0F01      CMN      R0,#+1
   \   00000062   0xD012             BEQ.N    ??create_chain_11
   1019                fs->free_clust--;
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x6120             STR      R0,[R4, #+16]
   1020                fs->fsi_flag = 1;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x7160             STRB     R0,[R4, #+5]
   \   0000006C   0xE00D             B.N      ??create_chain_11
   1021              }
   1022            } else {
   \                     ??create_chain_8:
   \   0000006E   0xF110 0x0F01      CMN      R0,#+1
   \   00000072   0xBF18             IT       NE 
   \   00000074   0x2801             CMPNE    R0,#+1
   \   00000076   0xD009             BEQ.N    ??create_chain_4
   \   00000078   0x42BD             CMP      R5,R7
   \   0000007A   0xD1D7             BNE.N    ??create_chain_5
   \                     ??create_chain_7:
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xBDF2             POP      {R1,R4-R7,PC}
   1023              ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_10:
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xBF0C             ITE      EQ 
   \   00000084   0xF04F 0x35FF      MOVEQ    R5,#-1
   \   00000088   0x2501             MOVNE    R5,#+1
   1024            }
   1025          
   1026            return ncl;   /* Return new cluster number or error code */
   \                     ??create_chain_11:
   \   0000008A   0x4628             MOV      R0,R5
   \                     ??create_chain_4:
   \   0000008C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1027          }
   1028          #endif /* !_FS_READONLY */
   1029          
   1030          
   1031          
   1032          /*-----------------------------------------------------------------------*/
   1033          /* FAT handling - Convert offset into cluster with link map table        */
   1034          /*-----------------------------------------------------------------------*/
   1035          
   1036          #if _USE_FASTSEEK
   1037          static
   1038          DWORD clmt_clust (  /* <2:Error, >=2:Cluster number */
   1039            FIL* fp,    /* Pointer to the file object */
   1040            DWORD ofs   /* File offset to be converted to cluster# */
   1041          )
   1042          {
   1043            DWORD cl, ncl, *tbl;
   1044          
   1045          
   1046            tbl = fp->cltbl + 1;  /* Top of CLMT */
   1047            cl = ofs / SS(fp->fs) / fp->fs->csize;  /* Cluster order from top of the file */
   1048            for (;;) {
   1049              ncl = *tbl++;     /* Number of cluters in the fragment */
   1050              if (!ncl) return 0;   /* End of table? (error) */
   1051              if (cl < ncl) break;  /* In this fragment? */
   1052              cl -= ncl; tbl++;   /* Next fragment */
   1053            }
   1054            return cl + *tbl; /* Return the cluster number */
   1055          }
   1056          #endif  /* _USE_FASTSEEK */
   1057          
   1058          
   1059          
   1060          /*-----------------------------------------------------------------------*/
   1061          /* Directory handling - Set directory index                              */
   1062          /*-----------------------------------------------------------------------*/
   1063          

   \                                 In section .text, align 2, keep-with-next
   1064          static
   1065          FRESULT dir_sdi (
   1066            DIR *dj,    /* Pointer to directory object */
   1067            WORD idx    /* Directory index number */
   1068          )
   1069          {
   \                     dir_sdi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1070            DWORD clst;
   1071            WORD ic;
   1072          
   1073          
   1074            dj->index = idx;
   \   00000006   0x80E5             STRH     R5,[R4, #+6]
   1075            clst = dj->sclust;
   \   00000008   0x68A1             LDR      R1,[R4, #+8]
   1076            if (clst == 1 || clst >= dj->fs->n_fatent)  /* Check start cluster range */
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD026             BEQ.N    ??dir_sdi_0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x69C2             LDR      R2,[R0, #+28]
   \   00000012   0x4291             CMP      R1,R2
   \   00000014   0xD222             BCS.N    ??dir_sdi_0
   1077              return FR_INT_ERR;
   1078            if (!clst && dj->fs->fs_type == FS_FAT32) /* Replace cluster# 0 with root cluster# if in FAT32 */
   \   00000016   0xB919             CBNZ.N   R1,??dir_sdi_1
   \   00000018   0x7801             LDRB     R1,[R0, #+0]
   \   0000001A   0x2903             CMP      R1,#+3
   \   0000001C   0xD101             BNE.N    ??dir_sdi_2
   1079              clst = dj->fs->dirbase;
   \   0000001E   0x6A81             LDR      R1,[R0, #+40]
   1080          
   1081            if (clst == 0) {  /* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_1:
   \   00000020   0xB931             CBNZ.N   R1,??dir_sdi_3
   1082              dj->clust = clst;
   \                     ??dir_sdi_2:
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x60E1             STR      R1,[R4, #+12]
   1083              if (idx >= dj->fs->n_rootdir)   /* Index is out of range */
   \   00000026   0x8901             LDRH     R1,[R0, #+8]
   \   00000028   0x428D             CMP      R5,R1
   \   0000002A   0xD217             BCS.N    ??dir_sdi_0
   1084                return FR_INT_ERR;
   1085              dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR); /* Sector# */
   \   0000002C   0x6A80             LDR      R0,[R0, #+40]
   \   0000002E   0xE01A             B.N      ??dir_sdi_4
   1086            }
   1087            else {        /* Dynamic table (sub-dirs or root-dir in FAT32) */
   1088              ic = SS(dj->fs) / SZ_DIR * dj->fs->csize; /* Entries per cluster */
   \                     ??dir_sdi_3:
   \   00000030   0x7880             LDRB     R0,[R0, #+2]
   \   00000032   0x0106             LSLS     R6,R0,#+4
   \   00000034   0xE000             B.N      ??dir_sdi_5
   1089              while (idx >= ic) { /* Follow cluster chain */
   1090                clst = get_fat(dj->fs, clst);       /* Get next cluster */
   1091                if (clst == 0xFFFFFFFF) return FR_DISK_ERR; /* Disk error */
   1092                if (clst < 2 || clst >= dj->fs->n_fatent) /* Reached to end of table or int error */
   1093                  return FR_INT_ERR;
   1094                idx -= ic;
   \                     ??dir_sdi_6:
   \   00000036   0x1BAD             SUBS     R5,R5,R6
   \                     ??dir_sdi_5:
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0xB2AD             UXTH     R5,R5
   \   0000003C   0x42B5             CMP      R5,R6
   \   0000003E   0xD30F             BCC.N    ??dir_sdi_7
   \   00000040   0x.... 0x....      BL       get_fat
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0xF111 0x0F01      CMN      R1,#+1
   \   0000004A   0xD101             BNE.N    ??dir_sdi_8
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xBD70             POP      {R4-R6,PC}
   \                     ??dir_sdi_8:
   \   00000050   0x2902             CMP      R1,#+2
   \   00000052   0xD303             BCC.N    ??dir_sdi_0
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x69C0             LDR      R0,[R0, #+28]
   \   00000058   0x4281             CMP      R1,R0
   \   0000005A   0xD3EC             BCC.N    ??dir_sdi_6
   \                     ??dir_sdi_0:
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0xBD70             POP      {R4-R6,PC}
   1095              }
   1096              dj->clust = clst;
   \                     ??dir_sdi_7:
   \   00000060   0x60E1             STR      R1,[R4, #+12]
   1097              dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);  /* Sector# */
   \   00000062   0x.... 0x....      BL       clust2sect
   \                     ??dir_sdi_4:
   \   00000066   0xEB00 0x1015      ADD      R0,R0,R5, LSR #+4
   \   0000006A   0x6120             STR      R0,[R4, #+16]
   1098            }
   1099          
   1100            dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR; /* Ptr to the entry in the sector */
   \   0000006C   0xF005 0x000F      AND      R0,R5,#0xF
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0xEB01 0x1040      ADD      R0,R1,R0, LSL #+5
   \   00000076   0x3034             ADDS     R0,R0,#+52
   \   00000078   0x6160             STR      R0,[R4, #+20]
   1101          
   1102            return FR_OK; /* Seek succeeded */
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xBD70             POP      {R4-R6,PC}       ;; return
   1103          }
   1104          
   1105          
   1106          
   1107          
   1108          /*-----------------------------------------------------------------------*/
   1109          /* Directory handling - Move directory index next                        */
   1110          /*-----------------------------------------------------------------------*/
   1111          

   \                                 In section .text, align 2, keep-with-next
   1112          static
   1113          FRESULT dir_next (  /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
   1114            DIR *dj,    /* Pointer to directory object */
   1115            int stretch   /* 0: Do not stretch table, 1: Stretch table if needed */
   1116          )
   1117          {
   \                     dir_next:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   1118            DWORD clst;
   1119            WORD i;
   1120          
   1121          
   1122            stretch = stretch;    /* To suppress warning on read-only cfg. */
   1123            i = dj->index + 1;
   \   00000006   0x88E0             LDRH     R0,[R4, #+6]
   \   00000008   0x1C45             ADDS     R5,R0,#+1
   \   0000000A   0xB2AD             UXTH     R5,R5
   1124            if (!i || !dj->sect)  /* Report EOT when index has reached 65535 */
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x6920             LDRNE    R0,[R4, #+16]
   \   00000012   0x2800             CMPNE    R0,#+0
   \   00000014   0xD01D             BEQ.N    ??dir_next_0
   1125              return FR_NO_FILE;
   1126          
   1127            if (!(i % (SS(dj->fs) / SZ_DIR))) { /* Sector changed? */
   \   00000016   0xF015 0x0F0F      TST      R5,#0xF
   \   0000001A   0xD155             BNE.N    ??dir_next_1
   1128              dj->sect++;         /* Next sector */
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x6120             STR      R0,[R4, #+16]
   1129          
   1130              if (dj->clust == 0) { /* Static table */
   \   00000020   0x68E1             LDR      R1,[R4, #+12]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xB919             CBNZ.N   R1,??dir_next_2
   1131                if (i >= dj->fs->n_rootdir) /* Report EOT when end of table */
   \   00000026   0x8900             LDRH     R0,[R0, #+8]
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xDB4D             BLT.N    ??dir_next_1
   \   0000002C   0xE011             B.N      ??dir_next_0
   1132                  return FR_NO_FILE;
   1133              }
   1134              else {          /* Dynamic table */
   1135                if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) { /* Cluster changed? */
   \                     ??dir_next_2:
   \   0000002E   0x7882             LDRB     R2,[R0, #+2]
   \   00000030   0x1E52             SUBS     R2,R2,#+1
   \   00000032   0xEA12 0x1F15      TST      R2,R5, LSR #+4
   \   00000036   0xD147             BNE.N    ??dir_next_1
   1136                  clst = get_fat(dj->fs, dj->clust);        /* Get next cluster */
   \   00000038   0x.... 0x....      BL       get_fat
   \   0000003C   0x4606             MOV      R6,R0
   1137                  if (clst <= 1) return FR_INT_ERR;
   \   0000003E   0x2E02             CMP      R6,#+2
   \   00000040   0xD312             BCC.N    ??dir_next_3
   1138                  if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \   00000042   0xF116 0x0F01      CMN      R6,#+1
   \   00000046   0xD036             BEQ.N    ??dir_next_4
   1139                  if (clst >= dj->fs->n_fatent) {         /* When it reached end of dynamic table */
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x69C1             LDR      R1,[R0, #+28]
   \   0000004C   0x428E             CMP      R6,R1
   \   0000004E   0xD337             BCC.N    ??dir_next_5
   1140          #if !_FS_READONLY
   1141                    BYTE c;
   1142                    if (!stretch) return FR_NO_FILE;      /* When do not stretch, report EOT */
   \   00000050   0xB90F             CBNZ.N   R7,??dir_next_6
   \                     ??dir_next_0:
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}
   1143                    clst = create_chain(dj->fs, dj->clust);   /* Stretch cluster chain */
   \                     ??dir_next_6:
   \   00000056   0x68E1             LDR      R1,[R4, #+12]
   \   00000058   0x.... 0x....      BL       create_chain
   \   0000005C   0x0006             MOVS     R6,R0
   1144                    if (clst == 0) return FR_DENIED;      /* No free cluster */
   \   0000005E   0xD101             BNE.N    ??dir_next_7
   \   00000060   0x2007             MOVS     R0,#+7
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}
   1145                    if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_7:
   \   00000064   0x2E01             CMP      R6,#+1
   \   00000066   0xD101             BNE.N    ??dir_next_8
   \                     ??dir_next_3:
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}
   1146                    if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_8:
   \   0000006C   0xF116 0x0F01      CMN      R6,#+1
   \   00000070   0xD021             BEQ.N    ??dir_next_4
   1147                    /* Clean-up stretched table */
   1148                    if (move_window(dj->fs, 0)) return FR_DISK_ERR; /* Flush active window */
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x.... 0x....      BL       ??Subroutine12_0
   \                     ??CrossCallReturnLabel_45:
   \   00000078   0xB9E8             CBNZ.N   R0,??dir_next_4
   1149                    mem_set(dj->fs->win, 0, SS(dj->fs));      /* Clear window buffer */
   \   0000007A   0xF44F 0x7200      MOV      R2,#+512
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x3034             ADDS     R0,R0,#+52
   \   00000084   0x.... 0x....      BL       mem_set
   1150                    dj->fs->winsect = clust2sect(dj->fs, clst); /* Cluster start sector */
   \   00000088   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_63:
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6308             STR      R0,[R1, #+48]
   1151                    for (c = 0; c < dj->fs->csize; c++) {   /* Fill the new cluster with 0 */
   \   00000090   0x2700             MOVS     R7,#+0
   \   00000092   0xE004             B.N      ??dir_next_9
   1152                      dj->fs->wflag = 1;
   1153                      if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   1154                      dj->fs->winsect++;
   \                     ??dir_next_10:
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6B01             LDR      R1,[R0, #+48]
   \   00000098   0x1C49             ADDS     R1,R1,#+1
   \   0000009A   0x6301             STR      R1,[R0, #+48]
   \   0000009C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??dir_next_9:
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x7881             LDRB     R1,[R0, #+2]
   \   000000A2   0xB2FF             UXTB     R7,R7
   \   000000A4   0x428F             CMP      R7,R1
   \   000000A6   0xD208             BCS.N    ??dir_next_11
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x7101             STRB     R1,[R0, #+4]
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x.... 0x....      BL       ??Subroutine12_0
   \                     ??CrossCallReturnLabel_44:
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD0EE             BEQ.N    ??dir_next_10
   \                     ??dir_next_4:
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xBDF2             POP      {R1,R4-R7,PC}
   1155                    }
   1156                    dj->fs->winsect -= c;           /* Rewind window address */
   \                     ??dir_next_11:
   \   000000BA   0x6B01             LDR      R1,[R0, #+48]
   \   000000BC   0x1BC9             SUBS     R1,R1,R7
   \   000000BE   0x6301             STR      R1,[R0, #+48]
   1157          #else
   1158                    return FR_NO_FILE;      /* Report EOT */
   1159          #endif
   1160                  }
   1161                  dj->clust = clst;       /* Initialize data for new cluster */
   \                     ??dir_next_5:
   \   000000C0   0x60E6             STR      R6,[R4, #+12]
   1162                  dj->sect = clust2sect(dj->fs, clst);
   \   000000C2   0x.... 0x....      BL       ?Subroutine18
   1163                }
   1164              }
   1165            }
   \                     ??CrossCallReturnLabel_62:
   \   000000C6   0x6120             STR      R0,[R4, #+16]
   1166          
   1167            dj->index = i;
   \                     ??dir_next_1:
   \   000000C8   0x80E5             STRH     R5,[R4, #+6]
   1168            dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   000000CA   0xF005 0x000F      AND      R0,R5,#0xF
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0xEB01 0x1040      ADD      R0,R1,R0, LSL #+5
   \   000000D4   0x3034             ADDS     R0,R0,#+52
   \   000000D6   0x6160             STR      R0,[R4, #+20]
   1169          
   1170            return FR_OK;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1171          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18:
   \   00000000   0x4631             MOV      R1,R6
   \                     ??Subroutine18_0:
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0x....             B.N      clust2sect

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12:
   \   00000000   0x6921             LDR      R1,[R4, #+16]
   \                     ??Subroutine12_0:
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0x....             B.N      move_window
   1172          
   1173          
   1174          
   1175          
   1176          /*-----------------------------------------------------------------------*/
   1177          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1178          /*-----------------------------------------------------------------------*/
   1179          #if _USE_LFN
   1180          static
   1181          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};  /* Offset of LFN chars in the directory entry */
   1182          
   1183          
   1184          static
   1185          int cmp_lfn (     /* 1:Matched, 0:Not matched */
   1186            WCHAR *lfnbuf,    /* Pointer to the LFN to be compared */
   1187            BYTE *dir     /* Pointer to the directory entry containing a part of LFN */
   1188          )
   1189          {
   1190            UINT i, s;
   1191            WCHAR wc, uc;
   1192          
   1193          
   1194            i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;  /* Get offset in the LFN buffer */
   1195            s = 0; wc = 1;
   1196            do {
   1197              uc = LD_WORD(dir+LfnOfs[s]);  /* Pick an LFN character from the entry */
   1198              if (wc) { /* Last char has not been processed */
   1199                wc = ff_wtoupper(uc);   /* Convert it to upper case */
   1200                if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))  /* Compare it */
   1201                  return 0;       /* Not matched */
   1202              } else {
   1203                if (uc != 0xFFFF) return 0; /* Check filler */
   1204              }
   1205            } while (++s < 13);       /* Repeat until all chars in the entry are checked */
   1206          
   1207            if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i]) /* Last segment matched but different length */
   1208              return 0;
   1209          
   1210            return 1;           /* The part of LFN matched */
   1211          }
   1212          
   1213          
   1214          
   1215          static
   1216          int pick_lfn (      /* 1:Succeeded, 0:Buffer overflow */
   1217            WCHAR *lfnbuf,    /* Pointer to the Unicode-LFN buffer */
   1218            BYTE *dir     /* Pointer to the directory entry */
   1219          )
   1220          {
   1221            UINT i, s;
   1222            WCHAR wc, uc;
   1223          
   1224          
   1225            i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;  /* Offset in the LFN buffer */
   1226          
   1227            s = 0; wc = 1;
   1228            do {
   1229              uc = LD_WORD(dir+LfnOfs[s]);    /* Pick an LFN character from the entry */
   1230              if (wc) { /* Last char has not been processed */
   1231                if (i >= _MAX_LFN) return 0;  /* Buffer overflow? */
   1232                lfnbuf[i++] = wc = uc;      /* Store it */
   1233              } else {
   1234                if (uc != 0xFFFF) return 0;   /* Check filler */
   1235              }
   1236            } while (++s < 13);           /* Read all character in the entry */
   1237          
   1238            if (dir[LDIR_Ord] & LLE) {        /* Put terminator if it is the last LFN part */
   1239              if (i >= _MAX_LFN) return 0;    /* Buffer overflow? */
   1240              lfnbuf[i] = 0;
   1241            }
   1242          
   1243            return 1;
   1244          }
   1245          
   1246          
   1247          #if !_FS_READONLY
   1248          static
   1249          void fit_lfn (
   1250            const WCHAR *lfnbuf,  /* Pointer to the LFN buffer */
   1251            BYTE *dir,        /* Pointer to the directory entry */
   1252            BYTE ord,       /* LFN order (1-20) */
   1253            BYTE sum        /* SFN sum */
   1254          )
   1255          {
   1256            UINT i, s;
   1257            WCHAR wc;
   1258          
   1259          
   1260            dir[LDIR_Chksum] = sum;     /* Set check sum */
   1261            dir[LDIR_Attr] = AM_LFN;    /* Set attribute. LFN entry */
   1262            dir[LDIR_Type] = 0;
   1263            ST_WORD(dir+LDIR_FstClusLO, 0);
   1264          
   1265            i = (ord - 1) * 13;       /* Get offset in the LFN buffer */
   1266            s = wc = 0;
   1267            do {
   1268              if (wc != 0xFFFF) wc = lfnbuf[i++]; /* Get an effective char */
   1269              ST_WORD(dir+LfnOfs[s], wc); /* Put it */
   1270              if (!wc) wc = 0xFFFF;   /* Padding chars following last char */
   1271            } while (++s < 13);
   1272            if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE; /* Bottom LFN part is the start of LFN sequence */
   1273            dir[LDIR_Ord] = ord;      /* Set the LFN order */
   1274          }
   1275          
   1276          #endif
   1277          #endif
   1278          
   1279          
   1280          
   1281          /*-----------------------------------------------------------------------*/
   1282          /* Create numbered name                                                  */
   1283          /*-----------------------------------------------------------------------*/
   1284          #if _USE_LFN
   1285          void gen_numname (
   1286            BYTE *dst,      /* Pointer to generated SFN */
   1287            const BYTE *src,  /* Pointer to source SFN to be modified */
   1288            const WCHAR *lfn, /* Pointer to LFN */
   1289            WORD seq      /* Sequence number */
   1290          )
   1291          {
   1292            BYTE ns[8], c;
   1293            UINT i, j;
   1294          
   1295          
   1296            mem_cpy(dst, src, 11);
   1297          
   1298            if (seq > 5) {  /* On many collisions, generate a hash number instead of sequential number */
   1299              do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   1300            }
   1301          
   1302            /* itoa (hexdecimal) */
   1303            i = 7;
   1304            do {
   1305              c = (seq % 16) + '0';
   1306              if (c > '9') c += 7;
   1307              ns[i--] = c;
   1308              seq /= 16;
   1309            } while (seq);
   1310            ns[i] = '~';
   1311          
   1312            /* Append the number */
   1313            for (j = 0; j < i && dst[j] != ' '; j++) {
   1314              if (IsDBCS1(dst[j])) {
   1315                if (j == i - 1) break;
   1316                j++;
   1317              }
   1318            }
   1319            do {
   1320              dst[j++] = (i < 8) ? ns[i++] : ' ';
   1321            } while (j < 8);
   1322          }
   1323          #endif
   1324          
   1325          
   1326          
   1327          
   1328          /*-----------------------------------------------------------------------*/
   1329          /* Calculate sum of an SFN                                               */
   1330          /*-----------------------------------------------------------------------*/
   1331          #if _USE_LFN
   1332          static
   1333          BYTE sum_sfn (
   1334            const BYTE *dir   /* Ptr to directory entry */
   1335          )
   1336          {
   1337            BYTE sum = 0;
   1338            UINT n = 11;
   1339          
   1340            do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   1341            return sum;
   1342          }
   1343          #endif
   1344          
   1345          
   1346          
   1347          
   1348          /*-----------------------------------------------------------------------*/
   1349          /* Directory handling - Find an object in the directory                  */
   1350          /*-----------------------------------------------------------------------*/
   1351          

   \                                 In section .text, align 2, keep-with-next
   1352          static
   1353          FRESULT dir_find (
   1354            DIR *dj     /* Pointer to the directory object linked to the file name */
   1355          )
   1356          {
   \                     dir_find:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1357            FRESULT res;
   1358            BYTE c, *dir;
   1359          #if _USE_LFN
   1360            BYTE a, ord, sum;
   1361          #endif
   1362          
   1363            res = dir_sdi(dj, 0);     /* Rewind directory object */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       dir_sdi
   1364            if (res != FR_OK) return res;
   \   0000000A   0xB9D8             CBNZ.N   R0,??dir_find_0
   1365          
   1366          #if _USE_LFN
   1367            ord = sum = 0xFF;
   1368          #endif
   1369            do {
   1370              res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_1:
   \   0000000C   0x.... 0x....      BL       ?Subroutine12
   1371              if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_49:
   \   00000010   0xB9C0             CBNZ.N   R0,??dir_find_0
   1372              dir = dj->dir;          /* Ptr to the directory entry of current index */
   \   00000012   0x6961             LDR      R1,[R4, #+20]
   1373              c = dir[DIR_Name];
   1374              if (c == 0) { res = FR_NO_FILE; break; }  /* Reached to end of table */
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   \   00000016   0xB90A             CBNZ.N   R2,??dir_find_2
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xBD70             POP      {R4-R6,PC}
   1375          #if _USE_LFN  /* LFN configuration */
   1376              a = dir[DIR_Attr] & AM_MASK;
   1377              if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {  /* An entry without valid data */
   1378                ord = 0xFF;
   1379              } else {
   1380                if (a == AM_LFN) {      /* An LFN entry is found */
   1381                  if (dj->lfn) {
   1382                    if (c & LLE) {    /* Is it start of LFN sequence? */
   1383                      sum = dir[LDIR_Chksum];
   1384                      c &= ~LLE; ord = c; /* LFN start order */
   1385                      dj->lfn_idx = dj->index;
   1386                    }
   1387                    /* Check validity of the LFN entry and compare it with given name */
   1388                    ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1389                  }
   1390                } else {          /* An SFN entry is found */
   1391                  if (!ord && sum == sum_sfn(dir)) break; /* LFN matched? */
   1392                  ord = 0xFF; dj->lfn_idx = 0xFFFF; /* Reset LFN sequence */
   1393                  if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;  /* SFN matched? */
   1394                }
   1395              }
   1396          #else   /* Non LFN configuration */
   1397              if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   \                     ??dir_find_2:
   \   0000001C   0x7ACA             LDRB     R2,[R1, #+11]
   \   0000001E   0x0712             LSLS     R2,R2,#+28
   \   00000020   0xD40C             BMI.N    ??dir_find_3
   \   00000022   0x220B             MOVS     R2,#+11
   \   00000024   0x69A3             LDR      R3,[R4, #+24]
   \   00000026   0x2500             MOVS     R5,#+0
   \                     ??dir_find_4:
   \   00000028   0x4616             MOV      R6,R2
   \   0000002A   0x1E72             SUBS     R2,R6,#+1
   \   0000002C   0xB12E             CBZ.N    R6,??dir_find_5
   \   0000002E   0xF811 0x5B01      LDRB     R5,[R1], #+1
   \   00000032   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   00000036   0x1BAD             SUBS     R5,R5,R6
   \   00000038   0xD0F6             BEQ.N    ??dir_find_4
   \                     ??dir_find_5:
   \   0000003A   0xB11D             CBZ.N    R5,??dir_find_0
   1398                break;
   1399          #endif
   1400              res = dir_next(dj, 0);    /* Next entry */
   \                     ??dir_find_3:
   \   0000003C   0x.... 0x....      BL       ?Subroutine7
   1401            } while (res == FR_OK);
   \                     ??CrossCallReturnLabel_24:
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD0E3             BEQ.N    ??dir_find_1
   1402          
   1403            return res;
   \                     ??dir_find_0:
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
   1404          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x....             B.N      dir_next
   1405          
   1406          
   1407          
   1408          
   1409          /*-----------------------------------------------------------------------*/
   1410          /* Read an object from the directory                                     */
   1411          /*-----------------------------------------------------------------------*/
   1412          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1413          static
   1414          FRESULT dir_read (
   1415            DIR *dj     /* Pointer to the directory object that pointing the entry to be read */
   1416          )
   1417          {
   \                     dir_read:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1418            FRESULT res;
   1419            BYTE c, *dir;
   1420          #if _USE_LFN
   1421            BYTE a, ord = 0xFF, sum = 0xFF;
   1422          #endif
   1423          
   1424            res = FR_NO_FILE;
   \   00000004   0x2004             MOVS     R0,#+4
   1425            while (dj->sect) {
   \                     ??dir_read_0:
   \   00000006   0x6921             LDR      R1,[R4, #+16]
   \   00000008   0xB189             CBZ.N    R1,??dir_read_1
   1426              res = move_window(dj->fs, dj->sect);
   \   0000000A   0x.... 0x....      BL       ??Subroutine12_0
   1427              if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_43:
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD10D             BNE.N    ??dir_read_1
   1428              dir = dj->dir;          /* Ptr to the directory entry of current index */
   \   00000012   0x6961             LDR      R1,[R4, #+20]
   1429              c = dir[DIR_Name];
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   1430              if (c == 0) { res = FR_NO_FILE; break; }  /* Reached to end of table */
   \   00000016   0xB90A             CBNZ.N   R2,??dir_read_2
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE009             B.N      ??dir_read_3
   1431          #if _USE_LFN  /* LFN configuration */
   1432              a = dir[DIR_Attr] & AM_MASK;
   1433              if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {  /* An entry without valid data */
   1434                ord = 0xFF;
   1435              } else {
   1436                if (a == AM_LFN) {      /* An LFN entry is found */
   1437                  if (c & LLE) {      /* Is it start of LFN sequence? */
   1438                    sum = dir[LDIR_Chksum];
   1439                    c &= ~LLE; ord = c;
   1440                    dj->lfn_idx = dj->index;
   1441                  }
   1442                  /* Check LFN validity and capture it */
   1443                  ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1444                } else {          /* An SFN entry is found */
   1445                  if (ord || sum != sum_sfn(dir)) /* Is there a valid LFN? */
   1446                    dj->lfn_idx = 0xFFFF;   /* It has no LFN. */
   1447                  break;
   1448                }
   1449              }
   1450          #else   /* Non LFN configuration */
   1451              if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL)) /* Is it a valid entry? */
   \                     ??dir_read_2:
   \   0000001C   0x2AE5             CMP      R2,#+229
   \   0000001E   0xD002             BEQ.N    ??dir_read_4
   \   00000020   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000022   0x0709             LSLS     R1,R1,#+28
   \   00000024   0xD506             BPL.N    ??dir_read_5
   1452                break;
   1453          #endif
   1454              res = dir_next(dj, 0);        /* Next entry */
   \                     ??dir_read_4:
   \   00000026   0x.... 0x....      BL       ?Subroutine7
   1455              if (res != FR_OK) break;
   \                     ??CrossCallReturnLabel_23:
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD0EB             BEQ.N    ??dir_read_0
   1456            }
   1457          
   1458            if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1:
   \   0000002E   0xB108             CBZ.N    R0,??dir_read_5
   \                     ??dir_read_3:
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6121             STR      R1,[R4, #+16]
   1459          
   1460            return res;
   \                     ??dir_read_5:
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   1461          }
   1462          #endif
   1463          
   1464          
   1465          
   1466          /*-----------------------------------------------------------------------*/
   1467          /* Register an object to the directory                                   */
   1468          /*-----------------------------------------------------------------------*/
   1469          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1470          static
   1471          FRESULT dir_register (  /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   1472            DIR *dj       /* Target directory with object name to be created */
   1473          )
   1474          {
   \                     dir_register:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1475            FRESULT res;
   1476            BYTE c, *dir;
   1477          #if _USE_LFN  /* LFN configuration */
   1478            WORD n, ne, is;
   1479            BYTE sn[12], *fn, sum;
   1480            WCHAR *lfn;
   1481          
   1482          
   1483            fn = dj->fn; lfn = dj->lfn;
   1484            mem_cpy(sn, fn, 12);
   1485          
   1486            if (_FS_RPATH && (sn[NS] & NS_DOT))   /* Cannot create dot entry */
   1487              return FR_INVALID_NAME;
   1488          
   1489            if (sn[NS] & NS_LOSS) {     /* When LFN is out of 8.3 format, generate a numbered name */
   1490              fn[NS] = 0; dj->lfn = 0;      /* Find only SFN */
   1491              for (n = 1; n < 100; n++) {
   1492                gen_numname(fn, sn, lfn, n);  /* Generate a numbered name */
   1493                res = dir_find(dj);       /* Check if the name collides with existing SFN */
   1494                if (res != FR_OK) break;
   1495              }
   1496              if (n == 100) return FR_DENIED;   /* Abort if too many collisions */
   1497              if (res != FR_NO_FILE) return res;  /* Abort if the result is other than 'not collided' */
   1498              fn[NS] = sn[NS]; dj->lfn = lfn;
   1499            }
   1500          
   1501            if (sn[NS] & NS_LFN) {      /* When LFN is to be created, reserve an SFN + LFN entries. */
   1502              for (ne = 0; lfn[ne]; ne++) ;
   1503              ne = (ne + 25) / 13;
   1504            } else {            /* Otherwise reserve only an SFN entry. */
   1505              ne = 1;
   1506            }
   1507          
   1508            /* Reserve contiguous entries */
   1509            res = dir_sdi(dj, 0);
   1510            if (res != FR_OK) return res;
   1511            n = is = 0;
   1512            do {
   1513              res = move_window(dj->fs, dj->sect);
   1514              if (res != FR_OK) break;
   1515              c = *dj->dir;       /* Check the entry status */
   1516              if (c == DDE || c == 0) { /* Is it a blank entry? */
   1517                if (n == 0) is = dj->index; /* First index of the contiguous entry */
   1518                if (++n == ne) break; /* A contiguous entry that required count is found */
   1519              } else {
   1520                n = 0;          /* Not a blank entry. Restart to search */
   1521              }
   1522              res = dir_next(dj, 1);    /* Next entry with table stretch */
   1523            } while (res == FR_OK);
   1524          
   1525            if (res == FR_OK && ne > 1) { /* Initialize LFN entry if needed */
   1526              res = dir_sdi(dj, is);
   1527              if (res == FR_OK) {
   1528                sum = sum_sfn(dj->fn);  /* Sum of the SFN tied to the LFN */
   1529                ne--;
   1530                do {          /* Store LFN entries in bottom first */
   1531                  res = move_window(dj->fs, dj->sect);
   1532                  if (res != FR_OK) break;
   1533                  fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   1534                  dj->fs->wflag = 1;
   1535                  res = dir_next(dj, 0);  /* Next entry */
   1536                } while (res == FR_OK && --ne);
   1537              }
   1538            }
   1539          
   1540          #else /* Non LFN configuration */
   1541            res = dir_sdi(dj, 0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       dir_sdi
   \   0000000A   0x0005             MOVS     R5,R0
   1542            if (res == FR_OK) {
   \   0000000C   0xD10F             BNE.N    ??dir_register_0
   1543              do {  /* Find a blank entry for the SFN */
   1544                res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_1:
   \   0000000E   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_48:
   \   00000012   0x0005             MOVS     R5,R0
   1545                if (res != FR_OK) break;
   \   00000014   0xD10B             BNE.N    ??dir_register_0
   1546                c = *dj->dir;
   \   00000016   0x6960             LDR      R0,[R4, #+20]
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   1547                if (c == DDE || c == 0) break;  /* Is it a blank entry? */
   \   0000001A   0x28E5             CMP      R0,#+229
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2800             CMPNE    R0,#+0
   \   00000020   0xD006             BEQ.N    ??dir_register_2
   1548                res = dir_next(dj, 1);      /* Next entry with table stretch */
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       dir_next
   \   0000002A   0x0005             MOVS     R5,R0
   1549              } while (res == FR_OK);
   \   0000002C   0xD0EF             BEQ.N    ??dir_register_1
   1550            }
   1551          #endif
   1552          
   1553            if (res == FR_OK) {   /* Initialize the SFN entry */
   \                     ??dir_register_0:
   \   0000002E   0xB97D             CBNZ.N   R5,??dir_register_3
   1554              res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_2:
   \   00000030   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_47:
   \   00000034   0x0005             MOVS     R5,R0
   1555              if (res == FR_OK) {
   \   00000036   0xD10B             BNE.N    ??dir_register_3
   1556                dir = dj->dir;
   \   00000038   0x6966             LDR      R6,[R4, #+20]
   1557                mem_set(dir, 0, SZ_DIR);  /* Clean the entry */
   \   0000003A   0x2220             MOVS     R2,#+32
   \   0000003C   0x.... 0x....      BL       ??Subroutine8_0
   1558                mem_cpy(dir, dj->fn, 11); /* Put SFN */
   \                     ??CrossCallReturnLabel_25:
   \   00000040   0x220B             MOVS     R2,#+11
   \   00000042   0x69A1             LDR      R1,[R4, #+24]
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       mem_cpy
   1559          #if _USE_LFN
   1560                dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
   1561          #endif
   1562                dj->fs->wflag = 1;
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x7101             STRB     R1,[R0, #+4]
   1563              }
   1564            }
   1565          
   1566            return res;
   \                     ??dir_register_3:
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
   1567          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   0xF44F 0x7200      MOV      R2,#+512
   \                     ??Subroutine8_0:
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x4630             MOV      R0,R6
   \   00000008   0x.... 0x....      B.W      mem_set
   1568          #endif /* !_FS_READONLY */
   1569          
   1570          
   1571          
   1572          
   1573          /*-----------------------------------------------------------------------*/
   1574          /* Remove an object from the directory                                   */
   1575          /*-----------------------------------------------------------------------*/
   1576          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1577          static
   1578          FRESULT dir_remove (  /* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1579            DIR *dj       /* Directory object pointing the entry to be removed */
   1580          )
   1581          {
   \                     dir_remove:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1582            FRESULT res;
   1583          #if _USE_LFN  /* LFN configuration */
   1584            WORD i;
   1585          
   1586            i = dj->index;  /* SFN index */
   1587            res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx)); /* Goto the SFN or top of the LFN entries */
   1588            if (res == FR_OK) {
   1589              do {
   1590                res = move_window(dj->fs, dj->sect);
   1591                if (res != FR_OK) break;
   1592                *dj->dir = DDE;     /* Mark the entry "deleted" */
   1593                dj->fs->wflag = 1;
   1594                if (dj->index >= i) break;  /* When reached SFN, all entries of the object has been deleted. */
   1595                res = dir_next(dj, 0);    /* Next entry */
   1596              } while (res == FR_OK);
   1597              if (res == FR_NO_FILE) res = FR_INT_ERR;
   1598            }
   1599          
   1600          #else     /* Non LFN configuration */
   1601            res = dir_sdi(dj, dj->index);
   \   00000004   0x88E1             LDRH     R1,[R4, #+6]
   \   00000006   0x.... 0x....      BL       dir_sdi
   1602            if (res == FR_OK) {
   \   0000000A   0xB940             CBNZ.N   R0,??dir_remove_0
   1603              res = move_window(dj->fs, dj->sect);
   \   0000000C   0x.... 0x....      BL       ?Subroutine12
   1604              if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_46:
   \   00000010   0xB928             CBNZ.N   R0,??dir_remove_0
   1605                *dj->dir = DDE;     /* Mark the entry "deleted" */
   \   00000012   0x6961             LDR      R1,[R4, #+20]
   \   00000014   0x22E5             MOVS     R2,#+229
   \   00000016   0x700A             STRB     R2,[R1, #+0]
   1606                dj->fs->wflag = 1;
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x710A             STRB     R2,[R1, #+4]
   1607              }
   1608            }
   1609          #endif
   1610          
   1611            return res;
   \                     ??dir_remove_0:
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1612          }
   1613          #endif /* !_FS_READONLY */
   1614          
   1615          
   1616          
   1617          
   1618          /*-----------------------------------------------------------------------*/
   1619          /* Pick a segment and create the object name in directory form           */
   1620          /*-----------------------------------------------------------------------*/
   1621          

   \                                 In section .text, align 2, keep-with-next
   1622          static
   1623          FRESULT create_name (
   1624            DIR *dj,      /* Pointer to the directory object */
   1625            const TCHAR **path  /* Pointer to pointer to the segment in the path string */
   1626          )
   1627          {
   \                     create_name:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4688             MOV      R8,R1
   1628          #ifdef _EXCVT
   1629            static const BYTE excvt[] = _EXCVT; /* Upper conversion table for extended chars */
   1630          #endif
   1631          
   1632          #if _USE_LFN  /* LFN configuration */
   1633            BYTE b, cf;
   1634            WCHAR w, *lfn;
   1635            UINT i, ni, si, di;
   1636            const TCHAR *p;
   1637          
   1638            /* Create LFN in Unicode */
   1639            for (p = *path; *p == '/' || *p == '\\'; p++) ; /* Strip duplicated separator */
   1640            lfn = dj->lfn;
   1641            si = di = 0;
   1642            for (;;) {
   1643              w = p[si++];          /* Get a character */
   1644              if (w < ' ' || w == '/' || w == '\\') break;  /* Break on end of segment */
   1645              if (di >= _MAX_LFN)       /* Reject too long name */
   1646                return FR_INVALID_NAME;
   1647          #if !_LFN_UNICODE
   1648              w &= 0xFF;
   1649              if (IsDBCS1(w)) {       /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1650                b = (BYTE)p[si++];      /* Get 2nd byte */
   1651                if (!IsDBCS2(b))
   1652                  return FR_INVALID_NAME; /* Reject invalid sequence */
   1653                w = (w << 8) + b;     /* Create a DBC */
   1654              }
   1655              w = ff_convert(w, 1);     /* Convert ANSI/OEM to Unicode */
   1656              if (!w) return FR_INVALID_NAME; /* Reject invalid code */
   1657          #endif
   1658              if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1659                return FR_INVALID_NAME;
   1660              lfn[di++] = w;          /* Store the Unicode char */
   1661            }
   1662            *path = &p[si];           /* Return pointer to the next segment */
   1663            cf = (w < ' ') ? NS_LAST : 0;   /* Set last segment flag if end of path */
   1664          #if _FS_RPATH
   1665            if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1666              (di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   1667              lfn[di] = 0;
   1668              for (i = 0; i < 11; i++)
   1669                dj->fn[i] = (i < di) ? '.' : ' ';
   1670              dj->fn[i] = cf | NS_DOT;    /* This is a dot entry */
   1671              return FR_OK;
   1672            }
   1673          #endif
   1674            while (di) {            /* Strip trailing spaces and dots */
   1675              w = lfn[di-1];
   1676              if (w != ' ' && w != '.') break;
   1677              di--;
   1678            }
   1679            if (!di) return FR_INVALID_NAME;  /* Reject nul string */
   1680          
   1681            lfn[di] = 0;            /* LFN is created */
   1682          
   1683            /* Create SFN in directory form */
   1684            mem_set(dj->fn, ' ', 11);
   1685            for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;  /* Strip leading spaces and dots */
   1686            if (si) cf |= NS_LOSS | NS_LFN;
   1687            while (di && lfn[di - 1] != '.') di--;  /* Find extension (di<=si: no extension) */
   1688          
   1689            b = i = 0; ni = 8;
   1690            for (;;) {
   1691              w = lfn[si++];          /* Get an LFN char */
   1692              if (!w) break;          /* Break on end of the LFN */
   1693              if (w == ' ' || (w == '.' && si != di)) { /* Remove spaces and dots */
   1694                cf |= NS_LOSS | NS_LFN; continue;
   1695              }
   1696          
   1697              if (i >= ni || si == di) {    /* Extension or end of SFN */
   1698                if (ni == 11) {       /* Long extension */
   1699                  cf |= NS_LOSS | NS_LFN; break;
   1700                }
   1701                if (si != di) cf |= NS_LOSS | NS_LFN; /* Out of 8.3 format */
   1702                if (si > di) break;     /* No extension */
   1703                si = di; i = 8; ni = 11;  /* Enter extension section */
   1704                b <<= 2; continue;
   1705              }
   1706          
   1707              if (w >= 0x80) {        /* Non ASCII char */
   1708          #ifdef _EXCVT
   1709                w = ff_convert(w, 0);   /* Unicode -> OEM code */
   1710                if (w) w = excvt[w - 0x80]; /* Convert extended char to upper (SBCS) */
   1711          #else
   1712                w = ff_convert(ff_wtoupper(w), 0);  /* Upper converted Unicode -> OEM code */
   1713          #endif
   1714                cf |= NS_LFN;       /* Force create LFN entry */
   1715              }
   1716          
   1717              if (_DF1S && w >= 0x100) {    /* Double byte char (always false on SBCS cfg) */
   1718                if (i >= ni - 1) {
   1719                  cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1720                }
   1721                dj->fn[i++] = (BYTE)(w >> 8);
   1722              } else {            /* Single byte char */
   1723                if (!w || chk_chr("+,;=[]", w)) { /* Replace illegal chars for SFN */
   1724                  w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1725                } else {
   1726                  if (IsUpper(w)) {   /* ASCII large capital */
   1727                    b |= 2;
   1728                  } else {
   1729                    if (IsLower(w)) { /* ASCII small capital */
   1730                      b |= 1; w -= 0x20;
   1731                    }
   1732                  }
   1733                }
   1734              }
   1735              dj->fn[i++] = (BYTE)w;
   1736            }
   1737          
   1738            if (dj->fn[0] == DDE) dj->fn[0] = NDDE; /* If the first char collides with deleted mark, replace it with 0x05 */
   1739          
   1740            if (ni == 8) b <<= 2;
   1741            if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) /* Create LFN entry when there are composite capitals */
   1742              cf |= NS_LFN;
   1743            if (!(cf & NS_LFN)) {           /* When LFN is in 8.3 format without extended char, NT flags are created */
   1744              if ((b & 0x03) == 0x01) cf |= NS_EXT; /* NT flag (Extension has only small capital) */
   1745              if ((b & 0x0C) == 0x04) cf |= NS_BODY;  /* NT flag (Filename has only small capital) */
   1746            }
   1747          
   1748            dj->fn[NS] = cf;  /* SFN is created */
   1749          
   1750            return FR_OK;
   1751          
   1752          
   1753          #else /* Non-LFN configuration */
   1754            BYTE b, c, d, *sfn;
   1755            UINT ni, si, i;
   1756            const signed char *p;
   1757          
   1758            /* Create file name in directory form */
   1759            for (p = *path; *p == '/' || *p == '\\'; p++) ; /* Strip duplicated separator */
   \   00000006   0xF8D8 0x6000      LDR      R6,[R8, #+0]
   \   0000000A   0xE000             B.N      ??create_name_0
   \                     ??create_name_1:
   \   0000000C   0x1C76             ADDS     R6,R6,#+1
   \                     ??create_name_0:
   \   0000000E   0xF996 0x1000      LDRSB    R1,[R6, #+0]
   \   00000012   0x292F             CMP      R1,#+47
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x295C             CMPNE    R1,#+92
   \   00000018   0xD0F8             BEQ.N    ??create_name_1
   1760            sfn = dj->fn;
   \   0000001A   0x6984             LDR      R4,[R0, #+24]
   1761            mem_set(sfn, ' ', 11);
   \   0000001C   0x220B             MOVS     R2,#+11
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       mem_set
   1762            si = i = b = 0; ni = 8;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x4602             MOV      R2,R0
   \   0000002C   0x2308             MOVS     R3,#+8
   1763          #if _FS_RPATH
   1764            if (p[si] == '.') { /* Is this a dot entry? */
   \   0000002E   0x5637             LDRSB    R7,[R6, R0]
   \   00000030   0x2F2E             CMP      R7,#+46
   \   00000032   0xD11D             BNE.N    ??create_name_2
   \   00000034   0xE003             B.N      ??create_name_3
   1765              for (;;) {
   1766                c = (BYTE)p[si++];
   1767                if (c != '.' || si >= 3) break;
   \                     ??create_name_4:
   \   00000036   0x2A03             CMP      R2,#+3
   \   00000038   0xD278             BCS.N    ??create_name_5
   1768                sfn[i++] = c;
   \   0000003A   0x550F             STRB     R7,[R1, R4]
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \                     ??create_name_3:
   \   0000003E   0x5797             LDRSB    R7,[R2, R6]
   \   00000040   0xB2FF             UXTB     R7,R7
   \   00000042   0x1C52             ADDS     R2,R2,#+1
   \   00000044   0x2F2E             CMP      R7,#+46
   \   00000046   0xD0F6             BEQ.N    ??create_name_4
   1769              }
   1770              if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   \   00000048   0x2F2F             CMP      R7,#+47
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0x2F5C             CMPNE    R7,#+92
   \   0000004E   0xD001             BEQ.N    ??create_name_6
   \   00000050   0x2F21             CMP      R7,#+33
   \   00000052   0xDA6B             BGE.N    ??create_name_5
   1771              *path = &p[si];                 /* Return pointer to the next segment */
   \                     ??create_name_6:
   \   00000054   0x1990             ADDS     R0,R2,R6
   \   00000056   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1772              sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
   \   0000005A   0x2F21             CMP      R7,#+33
   \   0000005C   0xBFB4             ITE      LT 
   \   0000005E   0x2024             MOVLT    R0,#+36
   \   00000060   0x2020             MOVGE    R0,#+32
   \   00000062   0x72E0             STRB     R0,[R4, #+11]
   1773              return FR_OK;
   \   00000064   0xE079             B.N      ??create_name_7
   1774            }
   1775          #endif
   1776            for (;;) {
   1777              c = (BYTE)p[si++];
   1778              if (c <= ' ' || c == '/' || c == '\\') break; /* Break on end of segment */
   1779              if (c == '.' || i >= ni) {
   1780                if (ni != 8 || c != '.') return FR_INVALID_NAME;
   \                     ??create_name_8:
   \   00000066   0x2B08             CMP      R3,#+8
   \   00000068   0xD160             BNE.N    ??create_name_5
   1781                i = 8; ni = 11;
   \   0000006A   0x2108             MOVS     R1,#+8
   \   0000006C   0x230B             MOVS     R3,#+11
   1782                b <<= 2; continue;
   \   0000006E   0x4628             MOV      R0,R5
   1783              }
   \                     ??create_name_2:
   \   00000070   0x5797             LDRSB    R7,[R2, R6]
   \   00000072   0xB2FF             UXTB     R7,R7
   \   00000074   0x1C52             ADDS     R2,R2,#+1
   \   00000076   0x0085             LSLS     R5,R0,#+2
   \   00000078   0xB2ED             UXTB     R5,R5
   \   0000007A   0x2F21             CMP      R7,#+33
   \   0000007C   0xDB03             BLT.N    ??create_name_9
   \   0000007E   0x2F2F             CMP      R7,#+47
   \   00000080   0xBF18             IT       NE 
   \   00000082   0x2F5C             CMPNE    R7,#+92
   \   00000084   0xD107             BNE.N    ??create_name_10
   1784              if (c >= 0x80) {        /* Extended char? */
   1785                b |= 3;           /* Eliminate NT flag */
   1786          #ifdef _EXCVT
   1787                c = excvt[c-0x80];      /* Upper conversion (SBCS) */
   1788          #else
   1789          #if !_DF1S  /* ASCII only cfg */
   1790                return FR_INVALID_NAME;
   1791          #endif
   1792          #endif
   1793              }
   1794              if (IsDBCS1(c)) {       /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1795                d = (BYTE)p[si++];      /* Get 2nd byte */
   1796                if (!IsDBCS2(d) || i >= ni - 1) /* Reject invalid DBC */
   1797                  return FR_INVALID_NAME;
   1798                sfn[i++] = c;
   1799                sfn[i++] = d;
   1800              } else {            /* Single byte code */
   1801                if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))  /* Reject illegal chrs for SFN */
   1802                  return FR_INVALID_NAME;
   1803                if (IsUpper(c)) {     /* ASCII large capital? */
   1804                  b |= 2;
   1805                } else {
   1806                  if (IsLower(c)) {   /* ASCII small capital? */
   1807                    b |= 1; c -= 0x20;
   1808                  }
   1809                }
   1810                sfn[i++] = c;
   1811              }
   1812            }
   1813            *path = &p[si];           /* Return pointer to the next segment */
   \                     ??create_name_9:
   \   00000086   0x1992             ADDS     R2,R2,R6
   \   00000088   0xF8C8 0x2000      STR      R2,[R8, #+0]
   1814            c = (c <= ' ') ? NS_LAST : 0;   /* Set last segment flag if end of path */
   \   0000008C   0x2F21             CMP      R7,#+33
   \   0000008E   0xBFB4             ITE      LT 
   \   00000090   0x2704             MOVLT    R7,#+4
   \   00000092   0x2700             MOVGE    R7,#+0
   \   00000094   0xE049             B.N      ??create_name_11
   \                     ??create_name_10:
   \   00000096   0x2F2E             CMP      R7,#+46
   \   00000098   0xD0E5             BEQ.N    ??create_name_8
   \   0000009A   0x4299             CMP      R1,R3
   \   0000009C   0xD246             BCS.N    ??create_name_5
   \   0000009E   0x2F80             CMP      R7,#+128
   \   000000A0   0xBFA8             IT       GE 
   \   000000A2   0xF040 0x0003      ORRGE    R0,R0,#0x3
   \   000000A6   0xF101 0x0C01      ADD      R12,R1,#+1
   \   000000AA   0xF1A7 0x0581      SUB      R5,R7,#+129
   \   000000AE   0x2D1F             CMP      R5,#+31
   \   000000B0   0xBF24             ITT      CS 
   \   000000B2   0xF1A7 0x05E0      SUBCS    R5,R7,#+224
   \   000000B6   0x2D1D             CMPCS    R5,#+29
   \   000000B8   0xD213             BCS.N    ??create_name_12
   \   000000BA   0x5795             LDRSB    R5,[R2, R6]
   \   000000BC   0xFA5F 0xFE85      UXTB     LR,R5
   \   000000C0   0x1C52             ADDS     R2,R2,#+1
   \   000000C2   0xF1AE 0x0540      SUB      R5,LR,#+64
   \   000000C6   0x2D3F             CMP      R5,#+63
   \   000000C8   0xBF27             ITTEE    CS 
   \   000000CA   0xF1AE 0x0580      SUBCS    R5,LR,#+128
   \   000000CE   0x2D7D             CMPCS    R5,#+125
   \   000000D0   0x1E5D             SUBCC    R5,R3,#+1
   \   000000D2   0x42A9             CMPCC    R1,R5
   \   000000D4   0xD22A             BCS.N    ??create_name_5
   \   000000D6   0x550F             STRB     R7,[R1, R4]
   \   000000D8   0xF80C 0xE004      STRB     LR,[R12, R4]
   \   000000DC   0xF10C 0x0101      ADD      R1,R12,#+1
   \   000000E0   0xE7C6             B.N      ??create_name_2
   \                     ??create_name_12:
   \   000000E2   0x.... 0x....      ADR.W    R5,`?<Constant "\\"*+,:;<=>?[]|\\177">`
   \   000000E6   0xE000             B.N      ??create_name_13
   \                     ??create_name_14:
   \   000000E8   0x1C6D             ADDS     R5,R5,#+1
   \                     ??create_name_13:
   \   000000EA   0xF895 0x9000      LDRB     R9,[R5, #+0]
   \   000000EE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F2   0xBF18             IT       NE 
   \   000000F4   0x45B9             CMPNE    R9,R7
   \   000000F6   0xD1F7             BNE.N    ??create_name_14
   \   000000F8   0xEA5F 0x0E09      MOVS     LR,R9
   \   000000FC   0xD116             BNE.N    ??create_name_5
   \   000000FE   0xF1A7 0x0E41      SUB      LR,R7,#+65
   \   00000102   0xF1BE 0x0F1A      CMP      LR,#+26
   \   00000106   0xD203             BCS.N    ??create_name_15
   \   00000108   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000010C   0xB2C0             UXTB     R0,R0
   \   0000010E   0xE009             B.N      ??create_name_16
   \                     ??create_name_15:
   \   00000110   0xF1A7 0x0E61      SUB      LR,R7,#+97
   \   00000114   0xF1BE 0x0F1A      CMP      LR,#+26
   \   00000118   0xD204             BCS.N    ??create_name_16
   \   0000011A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000011E   0xB2C0             UXTB     R0,R0
   \   00000120   0x3F20             SUBS     R7,R7,#+32
   \   00000122   0xB2FF             UXTB     R7,R7
   \                     ??create_name_16:
   \   00000124   0x550F             STRB     R7,[R1, R4]
   \   00000126   0x4661             MOV      R1,R12
   \   00000128   0xE7A2             B.N      ??create_name_2
   1815          
   1816            if (!i) return FR_INVALID_NAME;   /* Reject nul string */
   \                     ??create_name_11:
   \   0000012A   0xB909             CBNZ.N   R1,??create_name_17
   \                     ??create_name_5:
   \   0000012C   0x2006             MOVS     R0,#+6
   \   0000012E   0xE015             B.N      ??create_name_18
   1817            if (sfn[0] == DDE) sfn[0] = NDDE; /* When first char collides with DDE, replace it with 0x05 */
   \                     ??create_name_17:
   \   00000130   0x7821             LDRB     R1,[R4, #+0]
   \   00000132   0x29E5             CMP      R1,#+229
   \   00000134   0xBF04             ITT      EQ 
   \   00000136   0x2105             MOVEQ    R1,#+5
   \   00000138   0x7021             STRBEQ   R1,[R4, #+0]
   1818          
   1819            if (ni == 8) b <<= 2;
   \   0000013A   0x2B08             CMP      R3,#+8
   \   0000013C   0xBF08             IT       EQ 
   \   0000013E   0x4628             MOVEQ    R0,R5
   1820            if ((b & 0x03) == 0x01) c |= NS_EXT;  /* NT flag (Name extension has only small capital) */
   \   00000140   0xF000 0x0103      AND      R1,R0,#0x3
   \   00000144   0x2901             CMP      R1,#+1
   \   00000146   0xBF08             IT       EQ 
   \   00000148   0xF047 0x0710      ORREQ    R7,R7,#0x10
   1821            if ((b & 0x0C) == 0x04) c |= NS_BODY; /* NT flag (Name body has only small capital) */
   \   0000014C   0xF000 0x000C      AND      R0,R0,#0xC
   \   00000150   0x2804             CMP      R0,#+4
   \   00000152   0xBF08             IT       EQ 
   \   00000154   0xF047 0x0708      ORREQ    R7,R7,#0x8
   1822          
   1823            sfn[NS] = c;    /* Store NT flag, File name is created */
   \   00000158   0x72E7             STRB     R7,[R4, #+11]
   1824          
   1825            return FR_OK;
   \                     ??create_name_7:
   \   0000015A   0x2000             MOVS     R0,#+0
   \                     ??create_name_18:
   \   0000015C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1826          #endif
   1827          }
   1828          
   1829          
   1830          
   1831          
   1832          /*-----------------------------------------------------------------------*/
   1833          /* Get file information from directory entry                             */
   1834          /*-----------------------------------------------------------------------*/
   1835          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1836          static
   1837          void get_fileinfo (   /* No return code */
   1838            DIR *dj,      /* Pointer to the directory object */
   1839            FILINFO *fno    /* Pointer to the file information to be filled */
   1840          )
   1841          {
   \                     get_fileinfo:
   \   00000000   0xB510             PUSH     {R4,LR}
   1842            UINT i;
   1843            BYTE nt, *dir;
   1844            TCHAR *p, c;
   1845          
   1846          
   1847            p = fno->fname;
   \   00000002   0xF201 0x0209      ADDW     R2,R1,#+9
   1848            if (dj->sect) {
   \   00000006   0x6903             LDR      R3,[R0, #+16]
   \   00000008   0xB39B             CBZ.N    R3,??get_fileinfo_0
   1849              dir = dj->dir;
   \   0000000A   0x6940             LDR      R0,[R0, #+20]
   1850              nt = dir[DIR_NTres];    /* NT flag */
   1851              for (i = 0; i < 8; i++) { /* Copy name body */
   \   0000000C   0x2300             MOVS     R3,#+0
   1852                c = dir[i];
   \                     ??get_fileinfo_1:
   \   0000000E   0x561C             LDRSB    R4,[R3, R0]
   1853                if (c == ' ') break;
   \   00000010   0x2C20             CMP      R4,#+32
   \   00000012   0xD008             BEQ.N    ??get_fileinfo_2
   1854                if (c == NDDE) c = (TCHAR)DDE;
   \   00000014   0x2C05             CMP      R4,#+5
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0xF06F 0x041A      MVNEQ    R4,#+26
   1855                if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   1856          #if _LFN_UNICODE
   1857                if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   1858                  c = (c << 8) | dir[++i];
   1859                c = ff_convert(c, 1);
   1860                if (!c) c = '?';
   1861          #endif
   1862                *p++ = c;
   \   0000001C   0xF802 0x4B01      STRB     R4,[R2], #+1
   1863              }
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x2B08             CMP      R3,#+8
   \   00000024   0xD3F3             BCC.N    ??get_fileinfo_1
   1864              if (dir[8] != ' ') {    /* Copy name extension */
   \                     ??get_fileinfo_2:
   \   00000026   0x7A03             LDRB     R3,[R0, #+8]
   \   00000028   0x2B20             CMP      R3,#+32
   \   0000002A   0xD00B             BEQ.N    ??get_fileinfo_3
   1865                *p++ = '.';
   \   0000002C   0x232E             MOVS     R3,#+46
   \   0000002E   0xF802 0x3B01      STRB     R3,[R2], #+1
   1866                for (i = 8; i < 11; i++) {
   \   00000032   0x2308             MOVS     R3,#+8
   1867                  c = dir[i];
   \                     ??get_fileinfo_4:
   \   00000034   0x561C             LDRSB    R4,[R3, R0]
   1868                  if (c == ' ') break;
   \   00000036   0x2C20             CMP      R4,#+32
   \   00000038   0xD004             BEQ.N    ??get_fileinfo_3
   1869                  if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   1870          #if _LFN_UNICODE
   1871                  if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   1872                    c = (c << 8) | dir[++i];
   1873                  c = ff_convert(c, 1);
   1874                  if (!c) c = '?';
   1875          #endif
   1876                  *p++ = c;
   \   0000003A   0xF802 0x4B01      STRB     R4,[R2], #+1
   1877                }
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
   \   00000040   0x2B0B             CMP      R3,#+11
   \   00000042   0xD3F7             BCC.N    ??get_fileinfo_4
   1878              }
   1879              fno->fattrib = dir[DIR_Attr];       /* Attribute */
   \                     ??get_fileinfo_3:
   \   00000044   0x7AC3             LDRB     R3,[R0, #+11]
   \   00000046   0x720B             STRB     R3,[R1, #+8]
   1880              fno->fsize = LD_DWORD(dir+DIR_FileSize);  /* Size */
   \   00000048   0x7FC3             LDRB     R3,[R0, #+31]
   \   0000004A   0x7F84             LDRB     R4,[R0, #+30]
   \   0000004C   0x0424             LSLS     R4,R4,#+16
   \   0000004E   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   00000052   0x7F44             LDRB     R4,[R0, #+29]
   \   00000054   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   00000058   0x7F04             LDRB     R4,[R0, #+28]
   \   0000005A   0x4323             ORRS     R3,R4,R3
   \   0000005C   0x600B             STR      R3,[R1, #+0]
   1881              fno->fdate = LD_WORD(dir+DIR_WrtDate);    /* Date */
   \   0000005E   0x7E43             LDRB     R3,[R0, #+25]
   \   00000060   0x7E04             LDRB     R4,[R0, #+24]
   \   00000062   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
   \   00000066   0x808B             STRH     R3,[R1, #+4]
   1882              fno->ftime = LD_WORD(dir+DIR_WrtTime);    /* Time */
   \   00000068   0x7DC3             LDRB     R3,[R0, #+23]
   \   0000006A   0x7D80             LDRB     R0,[R0, #+22]
   \   0000006C   0xEA40 0x2003      ORR      R0,R0,R3, LSL #+8
   \   00000070   0x80C8             STRH     R0,[R1, #+6]
   1883            }
   1884            *p = 0;   /* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_0:
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x7010             STRB     R0,[R2, #+0]
   1885          
   1886          #if _USE_LFN
   1887            if (fno->lfname && fno->lfsize) {
   1888              TCHAR *tp = fno->lfname;
   1889              WCHAR w, *lfn;
   1890          
   1891              i = 0;
   1892              if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   1893                lfn = dj->lfn;
   1894                while ((w = *lfn++) != 0) {     /* Get an LFN char */
   1895          #if !_LFN_UNICODE
   1896                  w = ff_convert(w, 0);     /* Unicode -> OEM conversion */
   1897                  if (!w) { i = 0; break; }   /* Could not convert, no LFN */
   1898                  if (_DF1S && w >= 0x100)    /* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1899                    tp[i++] = (TCHAR)(w >> 8);
   1900          #endif
   1901                  if (i >= fno->lfsize - 1) { i = 0; break; } /* Buffer overflow, no LFN */
   1902                  tp[i++] = (TCHAR)w;
   1903                }
   1904              }
   1905              tp[i] = 0;  /* Terminate the LFN str by a \0 */
   1906            }
   1907          #endif
   1908          }
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
   1909          #endif /* _FS_MINIMIZE <= 1 */
   1910          
   1911          
   1912          
   1913          
   1914          /*-----------------------------------------------------------------------*/
   1915          /* Follow a file path                                                    */
   1916          /*-----------------------------------------------------------------------*/
   1917          

   \                                 In section .text, align 2, keep-with-next
   1918          static
   1919          FRESULT follow_path ( /* FR_OK(0): successful, !=0: error code */
   1920            DIR *dj,      /* Directory object to return last directory and found object */
   1921            const TCHAR *path /* Full-path string to find a file or directory */
   1922          )
   1923          {
   \                     follow_path:
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1924            FRESULT res;
   1925            BYTE *dir, ns;
   1926          
   1927          
   1928          #if _FS_RPATH
   1929            if (*path == '/' || *path == '\\') { /* There is a heading separator */
   \   00000004   0xF991 0x0000      LDRSB    R0,[R1, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x285C             CMPNE    R0,#+92
   \   0000000E   0xD103             BNE.N    ??follow_path_0
   1930              path++; dj->sclust = 0;   /* Strip it and start from the root dir */
   \   00000010   0x1C48             ADDS     R0,R1,#+1
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE001             B.N      ??follow_path_1
   1931            } else {              /* No heading separator */
   1932              dj->sclust = dj->fs->cdir;  /* Start from the current dir */
   \                     ??follow_path_0:
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6980             LDR      R0,[R0, #+24]
   \                     ??follow_path_1:
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
   1933            }
   1934          #else
   1935            if (*path == '/' || *path == '\\')  /* Strip heading separator if exist */
   1936              path++;
   1937            dj->sclust = 0;           /* Start from the root dir */
   1938          #endif
   1939          
   1940            if ((UINT)*path < ' ') {      /* Nul path means the start directory itself */
   \   0000001E   0x9801             LDR      R0,[SP, #+4]
   \   00000020   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2820             CMP      R0,#+32
   \   00000028   0xD206             BCS.N    ??CrossCallReturnLabel_64
   1941              res = dir_sdi(dj, 0);
   \   0000002A   0x.... 0x....      BL       ?Subroutine9
   1942              dj->dir = 0;
   \                     ??CrossCallReturnLabel_30:
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6161             STR      R1,[R4, #+20]
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}
   1943          
   1944            } else {              /* Follow path */
   1945              for (;;) {
   1946                res = create_name(dj, &path); /* Get a segment */
   1947                if (res != FR_OK) break;
   1948                res = dir_find(dj);       /* Find it */
   1949                ns = *(dj->fn+NS);
   1950                if (res != FR_OK) {       /* Failed to find the object */
   1951                  if (res != FR_NO_FILE) break; /* Abort if any hard error occured */
   1952                  /* Object not found */
   1953                  if (_FS_RPATH && (ns & NS_DOT)) { /* If dot entry is not exit */
   1954                    dj->sclust = 0; dj->dir = 0;  /* It is the root dir */
   1955                    res = FR_OK;
   1956                    if (!(ns & NS_LAST)) continue;
   1957                  } else {              /* Could not find the object */
   1958                    if (!(ns & NS_LAST)) res = FR_NO_PATH;
   1959                  }
   1960                  break;
   1961                }
   1962                if (ns & NS_LAST) break;      /* Last segment match. Function completed. */
   1963                dir = dj->dir;            /* There is next segment. Follow the sub directory */
   1964                if (!(dir[DIR_Attr] & AM_DIR)) {  /* Cannot follow because it is a file */
   1965                  res = FR_NO_PATH; break;
   1966                }
   1967                dj->sclust = LD_CLUST(dir);
   \                     ??follow_path_2:
   \   00000034   0x.... 0x....      BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_64:
   \   00000038   0xA901             ADD      R1,SP,#+4
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       create_name
   \   00000040   0xB9C8             CBNZ.N   R0,??follow_path_3
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       dir_find
   \   00000048   0x69A1             LDR      R1,[R4, #+24]
   \   0000004A   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000004C   0xF001 0x0204      AND      R2,R1,#0x4
   \   00000050   0xB158             CBZ.N    R0,??follow_path_4
   \   00000052   0x2804             CMP      R0,#+4
   \   00000054   0xD10F             BNE.N    ??follow_path_3
   \   00000056   0x0689             LSLS     R1,R1,#+26
   \   00000058   0xD505             BPL.N    ??follow_path_5
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
   \   0000005E   0x6160             STR      R0,[R4, #+20]
   \   00000060   0x2A00             CMP      R2,#+0
   \   00000062   0xD0E9             BEQ.N    ??CrossCallReturnLabel_64
   \   00000064   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??follow_path_5:
   \   00000066   0xB932             CBNZ.N   R2,??follow_path_3
   \   00000068   0xE004             B.N      ??follow_path_6
   \                     ??follow_path_4:
   \   0000006A   0xB922             CBNZ.N   R2,??follow_path_3
   \   0000006C   0x6960             LDR      R0,[R4, #+20]
   \   0000006E   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000070   0x06C9             LSLS     R1,R1,#+27
   \   00000072   0xD4DF             BMI.N    ??follow_path_2
   \                     ??follow_path_6:
   \   00000074   0x2005             MOVS     R0,#+5
   1968              }
   1969            }
   1970          
   1971            return res;
   \                     ??follow_path_3:
   \   00000076   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1972          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19:
   \   00000000   0x7D41             LDRB     R1,[R0, #+21]
   \   00000002   0x7D02             LDRB     R2,[R0, #+20]
   \   00000004   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000008   0x7EC2             LDRB     R2,[R0, #+27]
   \   0000000A   0x7E80             LDRB     R0,[R0, #+26]
   \   0000000C   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \   00000010   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000014   0x60A0             STR      R0,[R4, #+8]
   \   00000016   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x.... 0x....      B.W      dir_sdi
   1973          
   1974          
   1975          
   1976          
   1977          /*-----------------------------------------------------------------------*/
   1978          /* Load a sector and check if it is an FAT Volume Boot Record            */
   1979          /*-----------------------------------------------------------------------*/
   1980          

   \                                 In section .text, align 2, keep-with-next
   1981          static
   1982          BYTE check_fs ( /* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
   1983            FATFS *fs,  /* File system object */
   1984            DWORD sect  /* Sector# (lba) to check if it is an FAT boot record or not */
   1985          )
   1986          {
   \                     check_fs:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1987            if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK) /* Load boot record */
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_9:
   \   0000000C   0xB108             CBZ.N    R0,??check_fs_0
   1988              return 3;
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0xBD10             POP      {R4,PC}
   1989            if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)   /* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0:
   \   00000012   0xF894 0x0233      LDRB     R0,[R4, #+563]
   \   00000016   0xF894 0x1232      LDRB     R1,[R4, #+562]
   \   0000001A   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   0000001E   0xF64A 0x2155      MOVW     R1,#+43605
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD001             BEQ.N    ??check_fs_1
   1990              return 2;
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xBD10             POP      {R4,PC}
   1991          
   1992            if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) /* Check "FAT" string */
   \                     ??check_fs_1:
   \   0000002A   0xF204 0x016A      ADDW     R1,R4,#+106
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable10  ;; 0x544146
   \   00000032   0x788A             LDRB     R2,[R1, #+2]
   \   00000034   0x784B             LDRB     R3,[R1, #+1]
   \   00000036   0x021B             LSLS     R3,R3,#+8
   \   00000038   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   0000003C   0xF894 0x306A      LDRB     R3,[R4, #+106]
   \   00000040   0x431A             ORRS     R2,R3,R2
   \   00000042   0x4282             CMP      R2,R0
   \   00000044   0xD008             BEQ.N    ??check_fs_2
   1993              return 0;
   1994            if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \   00000046   0x7F8A             LDRB     R2,[R1, #+30]
   \   00000048   0x7F4B             LDRB     R3,[R1, #+29]
   \   0000004A   0x021B             LSLS     R3,R3,#+8
   \   0000004C   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   00000050   0x7F09             LDRB     R1,[R1, #+28]
   \   00000052   0x4311             ORRS     R1,R1,R2
   \   00000054   0x4281             CMP      R1,R0
   \   00000056   0xD101             BNE.N    ??check_fs_3
   1995              return 0;
   \                     ??check_fs_2:
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD10             POP      {R4,PC}
   1996          
   1997            return 1;
   \                     ??check_fs_3:
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
   1998          }
   1999          
   2000          
   2001          
   2002          
   2003          /*-----------------------------------------------------------------------*/
   2004          /* Check if the file system object is valid or not                       */
   2005          /*-----------------------------------------------------------------------*/
   2006          

   \                                 In section .text, align 2, keep-with-next
   2007          static
   2008          FRESULT chk_mounted ( /* FR_OK(0): successful, !=0: any error occurred */
   2009            const TCHAR **path, /* Pointer to pointer to the path name (drive number) */
   2010            FATFS **rfs,    /* Pointer to pointer to the found file system object */
   2011            BYTE chk_wp     /* !=0: Check media write protection for write access */
   2012          )
   2013          {
   \                     chk_mounted:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4616             MOV      R6,R2
   2014            BYTE fmt, b, pi, *tbl;
   2015            UINT vol;
   2016            DSTATUS stat;
   2017            DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2018            WORD nrsv;
   2019            const TCHAR *p = *path;
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   2020            FATFS *fs;
   2021          
   2022            /* Get logical drive number from the path name */
   2023            vol = p[0] - '0';         /* Is there a drive number? */
   \   00000006   0xF992 0x3000      LDRSB    R3,[R2, #+0]
   \   0000000A   0x3B30             SUBS     R3,R3,#+48
   2024            if (vol <= 9 && p[1] == ':') {    /* Found a drive number, get and strip it */
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable10_1
   \   00000010   0x2B0A             CMP      R3,#+10
   \   00000012   0xD206             BCS.N    ??chk_mounted_0
   \   00000014   0xF992 0x5001      LDRSB    R5,[R2, #+1]
   \   00000018   0x2D3A             CMP      R5,#+58
   \   0000001A   0xD102             BNE.N    ??chk_mounted_0
   2025              p += 2; *path = p;        /* Return pointer to the path name */
   \   0000001C   0x1C92             ADDS     R2,R2,#+2
   \   0000001E   0x6002             STR      R2,[R0, #+0]
   \   00000020   0xE000             B.N      ??chk_mounted_1
   2026            } else {              /* No drive number is given */
   2027          #if _FS_RPATH
   2028              vol = CurrVol;          /* Use current drive */
   \                     ??chk_mounted_0:
   \   00000022   0x7823             LDRB     R3,[R4, #+0]
   2029          #else
   2030              vol = 0;            /* Use drive 0 */
   2031          #endif
   2032            }
   2033          
   2034            /* Check if the file system object is valid or not */
   2035            if (vol >= _VOLUMES)        /* Is the drive number valid? */
   \                     ??chk_mounted_1:
   \   00000024   0xB10B             CBZ.N    R3,??chk_mounted_2
   2036              return FR_INVALID_DRIVE;
   \   00000026   0x200B             MOVS     R0,#+11
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
   2037            *rfs = fs = FatFs[vol];       /* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_2:
   \   0000002A   0x6865             LDR      R5,[R4, #+4]
   \   0000002C   0x600D             STR      R5,[R1, #+0]
   2038            if (!fs) return FR_NOT_ENABLED;   /* Is the file system object available? */
   \   0000002E   0xB90D             CBNZ.N   R5,??chk_mounted_3
   \   00000030   0x200C             MOVS     R0,#+12
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
   2039          
   2040            ENTER_FF(fs);           /* Lock file system */
   2041          
   2042            if (fs->fs_type) {          /* If the logical drive has been mounted */
   \                     ??chk_mounted_3:
   \   00000034   0x7828             LDRB     R0,[R5, #+0]
   \   00000036   0xB148             CBZ.N    R0,??chk_mounted_4
   2043              stat = disk_status(fs->drv);
   \   00000038   0x7868             LDRB     R0,[R5, #+1]
   \   0000003A   0x.... 0x....      BL       disk_status
   2044              if (!(stat & STA_NOINIT)) {   /* and the physical drive is kept initialized (has not been changed), */
   \   0000003E   0x07C1             LSLS     R1,R0,#+31
   \   00000040   0xD404             BMI.N    ??chk_mounted_4
   2045                if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))  /* Check write protection if needed */
   \   00000042   0xB10E             CBZ.N    R6,??chk_mounted_5
   \   00000044   0x0740             LSLS     R0,R0,#+29
   \   00000046   0xD40D             BMI.N    ??chk_mounted_6
   2046                  return FR_WRITE_PROTECTED;
   2047                return FR_OK;       /* The file system object is valid */
   \                     ??chk_mounted_5:
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
   2048              }
   2049            }
   2050          
   2051            /* The file system object is not valid. */
   2052            /* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2053          
   2054            fs->fs_type = 0;          /* Clear the file system object */
   \                     ??chk_mounted_4:
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
   2055            fs->drv = LD2PD(vol);       /* Bind the logical drive and a physical drive */
   \   00000050   0x7068             STRB     R0,[R5, #+1]
   2056            stat = disk_initialize(fs->drv);  /* Initialize low level disk I/O layer */
   \   00000052   0x.... 0x....      BL       disk_initialize
   2057            if (stat & STA_NOINIT)        /* Check if the initialization succeeded */
   \   00000056   0x07C1             LSLS     R1,R0,#+31
   \   00000058   0xD501             BPL.N    ??chk_mounted_7
   2058              return FR_NOT_READY;      /* Failed to initialize due to no media or hard error */
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}
   2059            if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))  /* Check disk write protection if needed */
   \                     ??chk_mounted_7:
   \   0000005E   0xB11E             CBZ.N    R6,??chk_mounted_8
   \   00000060   0x0740             LSLS     R0,R0,#+29
   \   00000062   0xD501             BPL.N    ??chk_mounted_8
   2060              return FR_WRITE_PROTECTED;
   \                     ??chk_mounted_6:
   \   00000064   0x200A             MOVS     R0,#+10
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}
   2061          #if _MAX_SS != 512            /* Get disk sector size (variable sector size cfg only) */
   2062            if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2063              return FR_DISK_ERR;
   2064          #endif
   2065            /* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
   2066            fmt = check_fs(fs, bsect = 0);    /* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   \                     ??chk_mounted_8:
   \   00000068   0x2600             MOVS     R6,#+0
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       check_fs
   \   00000072   0x4607             MOV      R7,R0
   2067            if (LD2PT(vol) && !fmt) fmt = 1;  /* Force non-SFD if the volume is forced partition */
   2068            if (fmt == 1) {           /* Not an FAT-VBR, the physical drive can be partitioned */
   \   00000074   0x2F01             CMP      R7,#+1
   \   00000076   0xD114             BNE.N    ??chk_mounted_9
   2069              /* Check the partition listed in the partition table */
   2070              pi = LD2PT(vol);
   2071              if (pi) pi--;
   2072              tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
   \   00000078   0xF205 0x10F2      ADDW     R0,R5,#+498
   2073              if (tbl[4]) {           /* Is the partition existing? */
   \   0000007C   0x7901             LDRB     R1,[R0, #+4]
   \   0000007E   0x2900             CMP      R1,#+0
   \   00000080   0xD040             BEQ.N    ??chk_mounted_10
   2074                bsect = LD_DWORD(&tbl[8]);    /* Partition offset in LBA */
   \   00000082   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000084   0x7A82             LDRB     R2,[R0, #+10]
   \   00000086   0x0412             LSLS     R2,R2,#+16
   \   00000088   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   0000008C   0x7A42             LDRB     R2,[R0, #+9]
   \   0000008E   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000092   0x7A00             LDRB     R0,[R0, #+8]
   \   00000094   0xEA40 0x0601      ORR      R6,R0,R1
   2075                fmt = check_fs(fs, bsect);    /* Check the partition */
   \   00000098   0x4631             MOV      R1,R6
   \   0000009A   0x4628             MOV      R0,R5
   \   0000009C   0x.... 0x....      BL       check_fs
   \   000000A0   0x4607             MOV      R7,R0
   2076              }
   2077            }
   2078            if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_9:
   \   000000A2   0x2F03             CMP      R7,#+3
   \   000000A4   0xD101             BNE.N    ??chk_mounted_11
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xBDF2             POP      {R1,R4-R7,PC}
   2079            if (fmt) return FR_NO_FILESYSTEM;   /* No FAT volume is found */
   \                     ??chk_mounted_11:
   \   000000AA   0x2F00             CMP      R7,#+0
   \   000000AC   0xBF01             ITTTT    EQ 
   \   000000AE   0xF895 0x0040      LDRBEQ   R0,[R5, #+64]
   \   000000B2   0xF895 0x103F      LDRBEQ   R1,[R5, #+63]
   \   000000B6   0xEA41 0x2000      ORREQ    R0,R1,R0, LSL #+8
   \   000000BA   0xF5B0 0x7F00      CMPEQ    R0,#+512
   2080          
   2081            /* An FAT volume is found. Following code initializes the file system object */
   2082          
   2083            if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))    /* (BPB_BytsPerSec must be equal to the physical sector size) */
   \   000000BE   0xD11B             BNE.N    ??chk_mounted_12
   2084              return FR_NO_FILESYSTEM;
   2085          
   2086            fasize = LD_WORD(fs->win+BPB_FATSz16);        /* Number of sectors per FAT */
   \   000000C0   0xF895 0x004B      LDRB     R0,[R5, #+75]
   \   000000C4   0xF895 0x104A      LDRB     R1,[R5, #+74]
   \   000000C8   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   2087            if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   000000CC   0xD10D             BNE.N    ??chk_mounted_13
   \   000000CE   0xF895 0x005B      LDRB     R0,[R5, #+91]
   \   000000D2   0xF895 0x105A      LDRB     R1,[R5, #+90]
   \   000000D6   0x0409             LSLS     R1,R1,#+16
   \   000000D8   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000000DC   0xF895 0x1059      LDRB     R1,[R5, #+89]
   \   000000E0   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000000E4   0xF895 0x1058      LDRB     R1,[R5, #+88]
   \   000000E8   0x4308             ORRS     R0,R1,R0
   2088            fs->fsize = fasize;
   \                     ??chk_mounted_13:
   \   000000EA   0x6228             STR      R0,[R5, #+32]
   2089          
   2090            fs->n_fats = b = fs->win[BPB_NumFATs];        /* Number of FAT copies */
   \   000000EC   0xF895 0x1044      LDRB     R1,[R5, #+68]
   \   000000F0   0x70E9             STRB     R1,[R5, #+3]
   2091            if (b != 1 && b != 2) return FR_NO_FILESYSTEM;    /* (Must be 1 or 2) */
   \   000000F2   0x2901             CMP      R1,#+1
   \   000000F4   0xBF18             IT       NE 
   \   000000F6   0x2902             CMPNE    R1,#+2
   \                     ??chk_mounted_12:
   \   000000F8   0xD176             BNE.N    ??chk_mounted_14
   2092            fasize *= b;                    /* Number of sectors for FAT area */
   \   000000FA   0x4348             MULS     R0,R1,R0
   2093          
   2094            fs->csize = b = fs->win[BPB_SecPerClus];      /* Number of sectors per cluster */
   \   000000FC   0xF895 0x1041      LDRB     R1,[R5, #+65]
   \   00000100   0x70A9             STRB     R1,[R5, #+2]
   2095            if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM; /* (Must be power of 2) */
   \   00000102   0x2900             CMP      R1,#+0
   \                     ??chk_mounted_10:
   \   00000104   0xD070             BEQ.N    ??chk_mounted_14
   \   00000106   0x1E4A             SUBS     R2,R1,#+1
   \   00000108   0x4211             TST      R1,R2
   \   0000010A   0xD16D             BNE.N    ??chk_mounted_14
   2096          
   2097            fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);  /* Number of root directory entries */
   \   0000010C   0xF895 0x1046      LDRB     R1,[R5, #+70]
   \   00000110   0xF895 0x2045      LDRB     R2,[R5, #+69]
   \   00000114   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000118   0x8129             STRH     R1,[R5, #+8]
   2098            if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM; /* (BPB_RootEntCnt must be sector aligned) */
   \   0000011A   0x220F             MOVS     R2,#+15
   \   0000011C   0x4211             TST      R1,R2
   \   0000011E   0xD163             BNE.N    ??chk_mounted_14
   2099          
   2100            tsect = LD_WORD(fs->win+BPB_TotSec16);        /* Number of sectors on the volume */
   \   00000120   0xF895 0x2048      LDRB     R2,[R5, #+72]
   \   00000124   0xF895 0x3047      LDRB     R3,[R5, #+71]
   \   00000128   0xEA53 0x2702      ORRS     R7,R3,R2, LSL #+8
   2101            if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   0000012C   0xD10E             BNE.N    ??chk_mounted_15
   \   0000012E   0xF895 0x2057      LDRB     R2,[R5, #+87]
   \   00000132   0xF895 0x3056      LDRB     R3,[R5, #+86]
   \   00000136   0x041B             LSLS     R3,R3,#+16
   \   00000138   0xEA43 0x6202      ORR      R2,R3,R2, LSL #+24
   \   0000013C   0xF895 0x3055      LDRB     R3,[R5, #+85]
   \   00000140   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000144   0xF895 0x3054      LDRB     R3,[R5, #+84]
   \   00000148   0xEA43 0x0702      ORR      R7,R3,R2
   2102          
   2103            nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);       /* Number of reserved sectors */
   \                     ??chk_mounted_15:
   \   0000014C   0xF895 0x2043      LDRB     R2,[R5, #+67]
   \   00000150   0xF895 0x3042      LDRB     R3,[R5, #+66]
   \   00000154   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   2104            if (!nrsv) return FR_NO_FILESYSTEM;         /* (BPB_RsvdSecCnt must not be 0) */
   \   00000158   0xD046             BEQ.N    ??chk_mounted_14
   2105          
   2106            /* Determine the FAT sub type */
   2107            sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR); /* RSV+FAT+DIR */
   \   0000015A   0x1883             ADDS     R3,R0,R2
   \   0000015C   0xEB03 0x1311      ADD      R3,R3,R1, LSR #+4
   2108            if (tsect < sysect) return FR_NO_FILESYSTEM;    /* (Invalid volume size) */
   \   00000160   0x429F             CMP      R7,R3
   \   00000162   0xD341             BCC.N    ??chk_mounted_14
   2109            nclst = (tsect - sysect) / fs->csize;       /* Number of clusters */
   \   00000164   0x1AFF             SUBS     R7,R7,R3
   \   00000166   0xF895 0xC002      LDRB     R12,[R5, #+2]
   \   0000016A   0xFBB7 0xFCFC      UDIV     R12,R7,R12
   2110            if (!nclst) return FR_NO_FILESYSTEM;        /* (Invalid volume size) */
   \   0000016E   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000172   0xD039             BEQ.N    ??chk_mounted_14
   2111            fmt = FS_FAT12;
   \   00000174   0x2701             MOVS     R7,#+1
   2112            if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   00000176   0xF640 0x7EF6      MOVW     LR,#+4086
   \   0000017A   0x45F4             CMP      R12,LR
   \   0000017C   0xBF28             IT       CS 
   \   0000017E   0x2702             MOVCS    R7,#+2
   2113            if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \   00000180   0xF64F 0x7EF6      MOVW     LR,#+65526
   \   00000184   0x45F4             CMP      R12,LR
   \   00000186   0xBF28             IT       CS 
   \   00000188   0x2703             MOVCS    R7,#+3
   2114          
   2115            /* Boundaries and Limits */
   2116            fs->n_fatent = nclst + 2;             /* Number of FAT entries */
   \   0000018A   0xF10C 0x0C02      ADD      R12,R12,#+2
   \   0000018E   0xF8C5 0xC01C      STR      R12,[R5, #+28]
   2117            fs->database = bsect + sysect;            /* Data start sector */
   \   00000192   0x199B             ADDS     R3,R3,R6
   \   00000194   0x62EB             STR      R3,[R5, #+44]
   2118            fs->fatbase = bsect + nrsv;             /* FAT start sector */
   \   00000196   0x1992             ADDS     R2,R2,R6
   \   00000198   0x626A             STR      R2,[R5, #+36]
   2119            if (fmt == FS_FAT32) {
   \   0000019A   0x2F03             CMP      R7,#+3
   \   0000019C   0xD111             BNE.N    ??chk_mounted_16
   2120              if (fs->n_rootdir) return FR_NO_FILESYSTEM;   /* (BPB_RootEntCnt must be 0) */
   \   0000019E   0xBB19             CBNZ.N   R1,??chk_mounted_14
   2121              fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
   \   000001A0   0xF895 0x0063      LDRB     R0,[R5, #+99]
   \   000001A4   0xF895 0x1062      LDRB     R1,[R5, #+98]
   \   000001A8   0x0409             LSLS     R1,R1,#+16
   \   000001AA   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000001AE   0xF895 0x1061      LDRB     R1,[R5, #+97]
   \   000001B2   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000001B6   0xF895 0x1060      LDRB     R1,[R5, #+96]
   \   000001BA   0x4308             ORRS     R0,R1,R0
   2122              szbfat = fs->n_fatent * 4;            /* (Required FAT size) */
   \   000001BC   0x69E9             LDR      R1,[R5, #+28]
   \   000001BE   0x0089             LSLS     R1,R1,#+2
   \   000001C0   0xE00B             B.N      ??chk_mounted_17
   2123            } else {
   2124              if (!fs->n_rootdir) return FR_NO_FILESYSTEM;  /* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_16:
   \   000001C2   0xB189             CBZ.N    R1,??chk_mounted_14
   2125              fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
   \   000001C4   0x1880             ADDS     R0,R0,R2
   2126              szbfat = (fmt == FS_FAT16) ?          /* (Required FAT size) */
   2127                fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   000001C6   0x69E9             LDR      R1,[R5, #+28]
   \   000001C8   0x2F02             CMP      R7,#+2
   \   000001CA   0xBF0F             ITEEE    EQ 
   \   000001CC   0x0049             LSLEQ    R1,R1,#+1
   \   000001CE   0xEB01 0x0241      ADDNE    R2,R1,R1, LSL #+1
   \   000001D2   0xF001 0x0101      ANDNE    R1,R1,#0x1
   \   000001D6   0xEB01 0x0152      ADDNE    R1,R1,R2, LSR #+1
   \                     ??chk_mounted_17:
   \   000001DA   0x62A8             STR      R0,[R5, #+40]
   2128            }
   2129            if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) /* (BPB_FATSz must not be less than required) */
   \   000001DC   0x6A28             LDR      R0,[R5, #+32]
   \   000001DE   0xF201 0x11FF      ADDW     R1,R1,#+511
   \   000001E2   0xEBB0 0x2F51      CMP      R0,R1, LSR #+9
   \   000001E6   0xD201             BCS.N    ??chk_mounted_18
   2130              return FR_NO_FILESYSTEM;
   \                     ??chk_mounted_14:
   \   000001E8   0x200D             MOVS     R0,#+13
   \   000001EA   0xBDF2             POP      {R1,R4-R7,PC}
   2131          
   2132          #if !_FS_READONLY
   2133            /* Initialize cluster allocation information */
   2134            fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_18:
   \   000001EC   0xF04F 0x30FF      MOV      R0,#-1
   \   000001F0   0x6128             STR      R0,[R5, #+16]
   2135            fs->last_clust = 0;
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0x60E8             STR      R0,[R5, #+12]
   2136          
   2137            /* Get fsinfo if available */
   2138            if (fmt == FS_FAT32) {
   \   000001F6   0x2F03             CMP      R7,#+3
   \   000001F8   0xD15C             BNE.N    ??chk_mounted_19
   2139              fs->fsi_flag = 0;
   \   000001FA   0x7168             STRB     R0,[R5, #+5]
   2140              fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   000001FC   0xF895 0x0065      LDRB     R0,[R5, #+101]
   \   00000200   0xF895 0x1064      LDRB     R1,[R5, #+100]
   \   00000204   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000208   0x1982             ADDS     R2,R0,R6
   \   0000020A   0x616A             STR      R2,[R5, #+20]
   2141              if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2142                LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2143                LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2144                LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   0000020C   0x2301             MOVS     R3,#+1
   \   0000020E   0xF105 0x0134      ADD      R1,R5,#+52
   \   00000212   0x7868             LDRB     R0,[R5, #+1]
   \   00000214   0x.... 0x....      BL       disk_read
   \   00000218   0x2800             CMP      R0,#+0
   \   0000021A   0xD14B             BNE.N    ??chk_mounted_19
   \   0000021C   0xF895 0x0233      LDRB     R0,[R5, #+563]
   \   00000220   0xF895 0x1232      LDRB     R1,[R5, #+562]
   \   00000224   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000228   0xF64A 0x2155      MOVW     R1,#+43605
   \   0000022C   0x4288             CMP      R0,R1
   \   0000022E   0xD141             BNE.N    ??chk_mounted_19
   \   00000230   0xF895 0x0037      LDRB     R0,[R5, #+55]
   \   00000234   0xF895 0x1036      LDRB     R1,[R5, #+54]
   \   00000238   0x0409             LSLS     R1,R1,#+16
   \   0000023A   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   0000023E   0xF895 0x1035      LDRB     R1,[R5, #+53]
   \   00000242   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000246   0xF895 0x1034      LDRB     R1,[R5, #+52]
   \   0000024A   0x4308             ORRS     R0,R1,R0
   \   0000024C   0x.... 0x....      LDR.W    R1,??DataTable10_2  ;; 0x41615252
   \   00000250   0x4288             CMP      R0,R1
   \   00000252   0xD12F             BNE.N    ??chk_mounted_19
   \   00000254   0xF895 0x021B      LDRB     R0,[R5, #+539]
   \   00000258   0xF895 0x121A      LDRB     R1,[R5, #+538]
   \   0000025C   0x0409             LSLS     R1,R1,#+16
   \   0000025E   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000262   0xF895 0x1219      LDRB     R1,[R5, #+537]
   \   00000266   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000026A   0xF895 0x1218      LDRB     R1,[R5, #+536]
   \   0000026E   0x4308             ORRS     R0,R1,R0
   \   00000270   0x.... 0x....      LDR.W    R1,??DataTable10_3  ;; 0x61417272
   \   00000274   0x4288             CMP      R0,R1
   \   00000276   0xD11D             BNE.N    ??chk_mounted_19
   2145                  fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   00000278   0xF895 0x0223      LDRB     R0,[R5, #+547]
   \   0000027C   0xF895 0x1222      LDRB     R1,[R5, #+546]
   \   00000280   0x0409             LSLS     R1,R1,#+16
   \   00000282   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000286   0xF895 0x1221      LDRB     R1,[R5, #+545]
   \   0000028A   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000028E   0xF895 0x1220      LDRB     R1,[R5, #+544]
   \   00000292   0x4308             ORRS     R0,R1,R0
   \   00000294   0x60E8             STR      R0,[R5, #+12]
   2146                  fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   00000296   0xF895 0x021F      LDRB     R0,[R5, #+543]
   \   0000029A   0xF895 0x121E      LDRB     R1,[R5, #+542]
   \   0000029E   0x0409             LSLS     R1,R1,#+16
   \   000002A0   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000002A4   0xF895 0x121D      LDRB     R1,[R5, #+541]
   \   000002A8   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000002AC   0xF895 0x121C      LDRB     R1,[R5, #+540]
   \   000002B0   0x4308             ORRS     R0,R1,R0
   \   000002B2   0x6128             STR      R0,[R5, #+16]
   2147              }
   2148            }
   2149          #endif
   2150            fs->fs_type = fmt;    /* FAT sub-type */
   \                     ??chk_mounted_19:
   \   000002B4   0x702F             STRB     R7,[R5, #+0]
   2151            fs->id = ++Fsid;    /* File system mount ID */
   \   000002B6   0x8860             LDRH     R0,[R4, #+2]
   \   000002B8   0x1C40             ADDS     R0,R0,#+1
   \   000002BA   0x8060             STRH     R0,[R4, #+2]
   \   000002BC   0x80E8             STRH     R0,[R5, #+6]
   2152            fs->winsect = 0;    /* Invalidate sector cache */
   \   000002BE   0x2000             MOVS     R0,#+0
   \   000002C0   0x6328             STR      R0,[R5, #+48]
   2153            fs->wflag = 0;
   \   000002C2   0x7128             STRB     R0,[R5, #+4]
   2154          #if _FS_RPATH
   2155            fs->cdir = 0;     /* Current directory (root dir) */
   \   000002C4   0x61A8             STR      R0,[R5, #+24]
   2156          #endif
   2157          #if _FS_SHARE       /* Clear file lock semaphores */
   2158            clear_lock(fs);
   2159          #endif
   2160          
   2161            return FR_OK;
   \   000002C6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2162          }
   2163          
   2164          
   2165          
   2166          
   2167          /*-----------------------------------------------------------------------*/
   2168          /* Check if the file/dir object is valid or not                          */
   2169          /*-----------------------------------------------------------------------*/
   2170          

   \                                 In section .text, align 2, keep-with-next
   2171          static
   2172          FRESULT validate (  /* FR_OK(0): The object is valid, !=0: Invalid */
   2173            FATFS *fs,    /* Pointer to the file system object */
   2174            WORD id     /* Member id of the target object to be checked */
   2175          )
   2176          {
   \                     validate:
   \   00000000   0xB580             PUSH     {R7,LR}
   2177            if (!fs || !fs->fs_type || fs->id != id)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xBF1C             ITT      NE 
   \   00000006   0x7802             LDRBNE   R2,[R0, #+0]
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD002             BEQ.N    ??validate_0
   \   0000000C   0x88C2             LDRH     R2,[R0, #+6]
   \   0000000E   0x428A             CMP      R2,R1
   \   00000010   0xD001             BEQ.N    ??validate_1
   2178              return FR_INVALID_OBJECT;
   \                     ??validate_0:
   \   00000012   0x2009             MOVS     R0,#+9
   \   00000014   0xBD02             POP      {R1,PC}
   2179          
   2180            ENTER_FF(fs);   /* Lock file system */
   2181          
   2182            if (disk_status(fs->drv) & STA_NOINIT)
   \                     ??validate_1:
   \   00000016   0x7840             LDRB     R0,[R0, #+1]
   \   00000018   0x.... 0x....      BL       disk_status
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD501             BPL.N    ??validate_2
   2183              return FR_NOT_READY;
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0xBD02             POP      {R1,PC}
   2184          
   2185            return FR_OK;
   \                     ??validate_2:
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
   2186          }
   2187          
   2188          
   2189          
   2190          
   2191          /*--------------------------------------------------------------------------
   2192          
   2193             Public Functions
   2194          
   2195          --------------------------------------------------------------------------*/
   2196          
   2197          
   2198          
   2199          /*-----------------------------------------------------------------------*/
   2200          /* Mount/Unmount a Logical Drive                                         */
   2201          /*-----------------------------------------------------------------------*/
   2202          

   \                                 In section .text, align 2, keep-with-next
   2203          FRESULT f_mount (
   2204            BYTE vol,   /* Logical drive number to be mounted/unmounted */
   2205            FATFS *fs   /* Pointer to new file system object (NULL for unmount)*/
   2206          )
   2207          {
   2208            FATFS *rfs;
   2209          
   2210          
   2211            if (vol >= _VOLUMES)    /* Check if the drive number is valid */
   \                     f_mount:
   \   00000000   0xB108             CBZ.N    R0,??f_mount_0
   2212              return FR_INVALID_DRIVE;
   \   00000002   0x200B             MOVS     R0,#+11
   \   00000004   0x4770             BX       LR
   2213            rfs = FatFs[vol];     /* Get current fs object */
   \                     ??f_mount_0:
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000000A   0x6842             LDR      R2,[R0, #+4]
   2214          
   2215            if (rfs) {
   \   0000000C   0xB10A             CBZ.N    R2,??f_mount_1
   2216          #if _FS_SHARE
   2217              clear_lock(rfs);
   2218          #endif
   2219          #if _FS_REENTRANT       /* Discard sync object of the current volume */
   2220              if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   2221          #endif
   2222              rfs->fs_type = 0;   /* Clear old fs object */
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x7013             STRB     R3,[R2, #+0]
   2223            }
   2224          
   2225            if (fs) {
   \                     ??f_mount_1:
   \   00000012   0xB109             CBZ.N    R1,??f_mount_2
   2226              fs->fs_type = 0;    /* Clear new fs object */
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x700A             STRB     R2,[R1, #+0]
   2227          #if _FS_REENTRANT       /* Create sync object for the new volume */
   2228              if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   2229          #endif
   2230            }
   2231            FatFs[vol] = fs;      /* Register new fs object */
   \                     ??f_mount_2:
   \   00000018   0x6041             STR      R1,[R0, #+4]
   2232          
   2233            return FR_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   2234          }
   2235          
   2236          
   2237          
   2238          
   2239          /*-----------------------------------------------------------------------*/
   2240          /* Open or Create a File                                                 */
   2241          /*-----------------------------------------------------------------------*/
   2242          

   \                                 In section .text, align 2, keep-with-next
   2243          FRESULT f_open (
   2244            FIL *fp,      /* Pointer to the blank file object */
   2245            const TCHAR *path,  /* Pointer to the file name */
   2246            BYTE mode     /* Access mode and file open mode flags */
   2247          )
   2248          {
   \                     f_open:
   \   00000000   0xE92D 0x43F2      PUSH     {R1,R4-R9,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x4604             MOV      R4,R0
   2249            FRESULT res;
   2250            DIR dj;
   2251            BYTE *dir;
   2252            DEF_NAMEBUF;
   2253          
   2254          
   2255            fp->fs = 0;     /* Clear file object */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x6020             STR      R0,[R4, #+0]
   2256          
   2257          #if !_FS_READONLY
   2258            mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   0000000C   0xF002 0x051F      AND      R5,R2,#0x1F
   2259            res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   \   00000010   0xF005 0x02FE      AND      R2,R5,#0xFE
   \   00000014   0x.... 0x....      BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_70:
   \   00000018   0x0006             MOVS     R6,R0
   2260          #else
   2261            mode &= FA_READ;
   2262            res = chk_mounted(&path, &dj.fs, 0);
   2263          #endif
   2264            INIT_BUF(dj);
   \   0000001A   0xA807             ADD      R0,SP,#+28
   \   0000001C   0x9006             STR      R0,[SP, #+24]
   2265            if (res == FR_OK)
   \   0000001E   0xD102             BNE.N    ??f_open_0
   2266              res = follow_path(&dj, path); /* Follow the file path */
   \   00000020   0x.... 0x....      BL       ??Subroutine22_0
   \                     ??CrossCallReturnLabel_74:
   \   00000024   0x4606             MOV      R6,R0
   2267            dir = dj.dir;
   \                     ??f_open_0:
   \   00000026   0x9F05             LDR      R7,[SP, #+20]
   2268          
   2269          #if !_FS_READONLY /* R/W configuration */
   2270            if (res == FR_OK) {
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xBF04             ITT      EQ 
   \   0000002C   0x2F00             CMPEQ    R7,#+0
   2271              if (!dir) /* Current dir itself */
   \   0000002E   0x2606             MOVEQ    R6,#+6
   2272                res = FR_INVALID_NAME;
   2273          #if _FS_SHARE
   2274              else
   2275                res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2276          #endif
   2277            }
   2278            /* Create or Open a file */
   2279            if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \   00000030   0x201C             MOVS     R0,#+28
   \   00000032   0x4205             TST      R5,R0
   \   00000034   0xD078             BEQ.N    ??f_open_1
   2280              DWORD dw, cl;
   2281          
   2282              if (res != FR_OK) {         /* No file, create new */
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD06E             BEQ.N    ??f_open_2
   2283                if (res == FR_NO_FILE)      /* There is no file to open, create a new entry */
   \   0000003A   0x2E04             CMP      R6,#+4
   \   0000003C   0xD103             BNE.N    ??f_open_3
   2284          #if _FS_SHARE
   2285                  res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   2286          #else
   2287                  res = dir_register(&dj);
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       dir_register
   \   00000044   0x4606             MOV      R6,R0
   2288          #endif
   2289                mode |= FA_CREATE_ALWAYS;   /* File is created */
   \                     ??f_open_3:
   \   00000046   0xF045 0x0508      ORR      R5,R5,#0x8
   2290                dir = dj.dir;         /* New entry */
   \   0000004A   0x9F05             LDR      R7,[SP, #+20]
   2291              }
   2292              else {                /* Any object is already existing */
   2293                if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {  /* Cannot overwrite it (R/O or DIR) */
   2294                  res = FR_DENIED;
   2295                } else {
   2296                  if (mode & FA_CREATE_NEW) /* Cannot create as new file */
   2297                    res = FR_EXIST;
   2298                }
   2299              }
   2300              if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {  /* Truncate it if overwrite mode */
   \   0000004C   0xBBC6             CBNZ.N   R6,??f_open_4
   \                     ??f_open_5:
   \   0000004E   0x0728             LSLS     R0,R5,#+28
   \   00000050   0xD53B             BPL.N    ??f_open_6
   2301                dw = get_fattime();         /* Created time */
   \   00000052   0x.... 0x....      BL       get_fattime
   \   00000056   0x4601             MOV      R1,R0
   2302                ST_DWORD(dir+DIR_CrtTime, dw);
   \   00000058   0x73B9             STRB     R1,[R7, #+14]
   \   0000005A   0x0400             LSLS     R0,R0,#+16
   \   0000005C   0x0E00             LSRS     R0,R0,#+24
   \   0000005E   0x73F8             STRB     R0,[R7, #+15]
   \   00000060   0x0C08             LSRS     R0,R1,#+16
   \   00000062   0x7438             STRB     R0,[R7, #+16]
   \   00000064   0x0E08             LSRS     R0,R1,#+24
   \   00000066   0x7478             STRB     R0,[R7, #+17]
   2303                dir[DIR_Attr] = 0;          /* Reset attribute */
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x72F8             STRB     R0,[R7, #+11]
   2304                ST_DWORD(dir+DIR_FileSize, 0);    /* size = 0 */
   \   0000006C   0x7738             STRB     R0,[R7, #+28]
   \   0000006E   0x7778             STRB     R0,[R7, #+29]
   \   00000070   0x77B8             STRB     R0,[R7, #+30]
   \   00000072   0x77F8             STRB     R0,[R7, #+31]
   2305                cl = LD_CLUST(dir);         /* Get start cluster */
   \   00000074   0x7D78             LDRB     R0,[R7, #+21]
   \   00000076   0x7D39             LDRB     R1,[R7, #+20]
   \   00000078   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   0000007C   0x7EF9             LDRB     R1,[R7, #+27]
   \   0000007E   0x7EBA             LDRB     R2,[R7, #+26]
   \   00000080   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000084   0xEA41 0x4900      ORR      R9,R1,R0, LSL #+16
   2306                ST_CLUST(dir, 0);         /* cluster = 0 */
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x76B8             STRB     R0,[R7, #+26]
   \   0000008C   0x76F8             STRB     R0,[R7, #+27]
   \   0000008E   0x7538             STRB     R0,[R7, #+20]
   \   00000090   0x7578             STRB     R0,[R7, #+21]
   2307                dj.fs->wflag = 1;
   \   00000092   0x9800             LDR      R0,[SP, #+0]
   \   00000094   0x2101             MOVS     R1,#+1
   \   00000096   0x7101             STRB     R1,[R0, #+4]
   2308                if (cl) {             /* Remove the cluster chain if exist */
   \   00000098   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000009C   0xD011             BEQ.N    ??f_open_7
   2309                  dw = dj.fs->winsect;
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0xF8D0 0x8030      LDR      R8,[R0, #+48]
   2310                  res = remove_chain(dj.fs, cl);
   \   000000A4   0x4649             MOV      R1,R9
   \   000000A6   0x.... 0x....      BL       remove_chain
   \   000000AA   0x0006             MOVS     R6,R0
   2311                  if (res == FR_OK) {
   \   000000AC   0xD108             BNE.N    ??f_open_4
   2312                    dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0xF1A9 0x0101      SUB      R1,R9,#+1
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
   2313                    res = move_window(dj.fs, dw);
   \   000000B6   0x4641             MOV      R1,R8
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0x.... 0x....      BL       move_window
   \   000000BE   0x4606             MOV      R6,R0
   2314                  }
   2315                }
   2316              }
   2317            }
   2318            else {  /* Open an existing file */
   2319              if (res == FR_OK) {           /* Follow succeeded */
   2320                if (dir[DIR_Attr] & AM_DIR) {   /* It is a directory */
   2321                  res = FR_NO_FILE;
   2322                } else {
   2323                  if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   2324                    res = FR_DENIED;
   2325                }
   2326              }
   2327            }
   2328            if (res == FR_OK) {
   \                     ??f_open_4:
   \   000000C0   0xBB36             CBNZ.N   R6,??f_open_8
   2329              if (mode & FA_CREATE_ALWAYS)      /* Set file change flag if created or overwritten */
   \                     ??f_open_7:
   \   000000C2   0x0728             LSLS     R0,R5,#+28
   \   000000C4   0xBF48             IT       MI 
   \   000000C6   0xF045 0x0520      ORRMI    R5,R5,#0x20
   2330                mode |= FA__WRITTEN;
   2331              fp->dir_sect = dj.fs->winsect;      /* Pointer to the directory entry */
   \                     ??f_open_6:
   \   000000CA   0x9800             LDR      R0,[SP, #+0]
   \   000000CC   0x6B00             LDR      R0,[R0, #+48]
   \   000000CE   0x61E0             STR      R0,[R4, #+28]
   2332              fp->dir_ptr = dir;
   \   000000D0   0x6227             STR      R7,[R4, #+32]
   2333          #if _FS_SHARE
   2334              fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   2335              if (!fp->lockid) res = FR_INT_ERR;
   2336          #endif
   2337            }
   2338          
   2339          #else       /* R/O configuration */
   2340            if (res == FR_OK) {         /* Follow succeeded */
   2341              if (!dir) {           /* Current dir itself */
   2342                res = FR_INVALID_NAME;
   2343              } else {
   2344                if (dir[DIR_Attr] & AM_DIR) /* It is a directory */
   2345                  res = FR_NO_FILE;
   2346              }
   2347            }
   2348          #endif
   2349            FREE_BUF();
   2350          
   2351            if (res == FR_OK) {
   2352              fp->flag = mode;          /* File access mode */
   \   000000D2   0x71A5             STRB     R5,[R4, #+6]
   2353              fp->sclust = LD_CLUST(dir);     /* File start cluster */
   \   000000D4   0x7D78             LDRB     R0,[R7, #+21]
   \   000000D6   0x7D39             LDRB     R1,[R7, #+20]
   \   000000D8   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000000DC   0x7EF9             LDRB     R1,[R7, #+27]
   \   000000DE   0x7EBA             LDRB     R2,[R7, #+26]
   \   000000E0   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   000000E4   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   000000E8   0x6120             STR      R0,[R4, #+16]
   2354              fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
   \   000000EA   0x7FF8             LDRB     R0,[R7, #+31]
   \   000000EC   0x7FB9             LDRB     R1,[R7, #+30]
   \   000000EE   0x0409             LSLS     R1,R1,#+16
   \   000000F0   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   000000F4   0x7F79             LDRB     R1,[R7, #+29]
   \   000000F6   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   000000FA   0x7F39             LDRB     R1,[R7, #+28]
   \   000000FC   0x4308             ORRS     R0,R1,R0
   \   000000FE   0x60E0             STR      R0,[R4, #+12]
   2355              fp->fptr = 0;           /* File pointer */
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x60A0             STR      R0,[R4, #+8]
   2356              fp->dsect = 0;
   \   00000104   0x61A0             STR      R0,[R4, #+24]
   2357          #if _USE_FASTSEEK
   2358              fp->cltbl = 0;            /* Normal seek mode */
   2359          #endif
   2360              fp->fs = dj.fs; fp->id = dj.fs->id; /* Validate file object */
   \   00000106   0x9800             LDR      R0,[SP, #+0]
   \   00000108   0x6020             STR      R0,[R4, #+0]
   \   0000010A   0x9800             LDR      R0,[SP, #+0]
   \   0000010C   0x88C0             LDRH     R0,[R0, #+6]
   \   0000010E   0x80A0             STRH     R0,[R4, #+4]
   2361            }
   2362          
   2363            LEAVE_FF(dj.fs, res);
   \                     ??f_open_8:
   \   00000110   0x4630             MOV      R0,R6
   \   00000112   0xB00B             ADD      SP,SP,#+44
   \   00000114   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   \                     ??f_open_2:
   \   00000118   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000011A   0x2111             MOVS     R1,#+17
   \   0000011C   0x4208             TST      R0,R1
   \   0000011E   0xD10E             BNE.N    ??f_open_9
   \   00000120   0x0768             LSLS     R0,R5,#+29
   \   00000122   0xD594             BPL.N    ??f_open_5
   \   00000124   0x2608             MOVS     R6,#+8
   \   00000126   0xE7F3             B.N      ??f_open_8
   \                     ??f_open_1:
   \   00000128   0x2E00             CMP      R6,#+0
   \   0000012A   0xD1C9             BNE.N    ??f_open_4
   \   0000012C   0x7AF8             LDRB     R0,[R7, #+11]
   \   0000012E   0x06C1             LSLS     R1,R0,#+27
   \   00000130   0xBF48             IT       MI 
   \   00000132   0x2604             MOVMI    R6,#+4
   \   00000134   0xD4EC             BMI.N    ??f_open_8
   \   00000136   0x07A9             LSLS     R1,R5,#+30
   \   00000138   0xD5C3             BPL.N    ??f_open_7
   \   0000013A   0x07C0             LSLS     R0,R0,#+31
   \   0000013C   0xD5C1             BPL.N    ??f_open_7
   \                     ??f_open_9:
   \   0000013E   0x2607             MOVS     R6,#+7
   \   00000140   0xE7E6             B.N      ??f_open_8
   2364          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22:
   \   00000000   0xA807             ADD      R0,SP,#+28
   \   00000002   0x9006             STR      R0,[SP, #+24]
   \                     ??Subroutine22_0:
   \   00000004   0x990A             LDR      R1,[SP, #+40]
   \                     ??Subroutine22_1:
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x....             B.N      follow_path

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21:
   \   00000000   0xA900             ADD      R1,SP,#+0
   \   00000002   0xA80A             ADD      R0,SP,#+40
   \   00000004   0x.... 0x....      B.W      chk_mounted
   2365          
   2366          
   2367          
   2368          
   2369          /*-----------------------------------------------------------------------*/
   2370          /* Read File                                                             */
   2371          /*-----------------------------------------------------------------------*/
   2372          

   \                                 In section .text, align 2, keep-with-next
   2373          FRESULT f_read (
   2374            FIL *fp,    /* Pointer to the file object */
   2375            void *buff,   /* Pointer to data buffer */
   2376            UINT btr,   /* Number of bytes to read */
   2377            UINT *br    /* Pointer to number of bytes read */
   2378          )
   2379          {
   \                     f_read:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x.... 0x....      BL       ?Subroutine14
   2380            FRESULT res;
   2381            DWORD clst, sect, remain;
   2382            UINT rcnt, cc;
   2383            BYTE csect, *rbuff = buff;
   2384          
   2385          
   2386            *br = 0;  /* Initialize byte counter */
   2387          
   2388            res = validate(fp->fs, fp->id);       /* Check validity */
   2389            if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \                     ??CrossCallReturnLabel_53:
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD146             BNE.N    ??f_read_0
   2390            if (fp->flag & FA__ERROR)         /* Aborted file? */
   \   0000000C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000000E   0x0601             LSLS     R1,R0,#+24
   \   00000010   0xD442             BMI.N    ??f_read_1
   2391              LEAVE_FF(fp->fs, FR_INT_ERR);
   2392            if (!(fp->flag & FA_READ))          /* Check access mode */
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xBF58             IT       PL 
   \   00000016   0x2007             MOVPL    R0,#+7
   2393              LEAVE_FF(fp->fs, FR_DENIED);
   \   00000018   0xD57C             BPL.N    ??f_read_2
   2394            remain = fp->fsize - fp->fptr;
   \   0000001A   0x68E8             LDR      R0,[R5, #+12]
   \   0000001C   0x68A9             LDR      R1,[R5, #+8]
   \   0000001E   0x1A40             SUBS     R0,R0,R1
   2395            if (btr > remain) btr = (UINT)remain;   /* Truncate btr by remaining bytes */
   \   00000020   0x42B0             CMP      R0,R6
   \   00000022   0xD818             BHI.N    ??f_read_3
   \   00000024   0x4606             MOV      R6,R0
   \   00000026   0xE016             B.N      ??f_read_3
   2396          
   2397            for ( ;  btr;               /* Repeat until all data read */
   2398              rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2399              if ((fp->fptr % SS(fp->fs)) == 0) {   /* On the sector boundary? */
   2400                csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));  /* Sector offset in the cluster */
   2401                if (!csect) {           /* On the cluster boundary? */
   2402                  if (fp->fptr == 0) {      /* On the top of the file? */
   2403                    clst = fp->sclust;      /* Follow from the origin */
   2404                  } else {            /* Middle or end of the file */
   2405          #if _USE_FASTSEEK
   2406                    if (fp->cltbl)
   2407                      clst = clmt_clust(fp, fp->fptr);  /* Get cluster# from the CLMT */
   2408                    else
   2409          #endif
   2410                      clst = get_fat(fp->fs, fp->clust);  /* Follow cluster chain on the FAT */
   2411                  }
   2412                  if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   2413                  if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2414                  fp->clust = clst;       /* Update current cluster */
   2415                }
   2416                sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
   2417                if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2418                sect += csect;
   2419                cc = btr / SS(fp->fs);        /* When remaining bytes >= sector size, */
   2420                if (cc) {             /* Read maximum contiguous sectors directly */
   2421                  if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
   2422                    cc = fp->fs->csize - csect;
   2423                  if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
   2424                    ABORT(fp->fs, FR_DISK_ERR);
   2425          #if !_FS_READONLY && _FS_MINIMIZE <= 2      /* Replace one of the read sectors with cached data if it contains a dirty sector */
   2426          #if _FS_TINY
   2427                  if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2428                    mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2429          #else
   2430                  if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2431                    mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2432          #endif
   2433          #endif
   2434                  rcnt = SS(fp->fs) * cc;     /* Number of bytes transferred */
   2435                  continue;
   2436                }
   2437          #if !_FS_TINY
   2438                if (fp->dsect != sect) {      /* Load data sector if not in cache */
   2439          #if !_FS_READONLY
   2440                  if (fp->flag & FA__DIRTY) {   /* Write-back dirty sector cache */
   2441                    if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2442                      ABORT(fp->fs, FR_DISK_ERR);
   2443                    fp->flag &= ~FA__DIRTY;
   2444                  }
   2445          #endif
   2446                  if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK) /* Fill sector cache */
   2447                    ABORT(fp->fs, FR_DISK_ERR);
   2448                }
   2449          #endif
   2450                fp->dsect = sect;
   \                     ??f_read_4:
   \   00000028   0xF8C5 0x9018      STR      R9,[R5, #+24]
   2451              }
   2452              rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));  /* Get partial sector data from sector buffer */
   \                     ??f_read_5:
   \   0000002C   0x.... 0x....      BL       ?Subroutine24
   2453              if (rcnt > btr) rcnt = btr;
   \                     ??CrossCallReturnLabel_80:
   \   00000030   0xBF88             IT       HI 
   \   00000032   0x460C             MOVHI    R4,R1
   2454          #if _FS_TINY
   2455              if (move_window(fp->fs, fp->dsect))   /* Move sector window */
   2456                ABORT(fp->fs, FR_DISK_ERR);
   2457              mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
   2458          #else
   2459              mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
   \   00000034   0x4622             MOV      R2,R4
   \   00000036   0x1940             ADDS     R0,R0,R5
   \   00000038   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000003C   0x4640             MOV      R0,R8
   \   0000003E   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_6:
   \   00000042   0x44A0             ADD      R8,R4,R8
   \   00000044   0x68A8             LDR      R0,[R5, #+8]
   \   00000046   0x1820             ADDS     R0,R4,R0
   \   00000048   0x60A8             STR      R0,[R5, #+8]
   \   0000004A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000004E   0x1820             ADDS     R0,R4,R0
   \   00000050   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000054   0x1B36             SUBS     R6,R6,R4
   \                     ??f_read_3:
   \   00000056   0x2E00             CMP      R6,#+0
   \   00000058   0xD05B             BEQ.N    ??f_read_7
   \   0000005A   0x68A9             LDR      R1,[R5, #+8]
   \   0000005C   0x05C8             LSLS     R0,R1,#+23
   \   0000005E   0xD1E5             BNE.N    ??f_read_5
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0x7883             LDRB     R3,[R0, #+2]
   \   00000064   0x1E5B             SUBS     R3,R3,#+1
   \   00000066   0xEA13 0x2251      ANDS     R2,R3,R1, LSR #+9
   \   0000006A   0xB2D4             UXTB     R4,R2
   \   0000006C   0xB95C             CBNZ.N   R4,??f_read_8
   \   0000006E   0x2900             CMP      R1,#+0
   \   00000070   0xBF0E             ITEE     EQ 
   \   00000072   0x6928             LDREQ    R0,[R5, #+16]
   \   00000074   0x6969             LDRNE    R1,[R5, #+20]
   \   00000076   0x.... 0x....      BLNE     get_fat
   \   0000007A   0x2802             CMP      R0,#+2
   \   0000007C   0xD308             BCC.N    ??f_read_9
   \   0000007E   0xF110 0x0F01      CMN      R0,#+1
   \   00000082   0xD040             BEQ.N    ??f_read_10
   \   00000084   0x6168             STR      R0,[R5, #+20]
   \                     ??f_read_8:
   \   00000086   0x6969             LDR      R1,[R5, #+20]
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0x.... 0x....      BL       clust2sect
   \   0000008E   0xB928             CBNZ.N   R0,??f_read_11
   \                     ??f_read_9:
   \   00000090   0x79A8             LDRB     R0,[R5, #+6]
   \   00000092   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000096   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_read_1:
   \   00000098   0x2002             MOVS     R0,#+2
   \                     ??f_read_0:
   \   0000009A   0xE03B             B.N      ??f_read_2
   \                     ??f_read_11:
   \   0000009C   0xEB04 0x0900      ADD      R9,R4,R0
   \   000000A0   0x0A77             LSRS     R7,R6,#+9
   \   000000A2   0xD01E             BEQ.N    ??f_read_12
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0x7881             LDRB     R1,[R0, #+2]
   \   000000A8   0x193A             ADDS     R2,R7,R4
   \   000000AA   0x4291             CMP      R1,R2
   \   000000AC   0xBF38             IT       CC 
   \   000000AE   0x1B0F             SUBCC    R7,R1,R4
   \   000000B0   0xB2FB             UXTB     R3,R7
   \   000000B2   0x464A             MOV      R2,R9
   \   000000B4   0x4641             MOV      R1,R8
   \   000000B6   0x7840             LDRB     R0,[R0, #+1]
   \   000000B8   0x.... 0x....      BL       disk_read
   \   000000BC   0xBB18             CBNZ.N   R0,??f_read_10
   \   000000BE   0x79A8             LDRB     R0,[R5, #+6]
   \   000000C0   0x0640             LSLS     R0,R0,#+25
   \   000000C2   0xD50C             BPL.N    ??f_read_13
   \   000000C4   0x69A8             LDR      R0,[R5, #+24]
   \   000000C6   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000CA   0x42B8             CMP      R0,R7
   \   000000CC   0xD207             BCS.N    ??f_read_13
   \   000000CE   0xF44F 0x7200      MOV      R2,#+512
   \   000000D2   0xF105 0x0124      ADD      R1,R5,#+36
   \   000000D6   0xEB08 0x2040      ADD      R0,R8,R0, LSL #+9
   \   000000DA   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_13:
   \   000000DE   0x027C             LSLS     R4,R7,#+9
   \   000000E0   0xE7AF             B.N      ??f_read_6
   \                     ??f_read_12:
   \   000000E2   0x69AA             LDR      R2,[R5, #+24]
   \   000000E4   0x454A             CMP      R2,R9
   \   000000E6   0xD09F             BEQ.N    ??f_read_4
   \   000000E8   0x79A8             LDRB     R0,[R5, #+6]
   \   000000EA   0x0640             LSLS     R0,R0,#+25
   \   000000EC   0xD507             BPL.N    ??f_read_14
   \   000000EE   0x2301             MOVS     R3,#+1
   \   000000F0   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_21:
   \   000000F4   0xB938             CBNZ.N   R0,??f_read_10
   \   000000F6   0x79A8             LDRB     R0,[R5, #+6]
   \   000000F8   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   000000FC   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_read_14:
   \   000000FE   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD090             BEQ.N    ??f_read_4
   \                     ??f_read_10:
   \   00000106   0x79A8             LDRB     R0,[R5, #+6]
   \   00000108   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000010C   0x71A8             STRB     R0,[R5, #+6]
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xE000             B.N      ??f_read_2
   2460          #endif
   2461            }
   2462          
   2463            LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_7:
   \   00000112   0x2000             MOVS     R0,#+0
   \                     ??f_read_2:
   \   00000114   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2464          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24:
   \   00000000   0x68A8             LDR      R0,[R5, #+8]
   \   00000002   0x05C0             LSLS     R0,R0,#+23
   \   00000004   0x0DC0             LSRS     R0,R0,#+23
   \   00000006   0xF5C0 0x7100      RSB      R1,R0,#+512
   \   0000000A   0x4634             MOV      R4,R6
   \   0000000C   0x428E             CMP      R6,R1
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14:
   \   00000000   0x4605             MOV      R5,R0
   \   00000002   0x4616             MOV      R6,R2
   \   00000004   0x469A             MOV      R10,R3
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   0000000E   0x88A9             LDRH     R1,[R5, #+4]
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x....             B.N      validate

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x464A             MOV      R2,R9
   \   00000004   0xF105 0x0124      ADD      R1,R5,#+36
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x7840             LDRB     R0,[R0, #+1]
   \   0000000C   0x.... 0x....      B.W      disk_read

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0xF105 0x0124      ADD      R1,R5,#+36
   \   00000004   0x6828             LDR      R0,[R5, #+0]
   \                     ??Subroutine6_0:
   \   00000006   0x7840             LDRB     R0,[R0, #+1]
   \   00000008   0x.... 0x....      B.W      disk_write
   2465          
   2466          
   2467          
   2468          
   2469          #if !_FS_READONLY
   2470          /*-----------------------------------------------------------------------*/
   2471          /* Write File                                                            */
   2472          /*-----------------------------------------------------------------------*/
   2473          

   \                                 In section .text, align 2, keep-with-next
   2474          FRESULT f_write (
   2475            FIL *fp,      /* Pointer to the file object */
   2476            const void *buff, /* Pointer to the data to be written */
   2477            UINT btw,     /* Number of bytes to write */
   2478            UINT *bw      /* Pointer to number of bytes written */
   2479          )
   2480          {
   \                     f_write:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x.... 0x....      BL       ?Subroutine14
   2481            FRESULT res;
   2482            DWORD clst, sect;
   2483            UINT wcnt, cc;
   2484            const BYTE *wbuff = buff;
   2485            BYTE csect;
   2486          
   2487          
   2488            *bw = 0;  /* Initialize byte counter */
   2489          
   2490            res = validate(fp->fs, fp->id);     /* Check validity */
   2491            if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \                     ??CrossCallReturnLabel_52:
   \   00000008   0xB9B8             CBNZ.N   R0,??f_write_0
   2492            if (fp->flag & FA__ERROR)       /* Aborted file? */
   \   0000000A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000000C   0x0601             LSLS     R1,R0,#+24
   \   0000000E   0xD501             BPL.N    ??f_write_1
   2493              LEAVE_FF(fp->fs, FR_INT_ERR);
   \                     ??f_write_2:
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xE012             B.N      ??f_write_0
   2494            if (!(fp->flag & FA_WRITE))       /* Check access mode */
   \                     ??f_write_1:
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xBF58             IT       PL 
   \   00000018   0x2007             MOVPL    R0,#+7
   2495              LEAVE_FF(fp->fs, FR_DENIED);
   \   0000001A   0xD50E             BPL.N    ??f_write_0
   2496            if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;  /* File size cannot reach 4GB */
   \   0000001C   0x68E8             LDR      R0,[R5, #+12]
   \   0000001E   0x1831             ADDS     R1,R6,R0
   \   00000020   0x4281             CMP      R1,R0
   \   00000022   0xD226             BCS.N    ??f_write_3
   2497          
   2498            for ( ;  btw;             /* Repeat until all data written */
   2499              wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2500              if ((fp->fptr % SS(fp->fs)) == 0) { /* On the sector boundary? */
   2501                csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));  /* Sector offset in the cluster */
   2502                if (!csect) {         /* On the cluster boundary? */
   2503                  if (fp->fptr == 0) {    /* On the top of the file? */
   2504                    clst = fp->sclust;    /* Follow from the origin */
   2505                    if (clst == 0)      /* When no cluster is allocated, */
   2506                      fp->sclust = clst = create_chain(fp->fs, 0);  /* Create a new cluster chain */
   2507                  } else {          /* Middle or end of the file */
   2508          #if _USE_FASTSEEK
   2509                    if (fp->cltbl)
   2510                      clst = clmt_clust(fp, fp->fptr);  /* Get cluster# from the CLMT */
   2511                    else
   2512          #endif
   2513                      clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
   2514                  }
   2515                  if (clst == 0) break;   /* Could not allocate a new cluster (disk full) */
   2516                  if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2517                  if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2518                  fp->clust = clst;     /* Update current cluster */
   2519                }
   2520          #if _FS_TINY
   2521                if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0)) /* Write-back sector cache */
   2522                  ABORT(fp->fs, FR_DISK_ERR);
   2523          #else
   2524                if (fp->flag & FA__DIRTY) {   /* Write-back sector cache */
   2525                  if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2526                    ABORT(fp->fs, FR_DISK_ERR);
   2527                  fp->flag &= ~FA__DIRTY;
   2528                }
   2529          #endif
   2530                sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
   2531                if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2532                sect += csect;
   2533                cc = btw / SS(fp->fs);      /* When remaining bytes >= sector size, */
   2534                if (cc) {           /* Write maximum contiguous sectors directly */
   2535                  if (csect + cc > fp->fs->csize) /* Clip at cluster boundary */
   2536                    cc = fp->fs->csize - csect;
   2537                  if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   2538                    ABORT(fp->fs, FR_DISK_ERR);
   2539          #if _FS_TINY
   2540                  if (fp->fs->winsect - sect < cc) {  /* Refill sector cache if it gets invalidated by the direct write */
   2541                    mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2542                    fp->fs->wflag = 0;
   2543                  }
   2544          #else
   2545                  if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2546                    mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2547                    fp->flag &= ~FA__DIRTY;
   2548                  }
   2549          #endif
   2550                  wcnt = SS(fp->fs) * cc;   /* Number of bytes transferred */
   2551                  continue;
   2552                }
   2553          #if _FS_TINY
   2554                if (fp->fptr >= fp->fsize) {  /* Avoid silly cache filling at growing edge */
   2555                  if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   2556                  fp->fs->winsect = sect;
   2557                }
   2558          #else
   2559                if (fp->dsect != sect) {    /* Fill sector cache with file data */
   2560                  if (fp->fptr < fp->fsize &&
   2561                    disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2562                      ABORT(fp->fs, FR_DISK_ERR);
   2563                }
   2564          #endif
   2565                fp->dsect = sect;
   2566              }
   2567              wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   2568              if (wcnt > btw) wcnt = btw;
   2569          #if _FS_TINY
   2570              if (move_window(fp->fs, fp->dsect)) /* Move sector window */
   2571                ABORT(fp->fs, FR_DISK_ERR);
   2572              mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
   2573              fp->fs->wflag = 1;
   2574          #else
   2575              mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
   2576              fp->flag |= FA__DIRTY;
   2577          #endif
   2578            }
   2579          
   2580            if (fp->fptr > fp->fsize) fp->fsize = fp->fptr; /* Update file size if needed */
   \                     ??f_write_4:
   \   00000024   0x68E8             LDR      R0,[R5, #+12]
   \   00000026   0x68A9             LDR      R1,[R5, #+8]
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xBF38             IT       CC 
   \   0000002C   0x4608             MOVCC    R0,R1
   \   0000002E   0x60E8             STR      R0,[R5, #+12]
   2581            fp->flag |= FA__WRITTEN;            /* Set file change flag */
   \   00000030   0x79A8             LDRB     R0,[R5, #+6]
   \   00000032   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000036   0x71A8             STRB     R0,[R5, #+6]
   2582          
   2583            LEAVE_FF(fp->fs, FR_OK);
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??f_write_0:
   \   0000003A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??f_write_5:
   \   0000003E   0xF8C5 0x9018      STR      R9,[R5, #+24]
   \                     ??f_write_6:
   \   00000042   0x.... 0x....      BL       ?Subroutine24
   \                     ??CrossCallReturnLabel_81:
   \   00000046   0xBF88             IT       HI 
   \   00000048   0x460C             MOVHI    R4,R1
   \   0000004A   0x4622             MOV      R2,R4
   \   0000004C   0x4641             MOV      R1,R8
   \   0000004E   0x1940             ADDS     R0,R0,R5
   \   00000050   0x3024             ADDS     R0,R0,#+36
   \   00000052   0x.... 0x....      BL       mem_cpy
   \   00000056   0x79A8             LDRB     R0,[R5, #+6]
   \   00000058   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000005C   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_7:
   \   0000005E   0x44A0             ADD      R8,R4,R8
   \   00000060   0x68A8             LDR      R0,[R5, #+8]
   \   00000062   0x1820             ADDS     R0,R4,R0
   \   00000064   0x60A8             STR      R0,[R5, #+8]
   \   00000066   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000006A   0x1820             ADDS     R0,R4,R0
   \   0000006C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000070   0x1B36             SUBS     R6,R6,R4
   \                     ??f_write_3:
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD0D6             BEQ.N    ??f_write_4
   \   00000076   0x68A9             LDR      R1,[R5, #+8]
   \   00000078   0x05C8             LSLS     R0,R1,#+23
   \   0000007A   0xD1E2             BNE.N    ??f_write_6
   \   0000007C   0x6828             LDR      R0,[R5, #+0]
   \   0000007E   0x7883             LDRB     R3,[R0, #+2]
   \   00000080   0x1E5B             SUBS     R3,R3,#+1
   \   00000082   0xEA13 0x2251      ANDS     R2,R3,R1, LSR #+9
   \   00000086   0xB2D4             UXTB     R4,R2
   \   00000088   0xB99C             CBNZ.N   R4,??f_write_8
   \   0000008A   0xB931             CBNZ.N   R1,??f_write_9
   \   0000008C   0x6929             LDR      R1,[R5, #+16]
   \   0000008E   0xB941             CBNZ.N   R1,??f_write_10
   \   00000090   0x.... 0x....      BL       create_chain
   \   00000094   0x4601             MOV      R1,R0
   \   00000096   0x6129             STR      R1,[R5, #+16]
   \   00000098   0xE003             B.N      ??f_write_10
   \                     ??f_write_9:
   \   0000009A   0x6969             LDR      R1,[R5, #+20]
   \   0000009C   0x.... 0x....      BL       create_chain
   \   000000A0   0x4601             MOV      R1,R0
   \                     ??f_write_10:
   \   000000A2   0x2900             CMP      R1,#+0
   \   000000A4   0xD0BE             BEQ.N    ??f_write_4
   \   000000A6   0x2901             CMP      R1,#+1
   \   000000A8   0xD015             BEQ.N    ??f_write_11
   \   000000AA   0xF111 0x0F01      CMN      R1,#+1
   \   000000AE   0xD045             BEQ.N    ??f_write_12
   \   000000B0   0x6169             STR      R1,[R5, #+20]
   \                     ??f_write_8:
   \   000000B2   0x79A8             LDRB     R0,[R5, #+6]
   \   000000B4   0x0640             LSLS     R0,R0,#+25
   \   000000B6   0xD509             BPL.N    ??f_write_13
   \   000000B8   0x2301             MOVS     R3,#+1
   \   000000BA   0x69AA             LDR      R2,[R5, #+24]
   \   000000BC   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_20:
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD13B             BNE.N    ??f_write_12
   \   000000C4   0x79A8             LDRB     R0,[R5, #+6]
   \   000000C6   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   000000CA   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_13:
   \   000000CC   0x6969             LDR      R1,[R5, #+20]
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0x.... 0x....      BL       clust2sect
   \   000000D4   0xB920             CBNZ.N   R0,??f_write_14
   \                     ??f_write_11:
   \   000000D6   0x79A8             LDRB     R0,[R5, #+6]
   \   000000D8   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000DC   0x71A8             STRB     R0,[R5, #+6]
   \   000000DE   0xE797             B.N      ??f_write_2
   \                     ??f_write_14:
   \   000000E0   0xEB04 0x0900      ADD      R9,R4,R0
   \   000000E4   0x0A77             LSRS     R7,R6,#+9
   \   000000E6   0xD01E             BEQ.N    ??f_write_15
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x7881             LDRB     R1,[R0, #+2]
   \   000000EC   0x193A             ADDS     R2,R7,R4
   \   000000EE   0x4291             CMP      R1,R2
   \   000000F0   0xBF38             IT       CC 
   \   000000F2   0x1B0F             SUBCC    R7,R1,R4
   \   000000F4   0xB2FB             UXTB     R3,R7
   \   000000F6   0x464A             MOV      R2,R9
   \   000000F8   0x4641             MOV      R1,R8
   \   000000FA   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_19:
   \   000000FE   0xB9E8             CBNZ.N   R0,??f_write_12
   \   00000100   0x69A8             LDR      R0,[R5, #+24]
   \   00000102   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000106   0x42B8             CMP      R0,R7
   \   00000108   0xD20B             BCS.N    ??f_write_16
   \   0000010A   0xF44F 0x7200      MOV      R2,#+512
   \   0000010E   0xEB08 0x2140      ADD      R1,R8,R0, LSL #+9
   \   00000112   0xF105 0x0024      ADD      R0,R5,#+36
   \   00000116   0x.... 0x....      BL       mem_cpy
   \   0000011A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011C   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000120   0x71A8             STRB     R0,[R5, #+6]
   \                     ??f_write_16:
   \   00000122   0x027C             LSLS     R4,R7,#+9
   \   00000124   0xE79B             B.N      ??f_write_7
   \                     ??f_write_15:
   \   00000126   0x69A8             LDR      R0,[R5, #+24]
   \   00000128   0x4548             CMP      R0,R9
   \                     ??f_write_17:
   \   0000012A   0xD088             BEQ.N    ??f_write_5
   \   0000012C   0x68A8             LDR      R0,[R5, #+8]
   \   0000012E   0x68E9             LDR      R1,[R5, #+12]
   \   00000130   0x4288             CMP      R0,R1
   \   00000132   0xD284             BCS.N    ??f_write_5
   \   00000134   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD0F6             BEQ.N    ??f_write_17
   \                     ??f_write_12:
   \   0000013C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000013E   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000142   0x71A8             STRB     R0,[R5, #+6]
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0xE778             B.N      ??f_write_0
   2584          }
   2585          
   2586          
   2587          
   2588          
   2589          /*-----------------------------------------------------------------------*/
   2590          /* Synchronize the File Object                                           */
   2591          /*-----------------------------------------------------------------------*/
   2592          

   \                                 In section .text, align 2, keep-with-next
   2593          FRESULT f_sync (
   2594            FIL *fp   /* Pointer to the file object */
   2595          )
   2596          {
   \                     f_sync:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2597            FRESULT res;
   2598            DWORD tim;
   2599            BYTE *dir;
   2600          
   2601          
   2602            res = validate(fp->fs, fp->id);   /* Check validity of the object */
   \   00000004   0x88A1             LDRH     R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       validate
   2603            if (res == FR_OK) {
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD14A             BNE.N    ??f_sync_0
   2604              if (fp->flag & FA__WRITTEN) { /* Has the file been written? */
   \   00000010   0x79A1             LDRB     R1,[R4, #+6]
   \   00000012   0x068A             LSLS     R2,R1,#+26
   \   00000014   0xD547             BPL.N    ??f_sync_0
   2605          #if !_FS_TINY /* Write-back dirty buffer */
   2606                if (fp->flag & FA__DIRTY) {
   \   00000016   0x0648             LSLS     R0,R1,#+25
   \   00000018   0xD50D             BPL.N    ??f_sync_1
   2607                  if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   0000001A   0x2301             MOVS     R3,#+1
   \   0000001C   0x69A2             LDR      R2,[R4, #+24]
   \   0000001E   0xF104 0x0124      ADD      R1,R4,#+36
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_18:
   \   00000028   0xB108             CBZ.N    R0,??f_sync_2
   2608                    LEAVE_FF(fp->fs, FR_DISK_ERR);
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}
   2609                  fp->flag &= ~FA__DIRTY;
   \                     ??f_sync_2:
   \   0000002E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000030   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   00000034   0x71A0             STRB     R0,[R4, #+6]
   2610                }
   2611          #endif
   2612                /* Update the directory entry */
   2613                res = move_window(fp->fs, fp->dir_sect);
   \                     ??f_sync_1:
   \   00000036   0x69E1             LDR      R1,[R4, #+28]
   \   00000038   0x.... 0x....      BL       ??Subroutine12_0
   2614                if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_42:
   \   0000003C   0xBB98             CBNZ.N   R0,??f_sync_0
   2615                  dir = fp->dir_ptr;
   \   0000003E   0x6A25             LDR      R5,[R4, #+32]
   2616                  dir[DIR_Attr] |= AM_ARC;          /* Set archive bit */
   \   00000040   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000042   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000046   0x72E8             STRB     R0,[R5, #+11]
   2617                  ST_DWORD(dir+DIR_FileSize, fp->fsize);    /* Update file size */
   \   00000048   0x68E0             LDR      R0,[R4, #+12]
   \   0000004A   0x7728             STRB     R0,[R5, #+28]
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0x0400             LSLS     R0,R0,#+16
   \   00000050   0x0E00             LSRS     R0,R0,#+24
   \   00000052   0x7768             STRB     R0,[R5, #+29]
   \   00000054   0x68E0             LDR      R0,[R4, #+12]
   \   00000056   0x0C00             LSRS     R0,R0,#+16
   \   00000058   0x77A8             STRB     R0,[R5, #+30]
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0x0E00             LSRS     R0,R0,#+24
   \   0000005E   0x77E8             STRB     R0,[R5, #+31]
   2618                  ST_CLUST(dir, fp->sclust);          /* Update start cluster */
   \   00000060   0x6920             LDR      R0,[R4, #+16]
   \   00000062   0x76A8             STRB     R0,[R5, #+26]
   \   00000064   0x6920             LDR      R0,[R4, #+16]
   \   00000066   0x0400             LSLS     R0,R0,#+16
   \   00000068   0x0E00             LSRS     R0,R0,#+24
   \   0000006A   0x76E8             STRB     R0,[R5, #+27]
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0x0C00             LSRS     R0,R0,#+16
   \   00000070   0x7528             STRB     R0,[R5, #+20]
   \   00000072   0x6920             LDR      R0,[R4, #+16]
   \   00000074   0x0C00             LSRS     R0,R0,#+16
   \   00000076   0x0A00             LSRS     R0,R0,#+8
   \   00000078   0x7568             STRB     R0,[R5, #+21]
   2619                  tim = get_fattime();            /* Update updated time */
   \   0000007A   0x.... 0x....      BL       get_fattime
   2620                  ST_DWORD(dir+DIR_WrtTime, tim);
   \   0000007E   0x75A8             STRB     R0,[R5, #+22]
   \   00000080   0x0401             LSLS     R1,R0,#+16
   \   00000082   0x0E09             LSRS     R1,R1,#+24
   \   00000084   0x75E9             STRB     R1,[R5, #+23]
   \   00000086   0x0C01             LSRS     R1,R0,#+16
   \   00000088   0x7629             STRB     R1,[R5, #+24]
   \   0000008A   0x0E00             LSRS     R0,R0,#+24
   \   0000008C   0x7668             STRB     R0,[R5, #+25]
   2621                  fp->flag &= ~FA__WRITTEN;
   \   0000008E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000090   0xF000 0x00DF      AND      R0,R0,#0xDF
   \   00000094   0x71A0             STRB     R0,[R4, #+6]
   2622                  fp->fs->wflag = 1;
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x7101             STRB     R1,[R0, #+4]
   2623                  res = sync(fp->fs);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   000000A2   0x.... 0x....      B.W      sync
   2624                }
   2625              }
   2626            }
   2627          
   2628            LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0:
   \   000000A6   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2629          }
   2630          
   2631          #endif /* !_FS_READONLY */
   2632          
   2633          
   2634          
   2635          
   2636          /*-----------------------------------------------------------------------*/
   2637          /* Close File                                                            */
   2638          /*-----------------------------------------------------------------------*/
   2639          

   \                                 In section .text, align 2, keep-with-next
   2640          FRESULT f_close (
   2641            FIL *fp   /* Pointer to the file object to be closed */
   2642          )
   2643          {
   \                     f_close:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2644            FRESULT res;
   2645          
   2646          #if _FS_READONLY
   2647            FATFS *fs = fp->fs;
   2648            res = validate(fs, fp->id);
   2649            if (res == FR_OK) fp->fs = 0; /* Discard file object */
   2650            LEAVE_FF(fs, res);
   2651          
   2652          #else
   2653            res = f_sync(fp);   /* Flush cached data */
   \   00000004   0x.... 0x....      BL       f_sync
   2654          #if _FS_SHARE
   2655            if (res == FR_OK) {   /* Decrement open counter */
   2656          #if _FS_REENTRANT
   2657              res = validate(fp->fs, fp->id);
   2658              if (res == FR_OK) {
   2659                res = dec_lock(fp->lockid);
   2660                unlock_fs(fp->fs, FR_OK);
   2661              }
   2662          #else
   2663              res = dec_lock(fp->lockid);
   2664          #endif
   2665            }
   2666          #endif
   2667            if (res == FR_OK) fp->fs = 0; /* Discard file object */
   \   00000008   0xB908             CBNZ.N   R0,??f_close_0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6021             STR      R1,[R4, #+0]
   2668            return res;
   \                     ??f_close_0:
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
   2669          #endif
   2670          }
   2671          
   2672          
   2673          
   2674          
   2675          /*-----------------------------------------------------------------------*/
   2676          /* Current Drive/Directory Handlings                                     */
   2677          /*-----------------------------------------------------------------------*/
   2678          
   2679          #if _FS_RPATH >= 1
   2680          

   \                                 In section .text, align 2, keep-with-next
   2681          FRESULT f_chdrive (
   2682            BYTE drv    /* Drive number */
   2683          )
   2684          {
   2685            if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \                     f_chdrive:
   \   00000000   0xB108             CBZ.N    R0,??f_chdrive_0
   \   00000002   0x200B             MOVS     R0,#+11
   \   00000004   0x4770             BX       LR
   2686          
   2687            CurrVol = drv;
   \                     ??f_chdrive_0:
   \   00000006   0x....             LDR.N    R0,??DataTable10_1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   2688          
   2689            return FR_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   2690          }
   2691          
   2692          
   2693          

   \                                 In section .text, align 2, keep-with-next
   2694          FRESULT f_chdir (
   2695            const TCHAR *path /* Pointer to the directory path */
   2696          )
   2697          {
   \                     f_chdir:
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   2698            FRESULT res;
   2699            DIR dj;
   2700            DEF_NAMEBUF;
   2701          
   2702          
   2703            res = chk_mounted(&path, &dj.fs, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x.... 0x....      BL       ?Subroutine21
   2704            if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_69:
   \   0000000A   0xB9D8             CBNZ.N   R0,??f_chdir_0
   2705              INIT_BUF(dj);
   \   0000000C   0x.... 0x....      BL       ?Subroutine22
   2706              res = follow_path(&dj, path);   /* Follow the path */
   2707              FREE_BUF();
   2708              if (res == FR_OK) {         /* Follow completed */
   \                     ??CrossCallReturnLabel_76:
   \   00000010   0xB9A8             CBNZ.N   R0,??f_chdir_1
   2709                if (!dj.dir) {
   \   00000012   0x9905             LDR      R1,[SP, #+20]
   \   00000014   0xB919             CBNZ.N   R1,??f_chdir_2
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x9A02             LDR      R2,[SP, #+8]
   \   0000001A   0x618A             STR      R2,[R1, #+24]
   \   0000001C   0xE012             B.N      ??f_chdir_0
   2710                  dj.fs->cdir = dj.sclust;  /* Start directory itself */
   2711                } else {
   2712                  if (dj.dir[DIR_Attr] & AM_DIR)  /* Reached to the directory */
   \                     ??f_chdir_2:
   \   0000001E   0x7ACA             LDRB     R2,[R1, #+11]
   \   00000020   0x06D2             LSLS     R2,R2,#+27
   \   00000022   0xD50E             BPL.N    ??f_chdir_3
   2713                    dj.fs->cdir = LD_CLUST(dj.dir);
   \   00000024   0x7D4A             LDRB     R2,[R1, #+21]
   \   00000026   0x7D0B             LDRB     R3,[R1, #+20]
   \   00000028   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \   0000002C   0x7ECB             LDRB     R3,[R1, #+27]
   \   0000002E   0x7E89             LDRB     R1,[R1, #+26]
   \   00000030   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000034   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000038   0x9A00             LDR      R2,[SP, #+0]
   \   0000003A   0x6191             STR      R1,[R2, #+24]
   \   0000003C   0xE002             B.N      ??f_chdir_0
   2714                  else
   2715                    res = FR_NO_PATH;   /* Reached but a file */
   2716                }
   2717              }
   2718              if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_1:
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0xD100             BNE.N    ??f_chdir_0
   \                     ??f_chdir_3:
   \   00000042   0x2005             MOVS     R0,#+5
   2719            }
   2720          
   2721            LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0:
   \   00000044   0xB00B             ADD      SP,SP,#+44
   \   00000046   0xBD00             POP      {PC}             ;; return
   2722          }
   2723          
   2724          
   2725          #if _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   2726          FRESULT f_getcwd (
   2727            TCHAR *path,  /* Pointer to the directory path */
   2728            UINT sz_path  /* Size of path */
   2729          )
   2730          {
   \                     f_getcwd:
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   \   00000004   0x460C             MOV      R4,R1
   2731            FRESULT res;
   2732            DIR dj;
   2733            UINT i, n;
   2734            DWORD ccl;
   2735            TCHAR *tp;
   2736            FILINFO fno;
   2737            DEF_NAMEBUF;
   2738          
   2739          
   2740            *path = 0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   2741            res = chk_mounted((const TCHAR**)&path, &dj.fs, 0); /* Get current volume */
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0xA810             ADD      R0,SP,#+64
   \   00000010   0x.... 0x....      BL       chk_mounted
   \   00000014   0x0006             MOVS     R6,R0
   2742            if (res == FR_OK) {
   \   00000016   0xD16C             BNE.N    ??f_getcwd_0
   2743              INIT_BUF(dj);
   \   00000018   0xA807             ADD      R0,SP,#+28
   \   0000001A   0x9006             STR      R0,[SP, #+24]
   2744              i = sz_path;    /* Bottom of buffer (dir stack base) */
   \   0000001C   0x4625             MOV      R5,R4
   2745              dj.sclust = dj.fs->cdir;      /* Start to follow upper dir from current dir */
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x6980             LDR      R0,[R0, #+24]
   \   00000022   0x9002             STR      R0,[SP, #+8]
   \   00000024   0xE00B             B.N      ??f_getcwd_1
   2746              while ((ccl = dj.sclust) != 0) {  /* Repeat while current dir is a sub-dir */
   2747                res = dir_sdi(&dj, 1);      /* Get parent dir */
   2748                if (res != FR_OK) break;
   2749                res = dir_read(&dj);
   2750                if (res != FR_OK) break;
   2751                dj.sclust = LD_CLUST(dj.dir); /* Goto parent dir */
   2752                res = dir_sdi(&dj, 0);
   2753                if (res != FR_OK) break;
   2754                do {              /* Find the entry links to the child dir */
   2755                  res = dir_read(&dj);
   2756                  if (res != FR_OK) break;
   2757                  if (ccl == LD_CLUST(dj.dir)) break; /* Found the entry */
   2758                  res = dir_next(&dj, 0);
   2759                } while (res == FR_OK);
   2760                if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2761                if (res != FR_OK) break;
   2762          #if _USE_LFN
   2763                fno.lfname = path;
   2764                fno.lfsize = i;
   2765          #endif
   2766                get_fileinfo(&dj, &fno);    /* Get the dir name and push it to the buffer */
   2767                tp = fno.fname;
   2768                if (_USE_LFN && *path) tp = path;
   2769                for (n = 0; tp[n]; n++) ;
   2770                if (i < n + 3) {
   2771                  res = FR_NOT_ENOUGH_CORE; break;
   2772                }
   2773                while (n) path[--i] = tp[--n];
   \                     ??f_getcwd_2:
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0xA90A             ADD      R1,SP,#+40
   \   0000002A   0x1841             ADDS     R1,R0,R1
   \   0000002C   0x7A49             LDRB     R1,[R1, #+9]
   \   0000002E   0x9A10             LDR      R2,[SP, #+64]
   \   00000030   0x54A9             STRB     R1,[R5, R2]
   \                     ??f_getcwd_3:
   \   00000032   0x1E6D             SUBS     R5,R5,#+1
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1F6             BNE.N    ??f_getcwd_2
   2774                path[--i] = '/';
   \   00000038   0x9810             LDR      R0,[SP, #+64]
   \   0000003A   0x212F             MOVS     R1,#+47
   \   0000003C   0x5429             STRB     R1,[R5, R0]
   \                     ??f_getcwd_1:
   \   0000003E   0x9F02             LDR      R7,[SP, #+8]
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD03A             BEQ.N    ??f_getcwd_4
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x.... 0x....      BL       dir_sdi
   \   0000004C   0x0006             MOVS     R6,R0
   \   0000004E   0xD134             BNE.N    ??f_getcwd_4
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0x.... 0x....      BL       dir_read
   \   00000056   0x0006             MOVS     R6,R0
   \   00000058   0xD12F             BNE.N    ??f_getcwd_4
   \   0000005A   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_66:
   \   0000005E   0x9002             STR      R0,[SP, #+8]
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x.... 0x....      BL       dir_sdi
   \   00000068   0x0006             MOVS     R6,R0
   \   0000006A   0xD126             BNE.N    ??f_getcwd_4
   \                     ??f_getcwd_5:
   \   0000006C   0xA800             ADD      R0,SP,#+0
   \   0000006E   0x.... 0x....      BL       dir_read
   \   00000072   0x0006             MOVS     R6,R0
   \   00000074   0xD109             BNE.N    ??f_getcwd_6
   \   00000076   0x.... 0x....      BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_67:
   \   0000007A   0x4287             CMP      R7,R0
   \   0000007C   0xD00A             BEQ.N    ??f_getcwd_7
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xA800             ADD      R0,SP,#+0
   \   00000082   0x.... 0x....      BL       dir_next
   \   00000086   0x0006             MOVS     R6,R0
   \   00000088   0xD0F0             BEQ.N    ??f_getcwd_5
   \                     ??f_getcwd_6:
   \   0000008A   0x2E04             CMP      R6,#+4
   \   0000008C   0xD101             BNE.N    ??f_getcwd_8
   \   0000008E   0x2602             MOVS     R6,#+2
   \   00000090   0xE011             B.N      ??f_getcwd_9
   \                     ??f_getcwd_8:
   \   00000092   0xB996             CBNZ.N   R6,??f_getcwd_4
   \                     ??f_getcwd_7:
   \   00000094   0xA90A             ADD      R1,SP,#+40
   \   00000096   0xA800             ADD      R0,SP,#+0
   \   00000098   0x.... 0x....      BL       get_fileinfo
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE000             B.N      ??f_getcwd_10
   \                     ??f_getcwd_11:
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \                     ??f_getcwd_10:
   \   000000A2   0xA90A             ADD      R1,SP,#+40
   \   000000A4   0x1841             ADDS     R1,R0,R1
   \   000000A6   0xF991 0x1009      LDRSB    R1,[R1, #+9]
   \   000000AA   0x2900             CMP      R1,#+0
   \   000000AC   0xD1F8             BNE.N    ??f_getcwd_11
   \   000000AE   0x1CC1             ADDS     R1,R0,#+3
   \   000000B0   0x428D             CMP      R5,R1
   \   000000B2   0xD2BE             BCS.N    ??f_getcwd_3
   \   000000B4   0x2611             MOVS     R6,#+17
   \                     ??f_getcwd_9:
   \   000000B6   0x9810             LDR      R0,[SP, #+64]
   \   000000B8   0xE019             B.N      ??f_getcwd_12
   2775              }
   2776              tp = path;
   \                     ??f_getcwd_4:
   \   000000BA   0x9810             LDR      R0,[SP, #+64]
   2777              if (res == FR_OK) {
   \   000000BC   0x0031             MOVS     R1,R6
   \   000000BE   0xD116             BNE.N    ??f_getcwd_12
   2778                *tp++ = '0' + CurrVol;      /* Put drive number */
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000C4   0xF991 0x1000      LDRSB    R1,[R1, #+0]
   \   000000C8   0x3130             ADDS     R1,R1,#+48
   \   000000CA   0xF800 0x1B01      STRB     R1,[R0], #+1
   2779                *tp++ = ':';
   \   000000CE   0x213A             MOVS     R1,#+58
   \   000000D0   0xF800 0x1B01      STRB     R1,[R0], #+1
   2780                if (i == sz_path) {       /* Root-dir */
   \   000000D4   0x42A5             CMP      R5,R4
   \   000000D6   0xD103             BNE.N    ??f_getcwd_13
   2781                  *tp++ = '/';
   \   000000D8   0x212F             MOVS     R1,#+47
   \   000000DA   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   000000DE   0xE006             B.N      ??f_getcwd_12
   2782                } else {            /* Sub-dir */
   2783                  do    /* Add stacked path str */
   2784                    *tp++ = path[i++];
   \                     ??f_getcwd_13:
   \   000000E0   0x9910             LDR      R1,[SP, #+64]
   \   000000E2   0x5C69             LDRB     R1,[R5, R1]
   \   000000E4   0xF800 0x1B01      STRB     R1,[R0], #+1
   \   000000E8   0x1C6D             ADDS     R5,R5,#+1
   2785                  while (i < sz_path);
   \   000000EA   0x42A5             CMP      R5,R4
   \   000000EC   0xD3F8             BCC.N    ??f_getcwd_13
   2786                }
   2787              }
   2788              *tp = 0;
   \                     ??f_getcwd_12:
   \   000000EE   0x2100             MOVS     R1,#+0
   \   000000F0   0x7001             STRB     R1,[R0, #+0]
   2789              FREE_BUF();
   2790            }
   2791          
   2792            LEAVE_FF(dj.fs, res);
   \                     ??f_getcwd_0:
   \   000000F2   0x4630             MOV      R0,R6
   \   000000F4   0xB011             ADD      SP,SP,#+68
   \   000000F6   0xBDF0             POP      {R4-R7,PC}       ;; return
   2793          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20:
   \   00000000   0x9805             LDR      R0,[SP, #+20]
   \   00000002   0x7D41             LDRB     R1,[R0, #+21]
   \   00000004   0x7D02             LDRB     R2,[R0, #+20]
   \   00000006   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   0000000A   0x7EC2             LDRB     R2,[R0, #+27]
   \   0000000C   0x7E80             LDRB     R0,[R0, #+26]
   \   0000000E   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \   00000012   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000016   0x4770             BX       LR
   2794          #endif /* _FS_RPATH >= 2 */
   2795          #endif /* _FS_RPATH >= 1 */
   2796          
   2797          
   2798          
   2799          #if _FS_MINIMIZE <= 2
   2800          /*-----------------------------------------------------------------------*/
   2801          /* Seek File R/W Pointer                                                 */
   2802          /*-----------------------------------------------------------------------*/
   2803          

   \                                 In section .text, align 2, keep-with-next
   2804          FRESULT f_lseek (
   2805            FIL *fp,    /* Pointer to the file object */
   2806            DWORD ofs   /* File pointer from top of file */
   2807          )
   2808          {
   \                     f_lseek:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x.... 0x....      BL       ?Subroutine3
   2809            FRESULT res;
   2810          
   2811          
   2812            res = validate(fp->fs, fp->id);   /* Check validity of the object */
   \                     ??CrossCallReturnLabel_8:
   \   00000008   0xEA5F 0x0800      MOVS     R8,R0
   2813            if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   0000000C   0xF040 0x8089      BNE.W    ??f_lseek_0
   2814            if (fp->flag & FA__ERROR)     /* Check abort flag */
   \   00000010   0x79A0             LDRB     R0,[R4, #+6]
   \   00000012   0x0601             LSLS     R1,R0,#+24
   \   00000014   0xD454             BMI.N    ??f_lseek_1
   2815              LEAVE_FF(fp->fs, FR_INT_ERR);
   2816          
   2817          #if _USE_FASTSEEK
   2818            if (fp->cltbl) {  /* Fast seek */
   2819              DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2820          
   2821              if (ofs == CREATE_LINKMAP) {  /* Create CLMT */
   2822                tbl = fp->cltbl;
   2823                tlen = *tbl++; ulen = 2;  /* Given table size and required table size */
   2824                cl = fp->sclust;      /* Top of the chain */
   2825                if (cl) {
   2826                  do {
   2827                    /* Get a fragment */
   2828                    tcl = cl; ncl = 0; ulen += 2; /* Top, length and used items */
   2829                    do {
   2830                      pcl = cl; ncl++;
   2831                      cl = get_fat(fp->fs, cl);
   2832                      if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   2833                      if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2834                    } while (cl == pcl + 1);
   2835                    if (ulen <= tlen) {   /* Store the length and top of the fragment */
   2836                      *tbl++ = ncl; *tbl++ = tcl;
   2837                    }
   2838                  } while (cl < fp->fs->n_fatent);  /* Repeat until end of chain */
   2839                }
   2840                *fp->cltbl = ulen;  /* Number of items used */
   2841                if (ulen <= tlen)
   2842                  *tbl = 0;   /* Terminate table */
   2843                else
   2844                  res = FR_NOT_ENOUGH_CORE; /* Given table size is smaller than required */
   2845          
   2846              } else {            /* Fast seek */
   2847                if (ofs > fp->fsize)    /* Clip offset at the file size */
   2848                  ofs = fp->fsize;
   2849                fp->fptr = ofs;       /* Set file pointer */
   2850                if (ofs) {
   2851                  fp->clust = clmt_clust(fp, ofs - 1);
   2852                  dsc = clust2sect(fp->fs, fp->clust);
   2853                  if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   2854                  dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   2855                  if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {  /* Refill sector cache if needed */
   2856          #if !_FS_TINY
   2857          #if !_FS_READONLY
   2858                    if (fp->flag & FA__DIRTY) {   /* Write-back dirty sector cache */
   2859                      if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2860                        ABORT(fp->fs, FR_DISK_ERR);
   2861                      fp->flag &= ~FA__DIRTY;
   2862                    }
   2863          #endif
   2864                    if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)  /* Load current sector */
   2865                      ABORT(fp->fs, FR_DISK_ERR);
   2866          #endif
   2867                    fp->dsect = dsc;
   2868                  }
   2869                }
   2870              }
   2871            } else
   2872          #endif
   2873          
   2874            /* Normal Seek */
   2875            {
   2876              DWORD clst, bcs, nsect, ifptr;
   2877          
   2878              if (ofs > fp->fsize         /* In read-only mode, clip offset with the file size */
   2879          #if !_FS_READONLY
   2880                 && !(fp->flag & FA_WRITE)
   2881          #endif
   2882                ) ofs = fp->fsize;
   \   00000016   0x68E1             LDR      R1,[R4, #+12]
   \   00000018   0x42A9             CMP      R1,R5
   \   0000001A   0xD202             BCS.N    ??f_lseek_2
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xBF58             IT       PL 
   \   00000020   0x460D             MOVPL    R5,R1
   2883          
   2884              ifptr = fp->fptr;
   \                     ??f_lseek_2:
   \   00000022   0x68A1             LDR      R1,[R4, #+8]
   2885              fp->fptr = nsect = 0;
   \   00000024   0x2700             MOVS     R7,#+0
   \   00000026   0x60A7             STR      R7,[R4, #+8]
   2886              if (ofs) {
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD04D             BEQ.N    ??f_lseek_3
   2887                bcs = (DWORD)fp->fs->csize * SS(fp->fs);  /* Cluster size (byte) */
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x7882             LDRB     R2,[R0, #+2]
   \   00000030   0x0256             LSLS     R6,R2,#+9
   2888                if (ifptr > 0 &&
   2889                  (ofs - 1) / bcs >= (ifptr - 1) / bcs) { /* When seek to same or following cluster, */
   \   00000032   0xB171             CBZ.N    R1,??f_lseek_4
   \   00000034   0x1E49             SUBS     R1,R1,#+1
   \   00000036   0xFBB1 0xF2F6      UDIV     R2,R1,R6
   \   0000003A   0x1E6B             SUBS     R3,R5,#+1
   \   0000003C   0xFBB3 0xF3F6      UDIV     R3,R3,R6
   \   00000040   0x4293             CMP      R3,R2
   \   00000042   0xD306             BCC.N    ??f_lseek_4
   2890                  fp->fptr = (ifptr - 1) & ~(bcs - 1);  /* start from the current cluster */
   \   00000044   0x1E70             SUBS     R0,R6,#+1
   \   00000046   0xEA21 0x0000      BIC      R0,R1,R0
   \   0000004A   0x60A0             STR      R0,[R4, #+8]
   2891                  ofs -= fp->fptr;
   \   0000004C   0x1A2D             SUBS     R5,R5,R0
   2892                  clst = fp->clust;
   \   0000004E   0x6961             LDR      R1,[R4, #+20]
   \   00000050   0xE00B             B.N      ??f_lseek_5
   2893                } else {                  /* When seek to back cluster, */
   2894                  clst = fp->sclust;            /* start from the first cluster */
   \                     ??f_lseek_4:
   \   00000052   0x6921             LDR      R1,[R4, #+16]
   2895          #if !_FS_READONLY
   2896                  if (clst == 0) {            /* If no cluster chain, create a new chain */
   \   00000054   0xB941             CBNZ.N   R1,??f_lseek_6
   2897                    clst = create_chain(fp->fs, 0);
   \   00000056   0x.... 0x....      BL       create_chain
   \   0000005A   0x4601             MOV      R1,R0
   2898                    if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   0000005C   0x2901             CMP      R1,#+1
   \   0000005E   0xD02B             BEQ.N    ??f_lseek_7
   2899                    if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \   00000060   0xF111 0x0F01      CMN      R1,#+1
   \   00000064   0xD04D             BEQ.N    ??f_lseek_8
   2900                    fp->sclust = clst;
   \   00000066   0x6121             STR      R1,[R4, #+16]
   2901                  }
   2902          #endif
   2903                  fp->clust = clst;
   \                     ??f_lseek_6:
   \   00000068   0x6161             STR      R1,[R4, #+20]
   2904                }
   2905                if (clst != 0) {
   \                     ??f_lseek_5:
   \   0000006A   0xB989             CBNZ.N   R1,??f_lseek_9
   \   0000006C   0xE02C             B.N      ??f_lseek_3
   2906                  while (ofs > bcs) {           /* Cluster following loop */
   2907          #if !_FS_READONLY
   2908                    if (fp->flag & FA_WRITE) {      /* Check if in write mode or not */
   2909                      clst = create_chain(fp->fs, clst);  /* Force stretch if in write mode */
   2910                      if (clst == 0) {        /* When disk gets full, clip file size */
   2911                        ofs = bcs; break;
   2912                      }
   2913                    } else
   2914          #endif
   2915                      clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
   \                     ??f_lseek_10:
   \   0000006E   0x.... 0x....      BL       get_fat
   \   00000072   0x4601             MOV      R1,R0
   2916                    if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_11:
   \   00000074   0xF111 0x0F01      CMN      R1,#+1
   \   00000078   0xD043             BEQ.N    ??f_lseek_8
   2917                    if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   \   0000007A   0x2902             CMP      R1,#+2
   \   0000007C   0xD31C             BCC.N    ??f_lseek_7
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x69C0             LDR      R0,[R0, #+28]
   \   00000082   0x4281             CMP      R1,R0
   \   00000084   0xD218             BCS.N    ??f_lseek_7
   2918                    fp->clust = clst;
   \   00000086   0x6161             STR      R1,[R4, #+20]
   2919                    fp->fptr += bcs;
   \   00000088   0x68A0             LDR      R0,[R4, #+8]
   \   0000008A   0x1830             ADDS     R0,R6,R0
   \   0000008C   0x60A0             STR      R0,[R4, #+8]
   2920                    ofs -= bcs;
   \   0000008E   0x1BAD             SUBS     R5,R5,R6
   \                     ??f_lseek_9:
   \   00000090   0x42AE             CMP      R6,R5
   \   00000092   0xD208             BCS.N    ??f_lseek_12
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x79A2             LDRB     R2,[R4, #+6]
   \   00000098   0x0792             LSLS     R2,R2,#+30
   \   0000009A   0xD5E8             BPL.N    ??f_lseek_10
   \   0000009C   0x.... 0x....      BL       create_chain
   \   000000A0   0x0001             MOVS     R1,R0
   \   000000A2   0xD1E7             BNE.N    ??f_lseek_11
   \   000000A4   0x4635             MOV      R5,R6
   2921                  }
   2922                  fp->fptr += ofs;
   \                     ??f_lseek_12:
   \   000000A6   0x68A0             LDR      R0,[R4, #+8]
   \   000000A8   0x1828             ADDS     R0,R5,R0
   \   000000AA   0x60A0             STR      R0,[R4, #+8]
   2923                  if (ofs % SS(fp->fs)) {
   \   000000AC   0x05E8             LSLS     R0,R5,#+23
   \   000000AE   0xD00B             BEQ.N    ??f_lseek_3
   2924                    nsect = clust2sect(fp->fs, clst); /* Current sector */
   \   000000B0   0x.... 0x....      BL       ??Subroutine18_0
   \                     ??CrossCallReturnLabel_61:
   \   000000B4   0x0007             MOVS     R7,R0
   2925                    if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   000000B6   0xD105             BNE.N    ??f_lseek_13
   \                     ??f_lseek_7:
   \   000000B8   0x79A0             LDRB     R0,[R4, #+6]
   \   000000BA   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000BE   0x71A0             STRB     R0,[R4, #+6]
   \                     ??f_lseek_1:
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0xE02F             B.N      ??f_lseek_14
   2926                    nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_13:
   \   000000C4   0xEB00 0x2755      ADD      R7,R0,R5, LSR #+9
   2927                  }
   2928                }
   2929              }
   2930              if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {  /* Fill sector cache if needed */
   \                     ??f_lseek_3:
   \   000000C8   0x68A0             LDR      R0,[R4, #+8]
   \   000000CA   0x05C0             LSLS     R0,R0,#+23
   \   000000CC   0xBF1C             ITT      NE 
   \   000000CE   0x69A2             LDRNE    R2,[R4, #+24]
   \   000000D0   0x4297             CMPNE    R7,R2
   \   000000D2   0xD01D             BEQ.N    ??f_lseek_15
   2931          #if !_FS_TINY
   2932          #if !_FS_READONLY
   2933                if (fp->flag & FA__DIRTY) {     /* Write-back dirty sector cache */
   \   000000D4   0x79A0             LDRB     R0,[R4, #+6]
   \   000000D6   0x0640             LSLS     R0,R0,#+25
   \   000000D8   0xD50A             BPL.N    ??f_lseek_16
   2934                  if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   \   000000DA   0x2301             MOVS     R3,#+1
   \   000000DC   0xF104 0x0124      ADD      R1,R4,#+36
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_17:
   \   000000E6   0xB960             CBNZ.N   R0,??f_lseek_8
   2935                    ABORT(fp->fs, FR_DISK_ERR);
   2936                  fp->flag &= ~FA__DIRTY;
   \   000000E8   0x79A0             LDRB     R0,[R4, #+6]
   \   000000EA   0xF000 0x00BF      AND      R0,R0,#0xBF
   \   000000EE   0x71A0             STRB     R0,[R4, #+6]
   2937                }
   2938          #endif
   2939                if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)  /* Fill sector cache */
   \                     ??f_lseek_16:
   \   000000F0   0x2301             MOVS     R3,#+1
   \   000000F2   0x463A             MOV      R2,R7
   \   000000F4   0xF104 0x0124      ADD      R1,R4,#+36
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x7840             LDRB     R0,[R0, #+1]
   \   000000FC   0x.... 0x....      BL       disk_read
   \   00000100   0xB128             CBZ.N    R0,??f_lseek_17
   2940                  ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_8:
   \   00000102   0x79A0             LDRB     R0,[R4, #+6]
   \   00000104   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000108   0x71A0             STRB     R0,[R4, #+6]
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xE00A             B.N      ??f_lseek_14
   2941          #endif
   2942                fp->dsect = nsect;
   \                     ??f_lseek_17:
   \   0000010E   0x61A7             STR      R7,[R4, #+24]
   2943              }
   2944          #if !_FS_READONLY
   2945              if (fp->fptr > fp->fsize) {     /* Set file change flag if the file size is extended */
   \                     ??f_lseek_15:
   \   00000110   0x68A0             LDR      R0,[R4, #+8]
   \   00000112   0x68E1             LDR      R1,[R4, #+12]
   \   00000114   0x4281             CMP      R1,R0
   \   00000116   0xD204             BCS.N    ??f_lseek_0
   2946                fp->fsize = fp->fptr;
   \   00000118   0x60E0             STR      R0,[R4, #+12]
   2947                fp->flag |= FA__WRITTEN;
   \   0000011A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000011C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000120   0x71A0             STRB     R0,[R4, #+6]
   2948              }
   2949          #endif
   2950            }
   2951          
   2952            LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_0:
   \   00000122   0x4640             MOV      R0,R8
   \                     ??f_lseek_14:
   \   00000124   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2953          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x460D             MOV      R5,R1
   \   00000004   0x88A1             LDRH     R1,[R4, #+4]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x.... 0x....      B.W      validate
   2954          
   2955          
   2956          
   2957          #if _FS_MINIMIZE <= 1
   2958          /*-----------------------------------------------------------------------*/
   2959          /* Create a Directroy Object                                             */
   2960          /*-----------------------------------------------------------------------*/
   2961          

   \                                 In section .text, align 2, keep-with-next
   2962          FRESULT f_opendir (
   2963            DIR *dj,      /* Pointer to directory object to create */
   2964            const TCHAR *path /* Pointer to the directory path */
   2965          )
   2966          {
   \                     f_opendir:
   \   00000000   0xB512             PUSH     {R1,R4,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   2967            FRESULT res;
   2968            DEF_NAMEBUF;
   2969          
   2970          
   2971            res = chk_mounted(&path, &dj->fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x4621             MOV      R1,R4
   \   0000000A   0xA803             ADD      R0,SP,#+12
   \   0000000C   0x.... 0x....      BL       chk_mounted
   2972            if (res == FR_OK) {
   \   00000010   0xB9A8             CBNZ.N   R0,??f_opendir_0
   2973              INIT_BUF(*dj);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x61A0             STR      R0,[R4, #+24]
   2974              res = follow_path(dj, path);      /* Follow the path to the directory */
   \   00000016   0x9903             LDR      R1,[SP, #+12]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       follow_path
   2975              FREE_BUF();
   2976              if (res == FR_OK) {           /* Follow completed */
   \   0000001E   0xB958             CBNZ.N   R0,??CrossCallReturnLabel_29
   2977                if (dj->dir) {            /* It is not the root dir */
   \   00000020   0x6960             LDR      R0,[R4, #+20]
   \   00000022   0xB120             CBZ.N    R0,??CrossCallReturnLabel_65
   2978                  if (dj->dir[DIR_Attr] & AM_DIR) { /* The object is a directory */
   \   00000024   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000026   0x06C9             LSLS     R1,R1,#+27
   \   00000028   0xD508             BPL.N    ??f_opendir_1
   2979                    dj->sclust = LD_CLUST(dj->dir);
   \   0000002A   0x.... 0x....      BL       ?Subroutine19
   2980                  } else {            /* The object is not a directory */
   2981                    res = FR_NO_PATH;
   2982                  }
   2983                }
   2984                if (res == FR_OK) {
   2985                  dj->id = dj->fs->id;
   \                     ??CrossCallReturnLabel_65:
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x88C0             LDRH     R0,[R0, #+6]
   \   00000032   0x80A0             STRH     R0,[R4, #+4]
   2986                  res = dir_sdi(dj, 0);     /* Rewind dir */
   \   00000034   0x.... 0x....      BL       ?Subroutine9
   2987                }
   2988              }
   2989              if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??CrossCallReturnLabel_29:
   \   00000038   0x2804             CMP      R0,#+4
   \   0000003A   0xD100             BNE.N    ??f_opendir_0
   \                     ??f_opendir_1:
   \   0000003C   0x2005             MOVS     R0,#+5
   2990            }
   2991          
   2992            LEAVE_FF(dj->fs, res);
   \                     ??f_opendir_0:
   \   0000003E   0xB004             ADD      SP,SP,#+16
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
   2993          }
   2994          
   2995          
   2996          
   2997          
   2998          /*-----------------------------------------------------------------------*/
   2999          /* Read Directory Entry in Sequense                                      */
   3000          /*-----------------------------------------------------------------------*/
   3001          

   \                                 In section .text, align 2, keep-with-next
   3002          FRESULT f_readdir (
   3003            DIR *dj,      /* Pointer to the open directory object */
   3004            FILINFO *fno    /* Pointer to file information to return */
   3005          )
   3006          {
   \                     f_readdir:
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine3
   3007            FRESULT res;
   3008            DEF_NAMEBUF;
   3009          
   3010          
   3011            res = validate(dj->fs, dj->id);     /* Check validity of the object */
   3012            if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_7:
   \   00000006   0xB9C0             CBNZ.N   R0,??f_readdir_0
   3013              if (!fno) {
   \   00000008   0xB915             CBNZ.N   R5,??f_readdir_1
   3014                res = dir_sdi(dj, 0);     /* Rewind the directory object */
   \   0000000A   0x.... 0x....      BL       ?Subroutine9
   3015              } else {
   \                     ??CrossCallReturnLabel_28:
   \   0000000E   0xBD3E             POP      {R1-R5,PC}
   3016                INIT_BUF(*dj);
   \                     ??f_readdir_1:
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x61A0             STR      R0,[R4, #+24]
   3017                res = dir_read(dj);       /* Read an directory item */
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       dir_read
   3018                if (res == FR_NO_FILE) {    /* Reached end of dir */
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD102             BNE.N    ??f_readdir_2
   3019                  dj->sect = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6120             STR      R0,[R4, #+16]
   3020                  res = FR_OK;
   \   00000022   0xE000             B.N      ??f_readdir_3
   3021                }
   3022                if (res == FR_OK) {       /* A valid entry is found */
   \                     ??f_readdir_2:
   \   00000024   0xB948             CBNZ.N   R0,??f_readdir_0
   3023                  get_fileinfo(dj, fno);    /* Get the object information */
   \                     ??f_readdir_3:
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       get_fileinfo
   3024                  res = dir_next(dj, 0);    /* Increment index for next */
   \   0000002E   0x.... 0x....      BL       ?Subroutine7
   3025                  if (res == FR_NO_FILE) {
   \                     ??CrossCallReturnLabel_22:
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xBF04             ITT      EQ 
   \   00000036   0x2000             MOVEQ    R0,#+0
   \   00000038   0x6120             STREQ    R0,[R4, #+16]
   3026                    dj->sect = 0;
   3027                    res = FR_OK;
   3028                  }
   3029                }
   3030                FREE_BUF();
   3031              }
   3032            }
   3033          
   3034            LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0:
   \   0000003A   0xBD3E             POP      {R1-R5,PC}       ;; return
   3035          }
   3036          
   3037          
   3038          
   3039          #if _FS_MINIMIZE == 0
   3040          /*-----------------------------------------------------------------------*/
   3041          /* Get File Status                                                       */
   3042          /*-----------------------------------------------------------------------*/
   3043          

   \                                 In section .text, align 2, keep-with-next
   3044          FRESULT f_stat (
   3045            const TCHAR *path,  /* Pointer to the file path */
   3046            FILINFO *fno    /* Pointer to file information to return */
   3047          )
   3048          {
   \                     f_stat:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x460C             MOV      R4,R1
   3049            FRESULT res;
   3050            DIR dj;
   3051            DEF_NAMEBUF;
   3052          
   3053          
   3054            res = chk_mounted(&path, &dj.fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA903             ADD      R1,SP,#+12
   \   0000000A   0xA80A             ADD      R0,SP,#+40
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0005             MOVS     R5,R0
   3055            if (res == FR_OK) {
   \   00000012   0xD10F             BNE.N    ??f_stat_0
   3056              INIT_BUF(dj);
   \   00000014   0xA800             ADD      R0,SP,#+0
   \   00000016   0x9009             STR      R0,[SP, #+36]
   3057              res = follow_path(&dj, path); /* Follow the file path */
   \   00000018   0x990A             LDR      R1,[SP, #+40]
   \   0000001A   0xA803             ADD      R0,SP,#+12
   \   0000001C   0x.... 0x....      BL       follow_path
   \   00000020   0x0005             MOVS     R5,R0
   3058              if (res == FR_OK) {       /* Follow completed */
   \   00000022   0xD107             BNE.N    ??f_stat_0
   3059                if (dj.dir)   /* Found an object */
   \   00000024   0x9808             LDR      R0,[SP, #+32]
   \   00000026   0xB120             CBZ.N    R0,??f_stat_1
   3060                  get_fileinfo(&dj, fno);
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0xA803             ADD      R0,SP,#+12
   \   0000002C   0x.... 0x....      BL       get_fileinfo
   \   00000030   0xE000             B.N      ??f_stat_0
   3061                else      /* It is root dir */
   3062                  res = FR_INVALID_NAME;
   \                     ??f_stat_1:
   \   00000032   0x2506             MOVS     R5,#+6
   3063              }
   3064              FREE_BUF();
   3065            }
   3066          
   3067            LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0:
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0xB00B             ADD      SP,SP,#+44
   \   00000038   0xBD30             POP      {R4,R5,PC}       ;; return
   3068          }
   3069          
   3070          
   3071          
   3072          #if !_FS_READONLY
   3073          /*-----------------------------------------------------------------------*/
   3074          /* Get Number of Free Clusters                                           */
   3075          /*-----------------------------------------------------------------------*/
   3076          

   \                                 In section .text, align 2, keep-with-next
   3077          FRESULT f_getfree (
   3078            const TCHAR *path,  /* Pointer to the logical drive number (root dir) */
   3079            DWORD *nclst,   /* Pointer to the variable to return number of free clusters */
   3080            FATFS **fatfs   /* Pointer to pointer to corresponding file system object to return */
   3081          )
   3082          {
   \                     f_getfree:
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4616             MOV      R6,R2
   3083            FRESULT res;
   3084            DWORD n, clst, sect, stat;
   3085            UINT i;
   3086            BYTE fat, *p;
   3087          
   3088          
   3089            /* Get drive number */
   3090            res = chk_mounted(&path, fatfs, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4631             MOV      R1,R6
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       chk_mounted
   \   00000014   0xEA5F 0x0900      MOVS     R9,R0
   3091            if (res == FR_OK) {
   \   00000018   0xD160             BNE.N    ??f_getfree_0
   3092              /* If free_clust is valid, return it without full cluster scan */
   3093              if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
   \   0000001A   0x6830             LDR      R0,[R6, #+0]
   \   0000001C   0x6901             LDR      R1,[R0, #+16]
   \   0000001E   0x69C4             LDR      R4,[R0, #+28]
   \   00000020   0x1EA2             SUBS     R2,R4,#+2
   \   00000022   0x428A             CMP      R2,R1
   \   00000024   0xBF28             IT       CS 
   \   00000026   0xF8C8 0x1000      STRCS    R1,[R8, #+0]
   3094                *nclst = (*fatfs)->free_clust;
   \   0000002A   0xD257             BCS.N    ??f_getfree_0
   3095              } else {
   3096                /* Get number of free clusters */
   3097                fat = (*fatfs)->fs_type;
   \   0000002C   0x7807             LDRB     R7,[R0, #+0]
   3098                n = 0;
   \   0000002E   0x2500             MOVS     R5,#+0
   3099                if (fat == FS_FAT12) {
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xD117             BNE.N    ??f_getfree_1
   3100                  clst = 2;
   \   00000034   0x2402             MOVS     R4,#+2
   3101                  do {
   3102                    stat = get_fat(*fatfs, clst);
   \                     ??f_getfree_2:
   \   00000036   0x4621             MOV      R1,R4
   \   00000038   0x6830             LDR      R0,[R6, #+0]
   \   0000003A   0x.... 0x....      BL       get_fat
   3103                    if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   0000003E   0xF110 0x0F01      CMN      R0,#+1
   \   00000042   0xD102             BNE.N    ??f_getfree_3
   \   00000044   0xF04F 0x0901      MOV      R9,#+1
   \   00000048   0xE040             B.N      ??f_getfree_4
   3104                    if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_3:
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD102             BNE.N    ??f_getfree_5
   \   0000004E   0xF04F 0x0902      MOV      R9,#+2
   \   00000052   0xE03B             B.N      ??f_getfree_4
   3105                    if (stat == 0) n++;
   \                     ??f_getfree_5:
   \   00000054   0xB900             CBNZ.N   R0,??f_getfree_6
   \   00000056   0x1C6D             ADDS     R5,R5,#+1
   3106                  } while (++clst < (*fatfs)->n_fatent);
   \                     ??f_getfree_6:
   \   00000058   0x1C64             ADDS     R4,R4,#+1
   \   0000005A   0x6830             LDR      R0,[R6, #+0]
   \   0000005C   0x69C0             LDR      R0,[R0, #+28]
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD3E9             BCC.N    ??f_getfree_2
   \   00000062   0xE033             B.N      ??f_getfree_4
   3107                } else {
   3108                  clst = (*fatfs)->n_fatent;
   3109                  sect = (*fatfs)->fatbase;
   \                     ??f_getfree_1:
   \   00000064   0xF8D0 0xA024      LDR      R10,[R0, #+36]
   3110                  i = 0; p = 0;
   \   00000068   0xE000             B.N      ??f_getfree_7
   3111                  do {
   3112                    if (!i) {
   \                     ??f_getfree_8:
   \   0000006A   0xB961             CBNZ.N   R1,??f_getfree_9
   3113                      res = move_window(*fatfs, sect++);
   \                     ??f_getfree_7:
   \   0000006C   0x4651             MOV      R1,R10
   \   0000006E   0x6830             LDR      R0,[R6, #+0]
   \   00000070   0x.... 0x....      BL       move_window
   \   00000074   0xEA5F 0x0900      MOVS     R9,R0
   \   00000078   0xF10A 0x0A01      ADD      R10,R10,#+1
   3114                      if (res != FR_OK) break;
   \   0000007C   0xD126             BNE.N    ??f_getfree_4
   3115                      p = (*fatfs)->win;
   \   0000007E   0x6830             LDR      R0,[R6, #+0]
   \   00000080   0x3034             ADDS     R0,R0,#+52
   3116                      i = SS(*fatfs);
   \   00000082   0xF44F 0x7100      MOV      R1,#+512
   3117                    }
   3118                    if (fat == FS_FAT16) {
   \                     ??f_getfree_9:
   \   00000086   0x1C6A             ADDS     R2,R5,#+1
   \   00000088   0x2F02             CMP      R7,#+2
   \   0000008A   0xD109             BNE.N    ??f_getfree_10
   3119                      if (LD_WORD(p) == 0) n++;
   \   0000008C   0x7843             LDRB     R3,[R0, #+1]
   \   0000008E   0xF890 0xC000      LDRB     R12,[R0, #+0]
   \   00000092   0xEA5C 0x2303      ORRS     R3,R12,R3, LSL #+8
   \   00000096   0xBF08             IT       EQ 
   \   00000098   0x4615             MOVEQ    R5,R2
   3120                      p += 2; i -= 2;
   \   0000009A   0x1C80             ADDS     R0,R0,#+2
   \   0000009C   0x1E89             SUBS     R1,R1,#+2
   \   0000009E   0xE013             B.N      ??f_getfree_11
   3121                    } else {
   3122                      if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_10:
   \   000000A0   0x78C3             LDRB     R3,[R0, #+3]
   \   000000A2   0xF890 0xC002      LDRB     R12,[R0, #+2]
   \   000000A6   0xEA4F 0x4C0C      LSL      R12,R12,#+16
   \   000000AA   0xEA4C 0x6303      ORR      R3,R12,R3, LSL #+24
   \   000000AE   0xF890 0xC001      LDRB     R12,[R0, #+1]
   \   000000B2   0xEA43 0x230C      ORR      R3,R3,R12, LSL #+8
   \   000000B6   0xF890 0xC000      LDRB     R12,[R0, #+0]
   \   000000BA   0xEA4C 0x0303      ORR      R3,R12,R3
   \   000000BE   0x011B             LSLS     R3,R3,#+4
   \   000000C0   0xBF08             IT       EQ 
   \   000000C2   0x4615             MOVEQ    R5,R2
   3123                      p += 4; i -= 4;
   \   000000C4   0x1D00             ADDS     R0,R0,#+4
   \   000000C6   0x1F09             SUBS     R1,R1,#+4
   3124                    }
   3125                  } while (--clst);
   \                     ??f_getfree_11:
   \   000000C8   0x1E64             SUBS     R4,R4,#+1
   \   000000CA   0xD1CE             BNE.N    ??f_getfree_8
   3126                }
   3127                (*fatfs)->free_clust = n;
   \                     ??f_getfree_4:
   \   000000CC   0x6830             LDR      R0,[R6, #+0]
   \   000000CE   0x6105             STR      R5,[R0, #+16]
   3128                if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
   \   000000D0   0x2F03             CMP      R7,#+3
   \   000000D2   0xBF04             ITT      EQ 
   \   000000D4   0x2101             MOVEQ    R1,#+1
   \   000000D6   0x7141             STRBEQ   R1,[R0, #+5]
   3129                *nclst = n;
   \   000000D8   0xF8C8 0x5000      STR      R5,[R8, #+0]
   3130              }
   3131            }
   3132            LEAVE_FF(*fatfs, res);
   \                     ??f_getfree_0:
   \   000000DC   0x4648             MOV      R0,R9
   \   000000DE   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3133          }
   3134          
   3135          
   3136          
   3137          
   3138          /*-----------------------------------------------------------------------*/
   3139          /* Truncate File                                                         */
   3140          /*-----------------------------------------------------------------------*/
   3141          

   \                                 In section .text, align 2, keep-with-next
   3142          FRESULT f_truncate (
   3143            FIL *fp   /* Pointer to the file object */
   3144          )
   3145          {
   \                     f_truncate:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   3146            FRESULT res;
   3147            DWORD ncl;
   3148          
   3149          
   3150            res = validate(fp->fs, fp->id);   /* Check validity of the object */
   \   00000004   0x88A9             LDRH     R1,[R5, #+4]
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x.... 0x....      BL       validate
   \   0000000C   0x0004             MOVS     R4,R0
   3151            if (res == FR_OK) {
   \   0000000E   0xD13B             BNE.N    ??f_truncate_0
   3152              if (fp->flag & FA__ERROR) {     /* Check abort flag */
   \   00000010   0x79A8             LDRB     R0,[R5, #+6]
   \   00000012   0x0601             LSLS     R1,R0,#+24
   \   00000014   0xBF48             IT       MI 
   \   00000016   0x2402             MOVMI    R4,#+2
   3153                res = FR_INT_ERR;
   \   00000018   0xD436             BMI.N    ??f_truncate_0
   3154              } else {
   3155                if (!(fp->flag & FA_WRITE))   /* Check access mode */
   \   0000001A   0x0781             LSLS     R1,R0,#+30
   \   0000001C   0xBF58             IT       PL 
   \   0000001E   0x2407             MOVPL    R4,#+7
   3156                  res = FR_DENIED;
   \   00000020   0xD532             BPL.N    ??f_truncate_0
   3157              }
   3158            }
   3159            if (res == FR_OK) {
   3160              if (fp->fsize > fp->fptr) {
   \   00000022   0x68A9             LDR      R1,[R5, #+8]
   \   00000024   0x68EA             LDR      R2,[R5, #+12]
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xD22E             BCS.N    ??f_truncate_0
   3161                fp->fsize = fp->fptr; /* Set file size to current R/W point */
   \   0000002A   0x60E9             STR      R1,[R5, #+12]
   3162                fp->flag |= FA__WRITTEN;
   \   0000002C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000030   0x71A8             STRB     R0,[R5, #+6]
   3163                if (fp->fptr == 0) {  /* When set file size to zero, remove entire cluster chain */
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0xB931             CBNZ.N   R1,??f_truncate_1
   3164                  res = remove_chain(fp->fs, fp->sclust);
   \   00000036   0x6929             LDR      R1,[R5, #+16]
   \   00000038   0x.... 0x....      BL       remove_chain
   \   0000003C   0x4604             MOV      R4,R0
   3165                  fp->sclust = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6128             STR      R0,[R5, #+16]
   \   00000042   0xE01C             B.N      ??f_truncate_2
   3166                } else {        /* When truncate a part of the file, remove remaining clusters */
   3167                  ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_1:
   \   00000044   0x6969             LDR      R1,[R5, #+20]
   \   00000046   0x.... 0x....      BL       get_fat
   \   0000004A   0x4606             MOV      R6,R0
   3168                  res = FR_OK;
   3169                  if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   0000004C   0xF116 0x0F01      CMN      R6,#+1
   \   00000050   0xBF08             IT       EQ 
   \   00000052   0x2401             MOVEQ    R4,#+1
   \   00000054   0xD014             BEQ.N    ??f_truncate_3
   3170                  if (ncl == 1) res = FR_INT_ERR;
   \   00000056   0x2E01             CMP      R6,#+1
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0x2402             MOVEQ    R4,#+2
   \   0000005C   0xD010             BEQ.N    ??f_truncate_3
   3171                  if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \   0000005E   0x6828             LDR      R0,[R5, #+0]
   \   00000060   0x69C1             LDR      R1,[R0, #+28]
   \   00000062   0x428E             CMP      R6,R1
   \   00000064   0xD210             BCS.N    ??f_truncate_0
   3172                    res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   00000066   0xF06F 0x4270      MVN      R2,#-268435456
   \   0000006A   0x6969             LDR      R1,[R5, #+20]
   \   0000006C   0x.... 0x....      BL       put_fat
   \   00000070   0x0004             MOVS     R4,R0
   3173                    if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000072   0xD104             BNE.N    ??f_truncate_2
   \   00000074   0x4631             MOV      R1,R6
   \   00000076   0x6828             LDR      R0,[R5, #+0]
   \   00000078   0x.... 0x....      BL       remove_chain
   \   0000007C   0x4604             MOV      R4,R0
   3174                  }
   3175                }
   3176              }
   3177              if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_2:
   \   0000007E   0xB11C             CBZ.N    R4,??f_truncate_0
   \                     ??f_truncate_3:
   \   00000080   0x79A8             LDRB     R0,[R5, #+6]
   \   00000082   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000086   0x71A8             STRB     R0,[R5, #+6]
   3178            }
   3179          
   3180            LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_0:
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   3181          }
   3182          
   3183          
   3184          
   3185          
   3186          /*-----------------------------------------------------------------------*/
   3187          /* Delete a File or Directory                                            */
   3188          /*-----------------------------------------------------------------------*/
   3189          

   \                                 In section .text, align 2, keep-with-next
   3190          FRESULT f_unlink (
   3191            const TCHAR *path   /* Pointer to the file or directory path */
   3192          )
   3193          {
   \                     f_unlink:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
   3194            FRESULT res;
   3195            DIR dj, sdj;
   3196            BYTE *dir;
   3197            DWORD dclst;
   3198            DEF_NAMEBUF;
   3199          
   3200          
   3201            res = chk_mounted(&path, &dj.fs, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA811             ADD      R0,SP,#+68
   \   0000000A   0x.... 0x....      BL       chk_mounted
   3202            if (res == FR_OK) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD14C             BNE.N    ??f_unlink_0
   3203              INIT_BUF(dj);
   \   00000012   0xA807             ADD      R0,SP,#+28
   \   00000014   0x9006             STR      R0,[SP, #+24]
   3204              res = follow_path(&dj, path);   /* Follow the file path */
   \   00000016   0x9911             LDR      R1,[SP, #+68]
   \   00000018   0x.... 0x....      BL       ??Subroutine22_1
   3205              if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \                     ??CrossCallReturnLabel_73:
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD145             BNE.N    ??f_unlink_0
   \   00000020   0x9906             LDR      R1,[SP, #+24]
   \   00000022   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000024   0x0689             LSLS     R1,R1,#+26
   \   00000026   0xBF48             IT       MI 
   \   00000028   0x2006             MOVMI    R0,#+6
   3206                res = FR_INVALID_NAME;      /* Cannot remove dot entry */
   \   0000002A   0xD43F             BMI.N    ??f_unlink_0
   3207          #if _FS_SHARE
   3208              if (res == FR_OK) res = chk_lock(&dj, 2); /* Cannot remove open file */
   3209          #endif
   3210              if (res == FR_OK) {         /* The object is accessible */
   3211                dir = dj.dir;
   \   0000002C   0x9905             LDR      R1,[SP, #+20]
   3212                if (!dir) {
   \   0000002E   0xB909             CBNZ.N   R1,??f_unlink_1
   3213                  res = FR_INVALID_NAME;    /* Cannot remove the start directory */
   \   00000030   0x2006             MOVS     R0,#+6
   \   00000032   0xE003             B.N      ??f_unlink_2
   3214                } else {
   3215                  if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_1:
   \   00000034   0x7ACA             LDRB     R2,[R1, #+11]
   \   00000036   0x07D2             LSLS     R2,R2,#+31
   \   00000038   0xBF48             IT       MI 
   \   0000003A   0x2007             MOVMI    R0,#+7
   3216                    res = FR_DENIED;    /* Cannot remove R/O object */
   3217                }
   3218                dclst = LD_CLUST(dir);
   \                     ??f_unlink_2:
   \   0000003C   0x7D4A             LDRB     R2,[R1, #+21]
   \   0000003E   0x7D0B             LDRB     R3,[R1, #+20]
   \   00000040   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \   00000044   0x7ECB             LDRB     R3,[R1, #+27]
   \   00000046   0x7E8C             LDRB     R4,[R1, #+26]
   \   00000048   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
   \   0000004C   0xEA43 0x4402      ORR      R4,R3,R2, LSL #+16
   3219                if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) { /* Is it a sub-dir? */
   \   00000050   0xB9F0             CBNZ.N   R0,??f_unlink_3
   \   00000052   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000054   0x06C0             LSLS     R0,R0,#+27
   \   00000056   0xD51C             BPL.N    ??f_unlink_4
   3220                  if (dclst < 2) {
   \   00000058   0x2C02             CMP      R4,#+2
   \   0000005A   0xBF38             IT       CC 
   \   0000005C   0x2002             MOVCC    R0,#+2
   3221                    res = FR_INT_ERR;
   \   0000005E   0xD325             BCC.N    ??f_unlink_0
   3222                  } else {
   3223                    mem_cpy(&sdj, &dj, sizeof(DIR));  /* Check if the sub-dir is empty or not */
   \   00000060   0x221C             MOVS     R2,#+28
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0xA80A             ADD      R0,SP,#+40
   \   00000066   0x.... 0x....      BL       mem_cpy
   3224                    sdj.sclust = dclst;
   \   0000006A   0x940C             STR      R4,[SP, #+48]
   3225                    res = dir_sdi(&sdj, 2);   /* Exclude dot entries */
   \   0000006C   0x2102             MOVS     R1,#+2
   \   0000006E   0xA80A             ADD      R0,SP,#+40
   \   00000070   0x.... 0x....      BL       dir_sdi
   3226                    if (res == FR_OK) {
   \   00000074   0xB960             CBNZ.N   R0,??f_unlink_3
   3227                      res = dir_read(&sdj);
   \   00000076   0xA80A             ADD      R0,SP,#+40
   \   00000078   0x.... 0x....      BL       dir_read
   3228                      if (res == FR_OK      /* Not empty dir */
   3229          #if _FS_RPATH
   3230                      || dclst == sdj.fs->cdir  /* Current dir */
   3231          #endif
   3232                      ) res = FR_DENIED;
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xBF1D             ITTTE    NE 
   \   00000080   0x990A             LDRNE    R1,[SP, #+40]
   \   00000082   0x6989             LDRNE    R1,[R1, #+24]
   \   00000084   0x428C             CMPNE    R4,R1
   \   00000086   0x2007             MOVEQ    R0,#+7
   \   00000088   0xD010             BEQ.N    ??f_unlink_0
   3233                      if (res == FR_NO_FILE) res = FR_OK; /* Empty */
   \   0000008A   0x2804             CMP      R0,#+4
   \   0000008C   0xD10E             BNE.N    ??f_unlink_0
   \   0000008E   0xE000             B.N      ??f_unlink_4
   3234                    }
   3235                  }
   3236                }
   3237                if (res == FR_OK) {
   \                     ??f_unlink_3:
   \   00000090   0xB960             CBNZ.N   R0,??f_unlink_0
   3238                  res = dir_remove(&dj);    /* Remove the directory entry */
   \                     ??f_unlink_4:
   \   00000092   0xA800             ADD      R0,SP,#+0
   \   00000094   0x.... 0x....      BL       dir_remove
   3239                  if (res == FR_OK) {
   \   00000098   0xB940             CBNZ.N   R0,??f_unlink_0
   3240                    if (dclst)        /* Remove the cluster chain if exist */
   \   0000009A   0xB124             CBZ.N    R4,??f_unlink_5
   3241                      res = remove_chain(dj.fs, dclst);
   \   0000009C   0x4621             MOV      R1,R4
   \   0000009E   0x9800             LDR      R0,[SP, #+0]
   \   000000A0   0x.... 0x....      BL       remove_chain
   3242                    if (res == FR_OK) res = sync(dj.fs);
   \   000000A4   0xB910             CBNZ.N   R0,??f_unlink_0
   \                     ??f_unlink_5:
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x.... 0x....      BL       sync
   3243                  }
   3244                }
   3245              }
   3246              FREE_BUF();
   3247            }
   3248            LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0:
   \   000000AC   0xB012             ADD      SP,SP,#+72
   \   000000AE   0xBD10             POP      {R4,PC}          ;; return
   3249          }
   3250          
   3251          
   3252          
   3253          
   3254          /*-----------------------------------------------------------------------*/
   3255          /* Create a Directory                                                    */
   3256          /*-----------------------------------------------------------------------*/
   3257          

   \                                 In section .text, align 2, keep-with-next
   3258          FRESULT f_mkdir (
   3259            const TCHAR *path   /* Pointer to the directory path */
   3260          )
   3261          {
   \                     f_mkdir:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
   3262            FRESULT res;
   3263            DIR dj;
   3264            BYTE *dir, n;
   3265            DWORD dsc, dcl, pcl, tim = get_fattime();
   \   00000006   0x.... 0x....      BL       get_fattime
   \   0000000A   0x4604             MOV      R4,R0
   3266            DEF_NAMEBUF;
   3267          
   3268          
   3269            res = chk_mounted(&path, &dj.fs, 1);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xA901             ADD      R1,SP,#+4
   \   00000010   0xA80C             ADD      R0,SP,#+48
   \   00000012   0x.... 0x....      BL       chk_mounted
   \   00000016   0x0007             MOVS     R7,R0
   3270            if (res == FR_OK) {
   \   00000018   0xD10B             BNE.N    ??f_mkdir_0
   3271              INIT_BUF(dj);
   \   0000001A   0xA808             ADD      R0,SP,#+32
   \   0000001C   0x9007             STR      R0,[SP, #+28]
   3272              res = follow_path(&dj, path);     /* Follow the file path */
   \   0000001E   0x990C             LDR      R1,[SP, #+48]
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       follow_path
   \   00000026   0x0007             MOVS     R7,R0
   3273              if (res == FR_OK) res = FR_EXIST;   /* Any object with same name is already existing */
   \   00000028   0xBF08             IT       EQ 
   \   0000002A   0x2708             MOVEQ    R7,#+8
   \   0000002C   0xF000 0x80B5      BEQ.W    ??f_mkdir_1
   3274              if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   \   00000030   0x2F04             CMP      R7,#+4
   \                     ??f_mkdir_0:
   \   00000032   0xF040 0x80B2      BNE.W    ??f_mkdir_1
   \   00000036   0x9807             LDR      R0,[SP, #+28]
   \   00000038   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000003A   0x0680             LSLS     R0,R0,#+26
   \   0000003C   0xBF48             IT       MI 
   \   0000003E   0x2706             MOVMI    R7,#+6
   3275                res = FR_INVALID_NAME;
   \   00000040   0xF100 0x80AB      BMI.W    ??f_mkdir_1
   3276              if (res == FR_NO_FILE) {        /* Can create a new directory */
   3277                dcl = create_chain(dj.fs, 0);   /* Allocate a cluster for the new directory table */
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x9801             LDR      R0,[SP, #+4]
   \   00000048   0x.... 0x....      BL       create_chain
   \   0000004C   0x0005             MOVS     R5,R0
   3278                res = FR_OK;
   3279                if (dcl == 0) res = FR_DENIED;    /* No space to allocate a new cluster */
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x2707             MOVEQ    R7,#+7
   \   00000052   0xD007             BEQ.N    ??f_mkdir_2
   3280                if (dcl == 1) res = FR_INT_ERR;
   \   00000054   0x2D01             CMP      R5,#+1
   \   00000056   0xBF08             IT       EQ 
   \   00000058   0x2702             MOVEQ    R7,#+2
   \   0000005A   0xD003             BEQ.N    ??f_mkdir_2
   3281                if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   0000005C   0xF115 0x0F01      CMN      R5,#+1
   \   00000060   0xBF08             IT       EQ 
   \   00000062   0x2701             MOVEQ    R7,#+1
   \                     ??f_mkdir_2:
   \   00000064   0xD079             BEQ.N    ??f_mkdir_3
   3282                if (res == FR_OK)         /* Flush FAT */
   3283                  res = move_window(dj.fs, 0);
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x9801             LDR      R0,[SP, #+4]
   \   0000006A   0x.... 0x....      BL       move_window
   \   0000006E   0x4607             MOV      R7,R0
   3284                if (res == FR_OK) {         /* Initialize the new directory table */
   \   00000070   0xEA4F 0x4A15      LSR      R10,R5,#+16
   \   00000074   0xEA4F 0x201A      LSR      R0,R10,#+8
   \   00000078   0xF88D 0x0002      STRB     R0,[SP, #+2]
   \   0000007C   0x0428             LSLS     R0,R5,#+16
   \   0000007E   0x0E00             LSRS     R0,R0,#+24
   \   00000080   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000084   0x0420             LSLS     R0,R4,#+16
   \   00000086   0x0E00             LSRS     R0,R0,#+24
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000008C   0xEA4F 0x4814      LSR      R8,R4,#+16
   \   00000090   0x2F00             CMP      R7,#+0
   \   00000092   0xD15C             BNE.N    ??f_mkdir_4
   3285                  dsc = clust2sect(dj.fs, dcl);
   \   00000094   0x4629             MOV      R1,R5
   \   00000096   0x9801             LDR      R0,[SP, #+4]
   \   00000098   0x.... 0x....      BL       clust2sect
   \   0000009C   0x4681             MOV      R9,R0
   3286                  dir = dj.fs->win;
   \   0000009E   0x9801             LDR      R0,[SP, #+4]
   \   000000A0   0xF100 0x0634      ADD      R6,R0,#+52
   3287                  mem_set(dir, 0, SS(dj.fs));
   \   000000A4   0x.... 0x....      BL       ?Subroutine8
   3288                  mem_set(dir+DIR_Name, ' ', 8+3);  /* Create "." entry */
   \                     ??CrossCallReturnLabel_27:
   \   000000A8   0x220B             MOVS     R2,#+11
   \   000000AA   0x2120             MOVS     R1,#+32
   \   000000AC   0x4630             MOV      R0,R6
   \   000000AE   0x.... 0x....      BL       mem_set
   3289                  dir[DIR_Name] = '.';
   \   000000B2   0x202E             MOVS     R0,#+46
   \   000000B4   0x7030             STRB     R0,[R6, #+0]
   3290                  dir[DIR_Attr] = AM_DIR;
   \   000000B6   0x2010             MOVS     R0,#+16
   \   000000B8   0x72F0             STRB     R0,[R6, #+11]
   3291                  ST_DWORD(dir+DIR_WrtTime, tim);
   \   000000BA   0x75B4             STRB     R4,[R6, #+22]
   \   000000BC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C0   0x75F0             STRB     R0,[R6, #+23]
   \   000000C2   0xF886 0x8018      STRB     R8,[R6, #+24]
   \   000000C6   0x0E20             LSRS     R0,R4,#+24
   \   000000C8   0x7670             STRB     R0,[R6, #+25]
   3292                  ST_CLUST(dir, dcl);
   \   000000CA   0x76B5             STRB     R5,[R6, #+26]
   \   000000CC   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000D0   0x76F0             STRB     R0,[R6, #+27]
   \   000000D2   0xF886 0xA014      STRB     R10,[R6, #+20]
   \   000000D6   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000DA   0x7570             STRB     R0,[R6, #+21]
   3293                  mem_cpy(dir+SZ_DIR, dir, SZ_DIR);   /* Create ".." entry */
   \   000000DC   0x2220             MOVS     R2,#+32
   \   000000DE   0x4631             MOV      R1,R6
   \   000000E0   0xF106 0x0020      ADD      R0,R6,#+32
   \   000000E4   0x.... 0x....      BL       mem_cpy
   3294                  dir[33] = '.'; pcl = dj.sclust;
   \   000000E8   0x202E             MOVS     R0,#+46
   \   000000EA   0xF886 0x0021      STRB     R0,[R6, #+33]
   \   000000EE   0x9803             LDR      R0,[SP, #+12]
   3295                  if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   000000F0   0x9901             LDR      R1,[SP, #+4]
   \   000000F2   0x7809             LDRB     R1,[R1, #+0]
   \   000000F4   0x2903             CMP      R1,#+3
   \   000000F6   0xBF01             ITTTT    EQ 
   \   000000F8   0x9901             LDREQ    R1,[SP, #+4]
   \   000000FA   0x6A89             LDREQ    R1,[R1, #+40]
   \   000000FC   0x4288             CMPEQ    R0,R1
   \   000000FE   0x2000             MOVEQ    R0,#+0
   3296                    pcl = 0;
   3297                  ST_CLUST(dir+SZ_DIR, pcl);
   \   00000100   0xF886 0x003A      STRB     R0,[R6, #+58]
   \   00000104   0x0401             LSLS     R1,R0,#+16
   \   00000106   0x0E09             LSRS     R1,R1,#+24
   \   00000108   0xF886 0x103B      STRB     R1,[R6, #+59]
   \   0000010C   0x0C00             LSRS     R0,R0,#+16
   \   0000010E   0xF886 0x0034      STRB     R0,[R6, #+52]
   \   00000112   0x0A00             LSRS     R0,R0,#+8
   \   00000114   0xF886 0x0035      STRB     R0,[R6, #+53]
   3298                  for (n = dj.fs->csize; n; n--) {  /* Write dot entries and clear following sectors */
   \   00000118   0x9801             LDR      R0,[SP, #+4]
   \   0000011A   0xF890 0xB002      LDRB     R11,[R0, #+2]
   \   0000011E   0xE003             B.N      ??f_mkdir_5
   3299                    dj.fs->winsect = dsc++;
   3300                    dj.fs->wflag = 1;
   3301                    res = move_window(dj.fs, 0);
   3302                    if (res != FR_OK) break;
   3303                    mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_6:
   \   00000120   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_26:
   \   00000124   0xF1AB 0x0B01      SUB      R11,R11,#+1
   \                     ??f_mkdir_5:
   \   00000128   0xFA5F 0xFB8B      UXTB     R11,R11
   \   0000012C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000130   0xD00E             BEQ.N    ??f_mkdir_7
   \   00000132   0x9801             LDR      R0,[SP, #+4]
   \   00000134   0xF8C0 0x9030      STR      R9,[R0, #+48]
   \   00000138   0xF109 0x0901      ADD      R9,R9,#+1
   \   0000013C   0x9801             LDR      R0,[SP, #+4]
   \   0000013E   0x2101             MOVS     R1,#+1
   \   00000140   0x7101             STRB     R1,[R0, #+4]
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0x9801             LDR      R0,[SP, #+4]
   \   00000146   0x.... 0x....      BL       move_window
   \   0000014A   0x0007             MOVS     R7,R0
   \   0000014C   0xD0E8             BEQ.N    ??f_mkdir_6
   3304                  }
   3305                }
   3306                if (res == FR_OK) res = dir_register(&dj);  /* Register the object to the directoy */
   \                     ??f_mkdir_4:
   \   0000014E   0xB91F             CBNZ.N   R7,??f_mkdir_8
   \                     ??f_mkdir_7:
   \   00000150   0xA801             ADD      R0,SP,#+4
   \   00000152   0x.... 0x....      BL       dir_register
   \   00000156   0x4607             MOV      R7,R0
   3307                if (res != FR_OK) {
   \                     ??f_mkdir_8:
   \   00000158   0xB127             CBZ.N    R7,??f_mkdir_9
   3308                  remove_chain(dj.fs, dcl);     /* Could not register, remove cluster chain */
   \                     ??f_mkdir_3:
   \   0000015A   0x4629             MOV      R1,R5
   \   0000015C   0x9801             LDR      R0,[SP, #+4]
   \   0000015E   0x.... 0x....      BL       remove_chain
   \   00000162   0xE01A             B.N      ??f_mkdir_1
   3309                } else {
   3310                  dir = dj.dir;
   \                     ??f_mkdir_9:
   \   00000164   0x9906             LDR      R1,[SP, #+24]
   3311                  dir[DIR_Attr] = AM_DIR;       /* Attribute */
   \   00000166   0x2010             MOVS     R0,#+16
   \   00000168   0x72C8             STRB     R0,[R1, #+11]
   3312                  ST_DWORD(dir+DIR_WrtTime, tim);   /* Created time */
   \   0000016A   0x758C             STRB     R4,[R1, #+22]
   \   0000016C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000170   0x75C8             STRB     R0,[R1, #+23]
   \   00000172   0xF881 0x8018      STRB     R8,[R1, #+24]
   \   00000176   0x0E20             LSRS     R0,R4,#+24
   \   00000178   0x7648             STRB     R0,[R1, #+25]
   3313                  ST_CLUST(dir, dcl);         /* Table start cluster */
   \   0000017A   0x768D             STRB     R5,[R1, #+26]
   \   0000017C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000180   0x76C8             STRB     R0,[R1, #+27]
   \   00000182   0xF881 0xA014      STRB     R10,[R1, #+20]
   \   00000186   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000018A   0x7548             STRB     R0,[R1, #+21]
   3314                  dj.fs->wflag = 1;
   \   0000018C   0x9801             LDR      R0,[SP, #+4]
   \   0000018E   0x2101             MOVS     R1,#+1
   \   00000190   0x7101             STRB     R1,[R0, #+4]
   3315                  res = sync(dj.fs);
   \   00000192   0x9801             LDR      R0,[SP, #+4]
   \   00000194   0x.... 0x....      BL       sync
   \   00000198   0x4607             MOV      R7,R0
   3316                }
   3317              }
   3318              FREE_BUF();
   3319            }
   3320          
   3321            LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_1:
   \   0000019A   0x4638             MOV      R0,R7
   \   0000019C   0xB00D             ADD      SP,SP,#+52
   \   0000019E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3322          }
   3323          
   3324          
   3325          
   3326          
   3327          /*-----------------------------------------------------------------------*/
   3328          /* Change Attribute                                                      */
   3329          /*-----------------------------------------------------------------------*/
   3330          

   \                                 In section .text, align 2, keep-with-next
   3331          FRESULT f_chmod (
   3332            const TCHAR *path,  /* Pointer to the file path */
   3333            BYTE value,     /* Attribute bits */
   3334            BYTE mask     /* Attribute mask to change */
   3335          )
   3336          {
   \                     f_chmod:
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4614             MOV      R4,R2
   3337            FRESULT res;
   3338            DIR dj;
   3339            BYTE *dir;
   3340            DEF_NAMEBUF;
   3341          
   3342          
   3343            res = chk_mounted(&path, &dj.fs, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x.... 0x....      BL       ?Subroutine21
   3344            if (res == FR_OK) {
   \                     ??CrossCallReturnLabel_68:
   \   0000000E   0xB9A0             CBNZ.N   R0,??CrossCallReturnLabel_60
   3345              INIT_BUF(dj);
   \   00000010   0x.... 0x....      BL       ?Subroutine22
   3346              res = follow_path(&dj, path);   /* Follow the file path */
   3347              FREE_BUF();
   3348              if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \                     ??CrossCallReturnLabel_75:
   \   00000014   0xB988             CBNZ.N   R0,??CrossCallReturnLabel_60
   \   00000016   0x9806             LDR      R0,[SP, #+24]
   \   00000018   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000001A   0x0680             LSLS     R0,R0,#+26
   \   0000001C   0xD401             BMI.N    ??f_chmod_0
   3349                res = FR_INVALID_NAME;
   3350              if (res == FR_OK) {
   3351                dir = dj.dir;
   \   0000001E   0x9805             LDR      R0,[SP, #+20]
   3352                if (!dir) {           /* Is it a root directory? */
   \   00000020   0xB908             CBNZ.N   R0,??f_chmod_1
   3353                  res = FR_INVALID_NAME;
   \                     ??f_chmod_0:
   \   00000022   0x2006             MOVS     R0,#+6
   \   00000024   0xE009             B.N      ??CrossCallReturnLabel_60
   3354                } else {            /* File or sub directory */
   3355                  mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;  /* Valid attribute mask */
   \                     ??f_chmod_1:
   \   00000026   0xF004 0x0427      AND      R4,R4,#0x27
   3356                  dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask); /* Apply attribute change */
   \   0000002A   0xEA04 0x0105      AND      R1,R4,R5
   \   0000002E   0x7AC2             LDRB     R2,[R0, #+11]
   \   00000030   0x43A2             BICS     R2,R2,R4
   \   00000032   0x4311             ORRS     R1,R2,R1
   \   00000034   0x72C1             STRB     R1,[R0, #+11]
   3357                  dj.fs->wflag = 1;
   \   00000036   0x.... 0x....      BL       ?Subroutine17
   3358                  res = sync(dj.fs);
   3359                }
   3360              }
   3361            }
   3362          
   3363            LEAVE_FF(dj.fs, res);
   \                     ??CrossCallReturnLabel_60:
   \   0000003A   0xB00B             ADD      SP,SP,#+44
   \   0000003C   0xBD30             POP      {R4,R5,PC}       ;; return
   3364          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17:
   \   00000000   0x9800             LDR      R0,[SP, #+0]
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7101             STRB     R1,[R0, #+4]
   \   00000006   0x9800             LDR      R0,[SP, #+0]
   \   00000008   0x.... 0x....      B.W      sync
   3365          
   3366          
   3367          
   3368          
   3369          /*-----------------------------------------------------------------------*/
   3370          /* Change Timestamp                                                      */
   3371          /*-----------------------------------------------------------------------*/
   3372          

   \                                 In section .text, align 2, keep-with-next
   3373          FRESULT f_utime (
   3374            const TCHAR *path,  /* Pointer to the file/directory name */
   3375            const FILINFO *fno  /* Pointer to the time stamp to be set */
   3376          )
   3377          {
   \                     f_utime:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x460C             MOV      R4,R1
   3378            FRESULT res;
   3379            DIR dj;
   3380            BYTE *dir;
   3381            DEF_NAMEBUF;
   3382          
   3383          
   3384            res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xA80B             ADD      R0,SP,#+44
   \   0000000C   0x.... 0x....      BL       chk_mounted
   3385            if (res == FR_OK) {
   \   00000010   0xB9C8             CBNZ.N   R0,??CrossCallReturnLabel_59
   3386              INIT_BUF(dj);
   \   00000012   0xA807             ADD      R0,SP,#+28
   \   00000014   0x9006             STR      R0,[SP, #+24]
   3387              res = follow_path(&dj, path); /* Follow the file path */
   \   00000016   0x990B             LDR      R1,[SP, #+44]
   \   00000018   0x.... 0x....      BL       ??Subroutine22_1
   3388              FREE_BUF();
   3389              if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \                     ??CrossCallReturnLabel_72:
   \   0000001C   0xB998             CBNZ.N   R0,??CrossCallReturnLabel_59
   \   0000001E   0x9806             LDR      R0,[SP, #+24]
   \   00000020   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000022   0x0680             LSLS     R0,R0,#+26
   \   00000024   0xD401             BMI.N    ??f_utime_0
   3390                res = FR_INVALID_NAME;
   3391              if (res == FR_OK) {
   3392                dir = dj.dir;
   \   00000026   0x9805             LDR      R0,[SP, #+20]
   3393                if (!dir) {         /* Root directory */
   \   00000028   0xB908             CBNZ.N   R0,??f_utime_1
   3394                  res = FR_INVALID_NAME;
   \                     ??f_utime_0:
   \   0000002A   0x2006             MOVS     R0,#+6
   \   0000002C   0xE00B             B.N      ??CrossCallReturnLabel_59
   3395                } else {          /* File or sub-directory */
   3396                  ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_1:
   \   0000002E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000030   0x7581             STRB     R1,[R0, #+22]
   \   00000032   0x88E1             LDRH     R1,[R4, #+6]
   \   00000034   0x0A09             LSRS     R1,R1,#+8
   \   00000036   0x75C1             STRB     R1,[R0, #+23]
   3397                  ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   00000038   0x88A1             LDRH     R1,[R4, #+4]
   \   0000003A   0x7601             STRB     R1,[R0, #+24]
   \   0000003C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000003E   0x0A09             LSRS     R1,R1,#+8
   \   00000040   0x7641             STRB     R1,[R0, #+25]
   3398                  dj.fs->wflag = 1;
   \   00000042   0x.... 0x....      BL       ?Subroutine17
   3399                  res = sync(dj.fs);
   3400                }
   3401              }
   3402            }
   3403          
   3404            LEAVE_FF(dj.fs, res);
   \                     ??CrossCallReturnLabel_59:
   \   00000046   0xB00C             ADD      SP,SP,#+48
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
   3405          }
   3406          
   3407          
   3408          
   3409          
   3410          /*-----------------------------------------------------------------------*/
   3411          /* Rename File/Directory                                                 */
   3412          /*-----------------------------------------------------------------------*/
   3413          

   \                                 In section .text, align 2, keep-with-next
   3414          FRESULT f_rename (
   3415            const TCHAR *path_old,  /* Pointer to the old name */
   3416            const TCHAR *path_new /* Pointer to the new name */
   3417          )
   3418          {
   \                     f_rename:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB097             SUB      SP,SP,#+92
   \   00000004   0x460C             MOV      R4,R1
   3419            FRESULT res;
   3420            DIR djo, djn;
   3421            BYTE buf[21], *dir;
   3422            DWORD dw;
   3423            DEF_NAMEBUF;
   3424          
   3425          
   3426            res = chk_mounted(&path_old, &djo.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA907             ADD      R1,SP,#+28
   \   0000000A   0xA817             ADD      R0,SP,#+92
   \   0000000C   0x.... 0x....      BL       chk_mounted
   3427            if (res == FR_OK) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD178             BNE.N    ??f_rename_0
   3428              djn.fs = djo.fs;
   \   00000014   0x9807             LDR      R0,[SP, #+28]
   \   00000016   0x9000             STR      R0,[SP, #+0]
   3429              INIT_BUF(djo);
   \   00000018   0xA80E             ADD      R0,SP,#+56
   \   0000001A   0x900D             STR      R0,[SP, #+52]
   3430              res = follow_path(&djo, path_old);    /* Check old object */
   \   0000001C   0x9917             LDR      R1,[SP, #+92]
   \   0000001E   0xA807             ADD      R0,SP,#+28
   \   00000020   0x.... 0x....      BL       follow_path
   3431              if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD16E             BNE.N    ??f_rename_0
   \   00000028   0x980D             LDR      R0,[SP, #+52]
   \   0000002A   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000002C   0x0680             LSLS     R0,R0,#+26
   \   0000002E   0xBF48             IT       MI 
   \   00000030   0x2006             MOVMI    R0,#+6
   3432                res = FR_INVALID_NAME;
   \   00000032   0xD468             BMI.N    ??f_rename_0
   3433          #if _FS_SHARE
   3434              if (res == FR_OK) res = chk_lock(&djo, 2);
   3435          #endif
   3436              if (res == FR_OK) {           /* Old object is found */
   3437                if (!djo.dir) {           /* Is root dir? */
   \   00000034   0x980C             LDR      R0,[SP, #+48]
   \   00000036   0xB908             CBNZ.N   R0,??f_rename_1
   3438                  res = FR_NO_FILE;
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xE064             B.N      ??f_rename_0
   3439                } else {
   3440                  mem_cpy(buf, djo.dir+DIR_Attr, 21);   /* Save the object information except for name */
   \                     ??f_rename_1:
   \   0000003C   0x2215             MOVS     R2,#+21
   \   0000003E   0xF100 0x010B      ADD      R1,R0,#+11
   \   00000042   0xA811             ADD      R0,SP,#+68
   \   00000044   0x.... 0x....      BL       mem_cpy
   3441                  mem_cpy(&djn, &djo, sizeof(DIR));   /* Check new object */
   \   00000048   0x221C             MOVS     R2,#+28
   \   0000004A   0xA907             ADD      R1,SP,#+28
   \   0000004C   0xA800             ADD      R0,SP,#+0
   \   0000004E   0x.... 0x....      BL       mem_cpy
   3442                  res = follow_path(&djn, path_new);
   \   00000052   0x4621             MOV      R1,R4
   \   00000054   0x.... 0x....      BL       ??Subroutine22_1
   3443                  if (res == FR_OK) res = FR_EXIST;   /* The new object name is already existing */
   \                     ??CrossCallReturnLabel_71:
   \   00000058   0xB908             CBNZ.N   R0,??f_rename_2
   \   0000005A   0x2008             MOVS     R0,#+8
   \   0000005C   0xE053             B.N      ??f_rename_0
   3444                  if (res == FR_NO_FILE) {        /* Is it a valid path and no name collision? */
   \                     ??f_rename_2:
   \   0000005E   0x2804             CMP      R0,#+4
   \   00000060   0xD151             BNE.N    ??f_rename_0
   3445          /* Start critical section that any interruption or error can cause cross-link */
   3446                    res = dir_register(&djn);     /* Register the new entry */
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x.... 0x....      BL       dir_register
   3447                    if (res == FR_OK) {
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD14C             BNE.N    ??f_rename_0
   3448                      dir = djn.dir;          /* Copy object information except for name */
   \   0000006C   0x9C05             LDR      R4,[SP, #+20]
   3449                      mem_cpy(dir+13, buf+2, 19);
   \   0000006E   0x2213             MOVS     R2,#+19
   \   00000070   0xF10D 0x0146      ADD      R1,SP,#+70
   \   00000074   0xF104 0x000D      ADD      R0,R4,#+13
   \   00000078   0x.... 0x....      BL       mem_cpy
   3450                      dir[DIR_Attr] = buf[0] | AM_ARC;
   \   0000007C   0xF89D 0x0044      LDRB     R0,[SP, #+68]
   \   00000080   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000084   0x72E0             STRB     R0,[R4, #+11]
   3451                      djo.fs->wflag = 1;
   \   00000086   0x9807             LDR      R0,[SP, #+28]
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x7101             STRB     R1,[R0, #+4]
   3452                      if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {   /* Update .. entry in the directory if needed */
   \   0000008C   0x9809             LDR      R0,[SP, #+36]
   \   0000008E   0x9902             LDR      R1,[SP, #+8]
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD031             BEQ.N    ??f_rename_3
   \   00000094   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000096   0x06C0             LSLS     R0,R0,#+27
   \   00000098   0xD52E             BPL.N    ??f_rename_3
   3453                        dw = clust2sect(djn.fs, LD_CLUST(dir));
   \   0000009A   0x7D60             LDRB     R0,[R4, #+21]
   \   0000009C   0x7D21             LDRB     R1,[R4, #+20]
   \   0000009E   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000000A2   0x7EE1             LDRB     R1,[R4, #+27]
   \   000000A4   0x7EA2             LDRB     R2,[R4, #+26]
   \   000000A6   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   000000AA   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x.... 0x....      BL       clust2sect
   \   000000B4   0x0001             MOVS     R1,R0
   3454                        if (!dw) {
   \   000000B6   0xBF08             IT       EQ 
   \   000000B8   0x2002             MOVEQ    R0,#+2
   3455                          res = FR_INT_ERR;
   \   000000BA   0xD024             BEQ.N    ??f_rename_0
   3456                        } else {
   3457                          res = move_window(djn.fs, dw);
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   \   000000BE   0x.... 0x....      BL       move_window
   3458                          dir = djn.fs->win+SZ_DIR; /* .. entry */
   \   000000C2   0x9900             LDR      R1,[SP, #+0]
   \   000000C4   0xF101 0x0454      ADD      R4,R1,#+84
   3459                          if (res == FR_OK && dir[1] == '.') {
   \   000000C8   0xB9E8             CBNZ.N   R0,??f_rename_0
   \   000000CA   0x7860             LDRB     R0,[R4, #+1]
   \   000000CC   0x282E             CMP      R0,#+46
   \   000000CE   0xD113             BNE.N    ??f_rename_3
   3460                            dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
   \   000000D0   0x9902             LDR      R1,[SP, #+8]
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x7800             LDRB     R0,[R0, #+0]
   \   000000D6   0x2803             CMP      R0,#+3
   \   000000D8   0xBF01             ITTTT    EQ 
   \   000000DA   0x9800             LDREQ    R0,[SP, #+0]
   \   000000DC   0x6A80             LDREQ    R0,[R0, #+40]
   \   000000DE   0x4281             CMPEQ    R1,R0
   \   000000E0   0x2100             MOVEQ    R1,#+0
   3461                            ST_CLUST(dir, dw);
   \   000000E2   0x76A1             STRB     R1,[R4, #+26]
   \   000000E4   0x0408             LSLS     R0,R1,#+16
   \   000000E6   0x0E00             LSRS     R0,R0,#+24
   \   000000E8   0x76E0             STRB     R0,[R4, #+27]
   \   000000EA   0x0C08             LSRS     R0,R1,#+16
   \   000000EC   0x7520             STRB     R0,[R4, #+20]
   \   000000EE   0x0A00             LSRS     R0,R0,#+8
   \   000000F0   0x7560             STRB     R0,[R4, #+21]
   3462                            djn.fs->wflag = 1;
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0x7101             STRB     R1,[R0, #+4]
   3463                          }
   3464                        }
   3465                      }
   3466                      if (res == FR_OK) {
   3467                        res = dir_remove(&djo);   /* Remove old entry */
   \                     ??f_rename_3:
   \   000000F8   0xA807             ADD      R0,SP,#+28
   \   000000FA   0x.... 0x....      BL       dir_remove
   3468                        if (res == FR_OK)
   \   000000FE   0xB910             CBNZ.N   R0,??f_rename_0
   3469                          res = sync(djo.fs);
   \   00000100   0x9807             LDR      R0,[SP, #+28]
   \   00000102   0x.... 0x....      BL       sync
   3470                      }
   3471                    }
   3472          /* End critical section */
   3473                  }
   3474                }
   3475              }
   3476              FREE_BUF();
   3477            }
   3478            LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0:
   \   00000106   0xB018             ADD      SP,SP,#+96
   \   00000108   0xBD10             POP      {R4,PC}          ;; return
   3479          }
   3480          
   3481          #endif /* !_FS_READONLY */
   3482          #endif /* _FS_MINIMIZE == 0 */
   3483          #endif /* _FS_MINIMIZE <= 1 */
   3484          #endif /* _FS_MINIMIZE <= 2 */
   3485          
   3486          
   3487          
   3488          /*-----------------------------------------------------------------------*/
   3489          /* Forward data to the stream directly (available on only tiny cfg)      */
   3490          /*-----------------------------------------------------------------------*/
   3491          #if _USE_FORWARD && _FS_TINY
   3492          
   3493          FRESULT f_forward (
   3494            FIL *fp,            /* Pointer to the file object */
   3495            UINT (*func)(const BYTE*,UINT), /* Pointer to the streaming function */
   3496            UINT btr,           /* Number of bytes to forward */
   3497            UINT *bf            /* Pointer to number of bytes forwarded */
   3498          )
   3499          {
   3500            FRESULT res;
   3501            DWORD remain, clst, sect;
   3502            UINT rcnt;
   3503            BYTE csect;
   3504          
   3505          
   3506            *bf = 0;  /* Initialize byte counter */
   3507          
   3508            res = validate(fp->fs, fp->id);         /* Check validity of the object */
   3509            if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3510            if (fp->flag & FA__ERROR)           /* Check error flag */
   3511              LEAVE_FF(fp->fs, FR_INT_ERR);
   3512            if (!(fp->flag & FA_READ))            /* Check access mode */
   3513              LEAVE_FF(fp->fs, FR_DENIED);
   3514          
   3515            remain = fp->fsize - fp->fptr;
   3516            if (btr > remain) btr = (UINT)remain;     /* Truncate btr by remaining bytes */
   3517          
   3518            for ( ;  btr && (*func)(0, 0);          /* Repeat until all data transferred or stream becomes busy */
   3519              fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   3520              csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));  /* Sector offset in the cluster */
   3521              if ((fp->fptr % SS(fp->fs)) == 0) {     /* On the sector boundary? */
   3522                if (!csect) {             /* On the cluster boundary? */
   3523                  clst = (fp->fptr == 0) ?      /* On the top of the file? */
   3524                    fp->sclust : get_fat(fp->fs, fp->clust);
   3525                  if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3526                  if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3527                  fp->clust = clst;         /* Update current cluster */
   3528                }
   3529              }
   3530              sect = clust2sect(fp->fs, fp->clust);   /* Get current data sector */
   3531              if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3532              sect += csect;
   3533              if (move_window(fp->fs, sect))        /* Move sector window */
   3534                ABORT(fp->fs, FR_DISK_ERR);
   3535              fp->dsect = sect;
   3536              rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));  /* Forward data from sector window */
   3537              if (rcnt > btr) rcnt = btr;
   3538              rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3539              if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3540            }
   3541          
   3542            LEAVE_FF(fp->fs, FR_OK);
   3543          }
   3544          #endif /* _USE_FORWARD */
   3545          
   3546          
   3547          
   3548          #if _USE_MKFS && !_FS_READONLY
   3549          /*-----------------------------------------------------------------------*/
   3550          /* Create File System on the Drive                                       */
   3551          /*-----------------------------------------------------------------------*/
   3552          #define N_ROOTDIR 512   /* Number of root dir entries for FAT12/16 */
   3553          #define N_FATS    1   /* Number of FAT copies (1 or 2) */
   3554          
   3555          

   \                                 In section .text, align 2, keep-with-next
   3556          FRESULT f_mkfs (
   3557            BYTE drv,   /* Logical drive number */
   3558            BYTE sfd,   /* Partitioning rule 0:FDISK, 1:SFD */
   3559            UINT au     /* Allocation unit size [bytes] */
   3560          )
   3561          {
   \                     f_mkfs:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4614             MOV      R4,R2
   3562            static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   3563            static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   3564            BYTE fmt, md, sys, *tbl, pdrv, part;
   3565            DWORD n_clst, vs, n, wsect;
   3566            UINT i;
   3567            DWORD b_vol, b_fat, b_dir, b_data;  /* LBA */
   3568            DWORD n_vol, n_rsv, n_fat, n_dir; /* Size */
   3569            FATFS *fs;
   3570            DSTATUS stat;
   3571          
   3572          
   3573            /* Check mounted drive and clear work area */
   3574            if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \   0000000A   0xB108             CBZ.N    R0,??f_mkfs_0
   \   0000000C   0x200B             MOVS     R0,#+11
   \   0000000E   0xE252             B.N      ??f_mkfs_1
   3575            if (sfd > 1) return FR_INVALID_PARAMETER;
   \                     ??f_mkfs_0:
   \   00000010   0x2F02             CMP      R7,#+2
   \   00000012   0xD202             BCS.N    ??f_mkfs_2
   3576            if (au & (au - 1)) return FR_INVALID_PARAMETER;
   \   00000014   0x1E60             SUBS     R0,R4,#+1
   \   00000016   0x4204             TST      R4,R0
   \   00000018   0xD001             BEQ.N    ??f_mkfs_3
   \                     ??f_mkfs_2:
   \   0000001A   0x2013             MOVS     R0,#+19
   \   0000001C   0xE24B             B.N      ??f_mkfs_1
   3577            fs = FatFs[drv];
   \                     ??f_mkfs_3:
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000022   0x6840             LDR      R0,[R0, #+4]
   \   00000024   0x9003             STR      R0,[SP, #+12]
   3578            if (!fs) return FR_NOT_ENABLED;
   \   00000026   0xB908             CBNZ.N   R0,??f_mkfs_4
   \   00000028   0x200C             MOVS     R0,#+12
   \                     ??f_mkfs_5:
   \   0000002A   0xE244             B.N      ??f_mkfs_1
   3579            fs->fs_type = 0;
   \                     ??f_mkfs_4:
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
   3580            pdrv = LD2PD(drv);  /* Physical drive */
   3581            part = LD2PT(drv);  /* Partition (0:auto detect, 1-4:get from partition table)*/
   3582          
   3583            /* Get disk statics */
   3584            stat = disk_initialize(pdrv);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       disk_initialize
   3585            if (stat & STA_NOINIT) return FR_NOT_READY;
   \   00000036   0x07C1             LSLS     R1,R0,#+31
   \   00000038   0xBF48             IT       MI 
   \   0000003A   0x2003             MOVMI    R0,#+3
   \   0000003C   0xD4F5             BMI.N    ??f_mkfs_5
   3586            if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   \   0000003E   0x0740             LSLS     R0,R0,#+29
   \   00000040   0xBF48             IT       MI 
   \   00000042   0x200A             MOVMI    R0,#+10
   \   00000044   0xD4F1             BMI.N    ??f_mkfs_5
   3587          #if _MAX_SS != 512          /* Get disk sector size */
   3588            if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   3589              return FR_DISK_ERR;
   3590          #endif
   3591            if (_MULTI_PARTITION && part) {
   3592              /* Get partition information from partition table in the MBR */
   3593              if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3594              if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   3595              tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3596              if (!tbl[4]) return FR_MKFS_ABORTED;  /* No partition? */
   3597              b_vol = LD_DWORD(tbl+8);  /* Volume start sector */
   3598              n_vol = LD_DWORD(tbl+12); /* Volume size */
   3599            } else {
   3600              /* Create a partition in this function */
   3601              if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   \   00000046   0xAA01             ADD      R2,SP,#+4
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       disk_ioctl
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xF040 0x822F      BNE.W    ??f_mkfs_6
   \   00000056   0x9801             LDR      R0,[SP, #+4]
   \   00000058   0x2880             CMP      R0,#+128
   \   0000005A   0xF0C0 0x822B      BCC.W    ??f_mkfs_6
   3602                return FR_DISK_ERR;
   3603              b_vol = (sfd) ? 0 : 63;   /* Volume start sector */
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xBF14             ITE      NE 
   \   00000062   0x2000             MOVNE    R0,#+0
   \   00000064   0x203F             MOVEQ    R0,#+63
   \   00000066   0x9002             STR      R0,[SP, #+8]
   3604              n_vol -= b_vol;       /* Volume size */
   \   00000068   0x9801             LDR      R0,[SP, #+4]
   \   0000006A   0x9902             LDR      R1,[SP, #+8]
   \   0000006C   0x1A40             SUBS     R0,R0,R1
   \   0000006E   0x9001             STR      R0,[SP, #+4]
   3605            }
   3606          
   3607            if (!au) {        /* AU auto selection */
   \   00000070   0xB994             CBNZ.N   R4,??f_mkfs_7
   3608              vs = n_vol / (2000 / (SS(fs) / 512));
   \   00000072   0xF44F 0x61FA      MOV      R1,#+2000
   \   00000076   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   3609              for (i = 0; vs < vst[i]; i++) ;
   \   0000007A   0xF04F 0x0A00      MOV      R10,#+0
   \   0000007E   0x.... 0x....      ADR.W    R1,??vst
   \   00000082   0xE001             B.N      ??f_mkfs_8
   \                     ??f_mkfs_9:
   \   00000084   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??f_mkfs_8:
   \   00000088   0xF831 0x201A      LDRH     R2,[R1, R10, LSL #+1]
   \   0000008C   0x4290             CMP      R0,R2
   \   0000008E   0xD3F9             BCC.N    ??f_mkfs_9
   3610              au = cst[i];
   \   00000090   0x.... 0x....      ADR.W    R0,??cst
   \   00000094   0xF830 0x401A      LDRH     R4,[R0, R10, LSL #+1]
   3611            }
   3612            au /= SS(fs);   /* Number of sectors per cluster */
   \                     ??f_mkfs_7:
   \   00000098   0x0A64             LSRS     R4,R4,#+9
   3613            if (au == 0) au = 1;
   \   0000009A   0xBF08             IT       EQ 
   \   0000009C   0x2401             MOVEQ    R4,#+1
   \   0000009E   0xD002             BEQ.N    ??f_mkfs_10
   3614            if (au > 128) au = 128;
   \   000000A0   0x2C81             CMP      R4,#+129
   \   000000A2   0xBF28             IT       CS 
   \   000000A4   0x2480             MOVCS    R4,#+128
   3615          
   3616            /* Pre-compute number of clusters and FAT syb-type */
   3617            n_clst = n_vol / au;
   \                     ??f_mkfs_10:
   \   000000A6   0x9801             LDR      R0,[SP, #+4]
   \   000000A8   0xFBB0 0xF8F4      UDIV     R8,R0,R4
   3618            fmt = FS_FAT12;
   \   000000AC   0x2501             MOVS     R5,#+1
   \   000000AE   0xF640 0x70F6      MOVW     R0,#+4086
   \   000000B2   0x4580             CMP      R8,R0
   \   000000B4   0xBF28             IT       CS 
   \   000000B6   0x2502             MOVCS    R5,#+2
   3619            if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   3620            if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   \   000000B8   0xF64F 0x76F6      MOVW     R6,#+65526
   \   000000BC   0x45B0             CMP      R8,R6
   \   000000BE   0xBF28             IT       CS 
   \   000000C0   0x2503             MOVCS    R5,#+3
   \   000000C2   0xD201             BCS.N    ??f_mkfs_11
   3621          
   3622            /* Determine offset and size of FAT structure */
   3623            if (fmt == FS_FAT32) {
   \   000000C4   0x2D03             CMP      R5,#+3
   \   000000C6   0xD109             BNE.N    ??f_mkfs_12
   3624              n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   \                     ??f_mkfs_11:
   \   000000C8   0xEA4F 0x0088      LSL      R0,R8,#+2
   \   000000CC   0xF200 0x2007      ADDW     R0,R0,#+519
   \   000000D0   0xEA4F 0x2950      LSR      R9,R0,#+9
   3625              n_rsv = 32;
   \   000000D4   0xF04F 0x0B20      MOV      R11,#+32
   3626              n_dir = 0;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xE011             B.N      ??f_mkfs_13
   3627            } else {
   3628              n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   \                     ??f_mkfs_12:
   \   000000DC   0x2D01             CMP      R5,#+1
   \   000000DE   0xD105             BNE.N    ??f_mkfs_14
   \   000000E0   0xEB08 0x0048      ADD      R0,R8,R8, LSL #+1
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0x0840             LSRS     R0,R0,#+1
   \   000000E8   0x1CC0             ADDS     R0,R0,#+3
   \   000000EA   0xE002             B.N      ??f_mkfs_15
   \                     ??f_mkfs_14:
   \   000000EC   0xEA4F 0x0048      LSL      R0,R8,#+1
   \   000000F0   0x1D00             ADDS     R0,R0,#+4
   3629              n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   \                     ??f_mkfs_15:
   \   000000F2   0xF200 0x10FF      ADDW     R0,R0,#+511
   \   000000F6   0xEA4F 0x2950      LSR      R9,R0,#+9
   3630              n_rsv = 1;
   \   000000FA   0xF04F 0x0B01      MOV      R11,#+1
   3631              n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   \   000000FE   0x2020             MOVS     R0,#+32
   \                     ??f_mkfs_13:
   \   00000100   0x9005             STR      R0,[SP, #+20]
   3632            }
   3633            b_fat = b_vol + n_rsv;        /* FAT area start sector */
   \   00000102   0x9802             LDR      R0,[SP, #+8]
   \   00000104   0x4458             ADD      R0,R11,R0
   \   00000106   0x9004             STR      R0,[SP, #+16]
   3634            b_dir = b_fat + n_fat * N_FATS;   /* Directory area start sector */
   3635            b_data = b_dir + n_dir;       /* Data area start sector */
   \   00000108   0x4448             ADD      R0,R9,R0
   \   0000010A   0x9905             LDR      R1,[SP, #+20]
   \   0000010C   0xEB01 0x0800      ADD      R8,R1,R0
   3636            if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;  /* Too small volume */
   \   00000110   0x9801             LDR      R0,[SP, #+4]
   \   00000112   0xEB04 0x0108      ADD      R1,R4,R8
   \   00000116   0x9A02             LDR      R2,[SP, #+8]
   \   00000118   0x1A89             SUBS     R1,R1,R2
   \   0000011A   0x4288             CMP      R0,R1
   \   0000011C   0xD331             BCC.N    ??f_mkfs_16
   3637          
   3638            /* Align data start sector to erase block boundary (for flash memory media) */
   3639            if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   \   0000011E   0xAA00             ADD      R2,SP,#+0
   \   00000120   0x2103             MOVS     R1,#+3
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x.... 0x....      BL       disk_ioctl
   \   00000128   0xB920             CBNZ.N   R0,??f_mkfs_17
   \   0000012A   0x9800             LDR      R0,[SP, #+0]
   \   0000012C   0xB110             CBZ.N    R0,??f_mkfs_17
   \   0000012E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000132   0xD901             BLS.N    ??f_mkfs_18
   \                     ??f_mkfs_17:
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0x9000             STR      R0,[SP, #+0]
   3640            n = (b_data + n - 1) & ~(n - 1);  /* Next nearest erase block from current data start */
   3641            n = (n - b_data) / N_FATS;
   \                     ??f_mkfs_18:
   \   00000138   0x9800             LDR      R0,[SP, #+0]
   \   0000013A   0x4440             ADD      R0,R0,R8
   \   0000013C   0x1E40             SUBS     R0,R0,#+1
   \   0000013E   0x9900             LDR      R1,[SP, #+0]
   \   00000140   0x1E49             SUBS     R1,R1,#+1
   \   00000142   0x4388             BICS     R0,R0,R1
   \   00000144   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000148   0x9000             STR      R0,[SP, #+0]
   3642            if (fmt == FS_FAT32) {    /* FAT32: Move FAT offset */
   \   0000014A   0x2D03             CMP      R5,#+3
   \   0000014C   0xD105             BNE.N    ??f_mkfs_19
   3643              n_rsv += n;
   \   0000014E   0x4483             ADD      R11,R0,R11
   3644              b_fat += n;
   \   00000150   0x9804             LDR      R0,[SP, #+16]
   \   00000152   0x9900             LDR      R1,[SP, #+0]
   \   00000154   0x1808             ADDS     R0,R1,R0
   \   00000156   0x9004             STR      R0,[SP, #+16]
   \   00000158   0xE000             B.N      ??f_mkfs_20
   3645            } else {          /* FAT12/16: Expand FAT size */
   3646              n_fat += n;
   \                     ??f_mkfs_19:
   \   0000015A   0x4481             ADD      R9,R0,R9
   3647            }
   3648          
   3649            /* Determine number of clusters and final check of validity of the FAT sub-type */
   3650            n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   \                     ??f_mkfs_20:
   \   0000015C   0x9801             LDR      R0,[SP, #+4]
   \   0000015E   0xEBA0 0x000B      SUB      R0,R0,R11
   \   00000162   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000166   0x9905             LDR      R1,[SP, #+20]
   \   00000168   0x1A40             SUBS     R0,R0,R1
   \   0000016A   0xFBB0 0xF8F4      UDIV     R8,R0,R4
   3651            if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   3652              || (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   \   0000016E   0x2D02             CMP      R5,#+2
   \   00000170   0xD103             BNE.N    ??f_mkfs_21
   \   00000172   0xF640 0x70F6      MOVW     R0,#+4086
   \   00000176   0x4580             CMP      R8,R0
   \   00000178   0xD303             BCC.N    ??f_mkfs_16
   \                     ??f_mkfs_21:
   \   0000017A   0x2D03             CMP      R5,#+3
   \   0000017C   0xD103             BNE.N    ??f_mkfs_22
   \   0000017E   0x45B0             CMP      R8,R6
   \   00000180   0xD201             BCS.N    ??f_mkfs_22
   3653              return FR_MKFS_ABORTED;
   \                     ??f_mkfs_16:
   \   00000182   0x200E             MOVS     R0,#+14
   \   00000184   0xE197             B.N      ??f_mkfs_1
   3654          
   3655            switch (fmt) {  /* Determine system ID for partition table */
   \                     ??f_mkfs_22:
   \   00000186   0x2D01             CMP      R5,#+1
   \   00000188   0xD002             BEQ.N    ??f_mkfs_23
   \   0000018A   0x2D02             CMP      R5,#+2
   \   0000018C   0xD002             BEQ.N    ??f_mkfs_24
   \   0000018E   0xE008             B.N      ??f_mkfs_25
   3656            case FS_FAT12:  sys = 0x01; break;
   \                     ??f_mkfs_23:
   \   00000190   0x2601             MOVS     R6,#+1
   \   00000192   0xE007             B.N      ??f_mkfs_26
   3657            case FS_FAT16:  sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
   \                     ??f_mkfs_24:
   \   00000194   0x9801             LDR      R0,[SP, #+4]
   \   00000196   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000019A   0xBF2C             ITE      CS 
   \   0000019C   0x2606             MOVCS    R6,#+6
   \   0000019E   0x2604             MOVCC    R6,#+4
   \   000001A0   0xE000             B.N      ??f_mkfs_26
   3658            default:    sys = 0x0C;
   \                     ??f_mkfs_25:
   \   000001A2   0x260C             MOVS     R6,#+12
   \                     ??f_mkfs_26:
   \   000001A4   0xB10F             CBZ.N    R7,??f_mkfs_27
   3659            }
   3660          
   3661            if (_MULTI_PARTITION && part) {
   3662              /* Update system ID in the partition table */
   3663              tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3664              tbl[4] = sys;
   3665              if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3666              md = 0xF8;
   3667            } else {
   3668              if (sfd) {  /* No patition table (SFD) */
   3669                md = 0xF0;
   \   000001A6   0x26F0             MOVS     R6,#+240
   \   000001A8   0xE046             B.N      ??f_mkfs_28
   3670              } else {  /* Create partition table (FDISK) */
   3671                mem_set(fs->win, 0, SS(fs));
   \                     ??f_mkfs_27:
   \   000001AA   0xF44F 0x7200      MOV      R2,#+512
   \   000001AE   0x2100             MOVS     R1,#+0
   \   000001B0   0x9803             LDR      R0,[SP, #+12]
   \   000001B2   0x3034             ADDS     R0,R0,#+52
   \   000001B4   0x.... 0x....      BL       mem_set
   3672                tbl = fs->win+MBR_Table;  /* Create partiton table for single partition in the drive */
   \   000001B8   0x9803             LDR      R0,[SP, #+12]
   \   000001BA   0xF200 0x17F2      ADDW     R7,R0,#+498
   3673                tbl[1] = 1;           /* Partition start head */
   \   000001BE   0x2001             MOVS     R0,#+1
   \   000001C0   0x7078             STRB     R0,[R7, #+1]
   3674                tbl[2] = 1;           /* Partition start sector */
   \   000001C2   0x70B8             STRB     R0,[R7, #+2]
   3675                tbl[3] = 0;           /* Partition start cylinder */
   \   000001C4   0x2000             MOVS     R0,#+0
   \   000001C6   0x70F8             STRB     R0,[R7, #+3]
   3676                tbl[4] = sys;         /* System type */
   \   000001C8   0x713E             STRB     R6,[R7, #+4]
   3677                tbl[5] = 254;         /* Partition end head */
   \   000001CA   0x20FE             MOVS     R0,#+254
   \   000001CC   0x7178             STRB     R0,[R7, #+5]
   3678                n = (b_vol + n_vol) / 63 / 255;
   \   000001CE   0x9802             LDR      R0,[SP, #+8]
   \   000001D0   0x9901             LDR      R1,[SP, #+4]
   \   000001D2   0x1808             ADDS     R0,R1,R0
   \   000001D4   0x213F             MOVS     R1,#+63
   \   000001D6   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001DA   0x21FF             MOVS     R1,#+255
   \   000001DC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000001E0   0x9000             STR      R0,[SP, #+0]
   3679                tbl[6] = (BYTE)((n >> 2) | 63); /* Partiiton end sector */
   \   000001E2   0x0880             LSRS     R0,R0,#+2
   \   000001E4   0xF040 0x003F      ORR      R0,R0,#0x3F
   \   000001E8   0x71B8             STRB     R0,[R7, #+6]
   3680                tbl[7] = (BYTE)n;       /* End cylinder */
   \   000001EA   0x9800             LDR      R0,[SP, #+0]
   \   000001EC   0x71F8             STRB     R0,[R7, #+7]
   3681                ST_DWORD(tbl+8, 63);      /* Partition start in LBA */
   \   000001EE   0x203F             MOVS     R0,#+63
   \   000001F0   0x7238             STRB     R0,[R7, #+8]
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0x7278             STRB     R0,[R7, #+9]
   \   000001F6   0x72B8             STRB     R0,[R7, #+10]
   \   000001F8   0x72F8             STRB     R0,[R7, #+11]
   3682                ST_DWORD(tbl+12, n_vol);    /* Partition size in LBA */
   \   000001FA   0x9801             LDR      R0,[SP, #+4]
   \   000001FC   0x7338             STRB     R0,[R7, #+12]
   \   000001FE   0x9801             LDR      R0,[SP, #+4]
   \   00000200   0x0400             LSLS     R0,R0,#+16
   \   00000202   0x0E00             LSRS     R0,R0,#+24
   \   00000204   0x7378             STRB     R0,[R7, #+13]
   \   00000206   0x9801             LDR      R0,[SP, #+4]
   \   00000208   0x0C00             LSRS     R0,R0,#+16
   \   0000020A   0x73B8             STRB     R0,[R7, #+14]
   \   0000020C   0x9801             LDR      R0,[SP, #+4]
   \   0000020E   0x0E00             LSRS     R0,R0,#+24
   \   00000210   0x73F8             STRB     R0,[R7, #+15]
   3683                ST_WORD(fs->win+BS_55AA, 0xAA55); /* MBR signature */
   \   00000212   0x9803             LDR      R0,[SP, #+12]
   \   00000214   0x2155             MOVS     R1,#+85
   \   00000216   0xF880 0x1232      STRB     R1,[R0, #+562]
   \   0000021A   0x9803             LDR      R0,[SP, #+12]
   \   0000021C   0x21AA             MOVS     R1,#+170
   \   0000021E   0xF880 0x1233      STRB     R1,[R0, #+563]
   3684                if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)  /* Write it to the MBR sector */
   \   00000222   0x2301             MOVS     R3,#+1
   \   00000224   0x2200             MOVS     R2,#+0
   \   00000226   0x9803             LDR      R0,[SP, #+12]
   \   00000228   0xF100 0x0134      ADD      R1,R0,#+52
   \   0000022C   0x.... 0x....      BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_11:
   \   00000230   0x2800             CMP      R0,#+0
   \   00000232   0xF040 0x813F      BNE.W    ??f_mkfs_6
   3685                  return FR_DISK_ERR;
   3686                md = 0xF8;
   \   00000236   0x26F8             MOVS     R6,#+248
   3687              }
   3688            }
   3689          
   3690            /* Create BPB in the VBR */
   3691            tbl = fs->win;              /* Clear sector */
   \                     ??f_mkfs_28:
   \   00000238   0x9803             LDR      R0,[SP, #+12]
   \   0000023A   0xF100 0x0734      ADD      R7,R0,#+52
   3692            mem_set(tbl, 0, SS(fs));
   \   0000023E   0x.... 0x....      BL       ?Subroutine10
   3693            mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   \                     ??CrossCallReturnLabel_33:
   \   00000242   0x220B             MOVS     R2,#+11
   \   00000244   0x.... 0x....      ADR.W    R1,`?<Constant "\\353\\376\\220MSDOS5.0">`
   \   00000248   0x4638             MOV      R0,R7
   \   0000024A   0x.... 0x....      BL       mem_cpy
   3694            i = SS(fs);               /* Sector size */
   \   0000024E   0xF44F 0x7A00      MOV      R10,#+512
   3695            ST_WORD(tbl+BPB_BytsPerSec, i);
   \   00000252   0x2000             MOVS     R0,#+0
   \   00000254   0x72F8             STRB     R0,[R7, #+11]
   \   00000256   0x2002             MOVS     R0,#+2
   \   00000258   0x7338             STRB     R0,[R7, #+12]
   3696            tbl[BPB_SecPerClus] = (BYTE)au;     /* Sectors per cluster */
   \   0000025A   0x737C             STRB     R4,[R7, #+13]
   3697            ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);   /* Reserved sectors */
   \   0000025C   0xF887 0xB00E      STRB     R11,[R7, #+14]
   \   00000260   0xEA4F 0x410B      LSL      R1,R11,#+16
   \   00000264   0x0E08             LSRS     R0,R1,#+24
   \   00000266   0x73F8             STRB     R0,[R7, #+15]
   3698            tbl[BPB_NumFATs] = N_FATS;        /* Number of FATs */
   \   00000268   0x2001             MOVS     R0,#+1
   \   0000026A   0x7438             STRB     R0,[R7, #+16]
   3699            i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;  /* Number of rootdir entries */
   \   0000026C   0x2D03             CMP      R5,#+3
   \   0000026E   0xBF08             IT       EQ 
   \   00000270   0xF04F 0x0A00      MOVEQ    R10,#+0
   3700            ST_WORD(tbl+BPB_RootEntCnt, i);
   \   00000274   0x2000             MOVS     R0,#+0
   \   00000276   0x7478             STRB     R0,[R7, #+17]
   \   00000278   0xEA4F 0x201A      LSR      R0,R10,#+8
   \   0000027C   0x74B8             STRB     R0,[R7, #+18]
   3701            if (n_vol < 0x10000) {          /* Number of total sectors */
   \   0000027E   0x9801             LDR      R0,[SP, #+4]
   \   00000280   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000284   0xD205             BCS.N    ??f_mkfs_29
   3702              ST_WORD(tbl+BPB_TotSec16, n_vol);
   \   00000286   0x74F8             STRB     R0,[R7, #+19]
   \   00000288   0x9801             LDR      R0,[SP, #+4]
   \   0000028A   0x0400             LSLS     R0,R0,#+16
   \   0000028C   0x0E00             LSRS     R0,R0,#+24
   \   0000028E   0x7538             STRB     R0,[R7, #+20]
   \   00000290   0xE00E             B.N      ??f_mkfs_30
   3703            } else {
   3704              ST_DWORD(tbl+BPB_TotSec32, n_vol);
   \                     ??f_mkfs_29:
   \   00000292   0xF887 0x0020      STRB     R0,[R7, #+32]
   \   00000296   0x9801             LDR      R0,[SP, #+4]
   \   00000298   0x0400             LSLS     R0,R0,#+16
   \   0000029A   0x0E00             LSRS     R0,R0,#+24
   \   0000029C   0xF887 0x0021      STRB     R0,[R7, #+33]
   \   000002A0   0x9801             LDR      R0,[SP, #+4]
   \   000002A2   0x0C00             LSRS     R0,R0,#+16
   \   000002A4   0xF887 0x0022      STRB     R0,[R7, #+34]
   \   000002A8   0x9801             LDR      R0,[SP, #+4]
   \   000002AA   0x0E00             LSRS     R0,R0,#+24
   \   000002AC   0xF887 0x0023      STRB     R0,[R7, #+35]
   3705            }
   3706            tbl[BPB_Media] = md;          /* Media descriptor */
   \                     ??f_mkfs_30:
   \   000002B0   0x757E             STRB     R6,[R7, #+21]
   3707            ST_WORD(tbl+BPB_SecPerTrk, 63);     /* Number of sectors per track */
   \   000002B2   0x203F             MOVS     R0,#+63
   \   000002B4   0x7638             STRB     R0,[R7, #+24]
   \   000002B6   0x2000             MOVS     R0,#+0
   \   000002B8   0x7678             STRB     R0,[R7, #+25]
   3708            ST_WORD(tbl+BPB_NumHeads, 255);     /* Number of heads */
   \   000002BA   0x20FF             MOVS     R0,#+255
   \   000002BC   0x76B8             STRB     R0,[R7, #+26]
   \   000002BE   0x2000             MOVS     R0,#+0
   \   000002C0   0x76F8             STRB     R0,[R7, #+27]
   3709            ST_DWORD(tbl+BPB_HiddSec, b_vol);   /* Hidden sectors */
   \   000002C2   0x9802             LDR      R0,[SP, #+8]
   \   000002C4   0x7738             STRB     R0,[R7, #+28]
   \   000002C6   0x2000             MOVS     R0,#+0
   \   000002C8   0x7778             STRB     R0,[R7, #+29]
   \   000002CA   0x77B8             STRB     R0,[R7, #+30]
   \   000002CC   0x77F8             STRB     R0,[R7, #+31]
   3710            n = get_fattime();            /* Use current time as VSN */
   \   000002CE   0x.... 0x....      BL       get_fattime
   \   000002D2   0x9000             STR      R0,[SP, #+0]
   3711            if (fmt == FS_FAT32) {
   \   000002D4   0xEA4F 0x4009      LSL      R0,R9,#+16
   \   000002D8   0x0E00             LSRS     R0,R0,#+24
   \   000002DA   0x2D03             CMP      R5,#+3
   \   000002DC   0x9900             LDR      R1,[SP, #+0]
   \   000002DE   0xD13C             BNE.N    ??f_mkfs_31
   3712              ST_DWORD(tbl+BS_VolID32, n);    /* VSN */
   \   000002E0   0xF887 0x1043      STRB     R1,[R7, #+67]
   \   000002E4   0x9900             LDR      R1,[SP, #+0]
   \   000002E6   0x0409             LSLS     R1,R1,#+16
   \   000002E8   0x0E09             LSRS     R1,R1,#+24
   \   000002EA   0xF887 0x1044      STRB     R1,[R7, #+68]
   \   000002EE   0x9900             LDR      R1,[SP, #+0]
   \   000002F0   0x0C09             LSRS     R1,R1,#+16
   \   000002F2   0xF887 0x1045      STRB     R1,[R7, #+69]
   \   000002F6   0x9900             LDR      R1,[SP, #+0]
   \   000002F8   0x0E09             LSRS     R1,R1,#+24
   \   000002FA   0xF887 0x1046      STRB     R1,[R7, #+70]
   3713              ST_DWORD(tbl+BPB_FATSz32, n_fat); /* Number of sectors per FAT */
   \   000002FE   0xF887 0x9024      STRB     R9,[R7, #+36]
   \   00000302   0xF887 0x0025      STRB     R0,[R7, #+37]
   \   00000306   0xEA4F 0x4019      LSR      R0,R9,#+16
   \   0000030A   0xF887 0x0026      STRB     R0,[R7, #+38]
   \   0000030E   0xEA4F 0x6019      LSR      R0,R9,#+24
   \   00000312   0xF887 0x0027      STRB     R0,[R7, #+39]
   3714              ST_DWORD(tbl+BPB_RootClus, 2);    /* Root directory start cluster (2) */
   \   00000316   0x2002             MOVS     R0,#+2
   \   00000318   0xF887 0x002C      STRB     R0,[R7, #+44]
   \   0000031C   0x2000             MOVS     R0,#+0
   \   0000031E   0xF887 0x002D      STRB     R0,[R7, #+45]
   \   00000322   0xF887 0x002E      STRB     R0,[R7, #+46]
   \   00000326   0xF887 0x002F      STRB     R0,[R7, #+47]
   3715              ST_WORD(tbl+BPB_FSInfo, 1);     /* FSInfo record offset (VBR+1) */
   \   0000032A   0x2001             MOVS     R0,#+1
   \   0000032C   0xF887 0x0030      STRB     R0,[R7, #+48]
   \   00000330   0x2000             MOVS     R0,#+0
   \   00000332   0xF887 0x0031      STRB     R0,[R7, #+49]
   3716              ST_WORD(tbl+BPB_BkBootSec, 6);    /* Backup boot record offset (VBR+6) */
   \   00000336   0x2006             MOVS     R0,#+6
   \   00000338   0xF887 0x0032      STRB     R0,[R7, #+50]
   \   0000033C   0x2000             MOVS     R0,#+0
   \   0000033E   0xF887 0x0033      STRB     R0,[R7, #+51]
   3717              tbl[BS_DrvNum32] = 0x80;      /* Drive number */
   \   00000342   0x2080             MOVS     R0,#+128
   \   00000344   0xF887 0x0040      STRB     R0,[R7, #+64]
   3718              tbl[BS_BootSig32] = 0x29;     /* Extended boot signature */
   \   00000348   0x2029             MOVS     R0,#+41
   \   0000034A   0xF887 0x0042      STRB     R0,[R7, #+66]
   3719              mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19); /* Volume label, FAT signature */
   \   0000034E   0x2213             MOVS     R2,#+19
   \   00000350   0x.... 0x....      ADR.W    R1,`?<Constant "NO NAME    FAT32   ">`
   \   00000354   0xF107 0x0047      ADD      R0,R7,#+71
   \   00000358   0xE01C             B.N      ??f_mkfs_32
   3720            } else {
   3721              ST_DWORD(tbl+BS_VolID, n);      /* VSN */
   \                     ??f_mkfs_31:
   \   0000035A   0xF887 0x1027      STRB     R1,[R7, #+39]
   \   0000035E   0x9900             LDR      R1,[SP, #+0]
   \   00000360   0x0409             LSLS     R1,R1,#+16
   \   00000362   0x0E09             LSRS     R1,R1,#+24
   \   00000364   0xF887 0x1028      STRB     R1,[R7, #+40]
   \   00000368   0x9900             LDR      R1,[SP, #+0]
   \   0000036A   0x0C09             LSRS     R1,R1,#+16
   \   0000036C   0xF887 0x1029      STRB     R1,[R7, #+41]
   \   00000370   0x9900             LDR      R1,[SP, #+0]
   \   00000372   0x0E09             LSRS     R1,R1,#+24
   \   00000374   0xF887 0x102A      STRB     R1,[R7, #+42]
   3722              ST_WORD(tbl+BPB_FATSz16, n_fat);  /* Number of sectors per FAT */
   \   00000378   0xF887 0x9016      STRB     R9,[R7, #+22]
   \   0000037C   0x75F8             STRB     R0,[R7, #+23]
   3723              tbl[BS_DrvNum] = 0x80;        /* Drive number */
   \   0000037E   0x2080             MOVS     R0,#+128
   \   00000380   0xF887 0x0024      STRB     R0,[R7, #+36]
   3724              tbl[BS_BootSig] = 0x29;       /* Extended boot signature */
   \   00000384   0x2029             MOVS     R0,#+41
   \   00000386   0xF887 0x0026      STRB     R0,[R7, #+38]
   3725              mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19); /* Volume label, FAT signature */
   \   0000038A   0x2213             MOVS     R2,#+19
   \   0000038C   0x.... 0x....      ADR.W    R1,`?<Constant "NO NAME    FAT     ">`
   \   00000390   0xF107 0x002B      ADD      R0,R7,#+43
   \                     ??f_mkfs_32:
   \   00000394   0x.... 0x....      BL       mem_cpy
   3726            }
   3727            ST_WORD(tbl+BS_55AA, 0xAA55);     /* Signature (Offset is fixed here regardless of sector size) */
   \   00000398   0x.... 0x....      BL       ?Subroutine15
   3728            if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)  /* Write it to the VBR sector */
   \                     ??CrossCallReturnLabel_54:
   \   0000039C   0x9A02             LDR      R2,[SP, #+8]
   \   0000039E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_16:
   \   000003A2   0x2800             CMP      R0,#+0
   \   000003A4   0xD12A             BNE.N    ??f_mkfs_33
   3729              return FR_DISK_ERR;
   3730            if (fmt == FS_FAT32)              /* Write backup VBR if needed (VBR+6) */
   \   000003A6   0x2D03             CMP      R5,#+3
   \   000003A8   0xD104             BNE.N    ??CrossCallReturnLabel_15
   3731              disk_write(pdrv, tbl, b_vol + 6, 1);
   \   000003AA   0x2301             MOVS     R3,#+1
   \   000003AC   0x9802             LDR      R0,[SP, #+8]
   \   000003AE   0x1D82             ADDS     R2,R0,#+6
   \   000003B0   0x.... 0x....      BL       ?Subroutine5
   3732          
   3733            /* Initialize FAT area */
   3734            wsect = b_fat;
   \                     ??CrossCallReturnLabel_15:
   \   000003B4   0xF8DD 0xA010      LDR      R10,[SP, #+16]
   3735            for (i = 0; i < N_FATS; i++) {    /* Initialize each FAT copy */
   3736              mem_set(tbl, 0, SS(fs));      /* 1st sector of the FAT  */
   \   000003B8   0x.... 0x....      BL       ?Subroutine10
   3737              n = md;               /* Media descriptor byte */
   3738              if (fmt != FS_FAT32) {
   \                     ??CrossCallReturnLabel_32:
   \   000003BC   0x2D03             CMP      R5,#+3
   \   000003BE   0xD008             BEQ.N    ??f_mkfs_34
   3739                n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   \   000003C0   0x2D01             CMP      R5,#+1
   \   000003C2   0xBF0C             ITE      EQ 
   \   000003C4   0x....             LDREQ.N  R0,??DataTable11_1  ;; 0xffff00
   \   000003C6   0xF06F 0x00FF      MVNNE    R0,#+255
   \   000003CA   0x4330             ORRS     R0,R0,R6
   \   000003CC   0x.... 0x....      BL       ?Subroutine13
   3740                ST_DWORD(tbl+0, n);       /* Reserve cluster #0-1 (FAT12/16) */
   3741              } else {
   \                     ??CrossCallReturnLabel_50:
   \   000003D0   0xE00D             B.N      ??f_mkfs_35
   3742                n |= 0xFFFFFF00;
   \                     ??f_mkfs_34:
   \   000003D2   0xF066 0x00FF      ORN      R0,R6,#+255
   \   000003D6   0x.... 0x....      BL       ?Subroutine13
   3743                ST_DWORD(tbl+0, n);       /* Reserve cluster #0-1 (FAT32) */
   3744                ST_DWORD(tbl+4, 0xFFFFFFFF);
   \                     ??CrossCallReturnLabel_51:
   \   000003DA   0x20FF             MOVS     R0,#+255
   \   000003DC   0x7138             STRB     R0,[R7, #+4]
   \   000003DE   0x7178             STRB     R0,[R7, #+5]
   \   000003E0   0x71B8             STRB     R0,[R7, #+6]
   \   000003E2   0x71F8             STRB     R0,[R7, #+7]
   3745                ST_DWORD(tbl+8, 0x0FFFFFFF);  /* Reserve cluster #2 for root dir */
   \   000003E4   0x7238             STRB     R0,[R7, #+8]
   \   000003E6   0x7278             STRB     R0,[R7, #+9]
   \   000003E8   0x72B8             STRB     R0,[R7, #+10]
   \   000003EA   0x200F             MOVS     R0,#+15
   \   000003EC   0x72F8             STRB     R0,[R7, #+11]
   3746              }
   3747              if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_35:
   \   000003EE   0x2301             MOVS     R3,#+1
   \   000003F0   0x4652             MOV      R2,R10
   \   000003F2   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_14:
   \   000003F6   0xF10A 0x0601      ADD      R6,R10,#+1
   \   000003FA   0x2800             CMP      R0,#+0
   \                     ??f_mkfs_33:
   \   000003FC   0xD15A             BNE.N    ??f_mkfs_6
   3748                return FR_DISK_ERR;
   3749              mem_set(tbl, 0, SS(fs));      /* Fill following FAT entries with zero */
   \   000003FE   0x.... 0x....      BL       ?Subroutine10
   3750              for (n = 1; n < n_fat; n++) {   /* This loop may take a time on FAT32 volume due to many single sector writes */
   \                     ??CrossCallReturnLabel_31:
   \   00000402   0x2001             MOVS     R0,#+1
   \   00000404   0xE006             B.N      ??f_mkfs_36
   3751                if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_37:
   \   00000406   0x.... 0x....      BL       ?Subroutine2
   3752                  return FR_DISK_ERR;
   3753              }
   \                     ??CrossCallReturnLabel_6:
   \   0000040A   0x1C76             ADDS     R6,R6,#+1
   \   0000040C   0x2800             CMP      R0,#+0
   \   0000040E   0xD151             BNE.N    ??f_mkfs_6
   \   00000410   0x9800             LDR      R0,[SP, #+0]
   \   00000412   0x1C40             ADDS     R0,R0,#+1
   \                     ??f_mkfs_36:
   \   00000414   0x9000             STR      R0,[SP, #+0]
   \   00000416   0x9800             LDR      R0,[SP, #+0]
   \   00000418   0x4548             CMP      R0,R9
   \   0000041A   0xD3F4             BCC.N    ??f_mkfs_37
   3754            }
   3755          
   3756            /* Initialize root directory */
   3757            i = (fmt == FS_FAT32) ? au : n_dir;
   \   0000041C   0x2D03             CMP      R5,#+3
   \   0000041E   0xBF0C             ITE      EQ 
   \   00000420   0x46A2             MOVEQ    R10,R4
   \   00000422   0xF8DD 0xA014      LDRNE    R10,[SP, #+20]
   3758            do {
   3759              if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   \                     ??f_mkfs_38:
   \   00000426   0x.... 0x....      BL       ?Subroutine2
   3760                return FR_DISK_ERR;
   3761            } while (--i);
   \                     ??CrossCallReturnLabel_5:
   \   0000042A   0x1C76             ADDS     R6,R6,#+1
   \   0000042C   0x2800             CMP      R0,#+0
   \   0000042E   0xD141             BNE.N    ??f_mkfs_6
   \   00000430   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000434   0xD1F7             BNE.N    ??f_mkfs_38
   3762          
   3763          #if _USE_ERASE  /* Erase data area if needed */
   3764            {
   3765              DWORD eb[2];
   3766          
   3767              eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   3768              disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
   3769            }
   3770          #endif
   3771          
   3772            /* Create FSInfo if needed */
   3773            if (fmt == FS_FAT32) {
   \   00000436   0x2D03             CMP      R5,#+3
   \   00000438   0xD136             BNE.N    ??CrossCallReturnLabel_12
   3774              ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   \   0000043A   0x2052             MOVS     R0,#+82
   \   0000043C   0x7038             STRB     R0,[R7, #+0]
   \   0000043E   0x7078             STRB     R0,[R7, #+1]
   \   00000440   0x2061             MOVS     R0,#+97
   \   00000442   0x70B8             STRB     R0,[R7, #+2]
   \   00000444   0x2041             MOVS     R0,#+65
   \   00000446   0x70F8             STRB     R0,[R7, #+3]
   3775              ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   \   00000448   0x2072             MOVS     R0,#+114
   \   0000044A   0xF887 0x01E4      STRB     R0,[R7, #+484]
   \   0000044E   0xF887 0x01E5      STRB     R0,[R7, #+485]
   \   00000452   0x2041             MOVS     R0,#+65
   \   00000454   0xF887 0x01E6      STRB     R0,[R7, #+486]
   \   00000458   0x2061             MOVS     R0,#+97
   \   0000045A   0xF887 0x01E7      STRB     R0,[R7, #+487]
   3776              ST_DWORD(tbl+FSI_Free_Count, n_clst - 1); /* Number of free clusters */
   \   0000045E   0xF1A8 0x0001      SUB      R0,R8,#+1
   \   00000462   0xF887 0x01E8      STRB     R0,[R7, #+488]
   \   00000466   0x0400             LSLS     R0,R0,#+16
   \   00000468   0x0E00             LSRS     R0,R0,#+24
   \   0000046A   0xF887 0x01E9      STRB     R0,[R7, #+489]
   \   0000046E   0xF1A8 0x0001      SUB      R0,R8,#+1
   \   00000472   0x0C01             LSRS     R1,R0,#+16
   \   00000474   0xF887 0x11EA      STRB     R1,[R7, #+490]
   \   00000478   0x0E00             LSRS     R0,R0,#+24
   \   0000047A   0xF887 0x01EB      STRB     R0,[R7, #+491]
   3777              ST_DWORD(tbl+FSI_Nxt_Free, 2);        /* Last allocated cluster# */
   \   0000047E   0x2002             MOVS     R0,#+2
   \   00000480   0xF887 0x01EC      STRB     R0,[R7, #+492]
   \   00000484   0x2000             MOVS     R0,#+0
   \   00000486   0xF887 0x01ED      STRB     R0,[R7, #+493]
   \   0000048A   0xF887 0x01EE      STRB     R0,[R7, #+494]
   \   0000048E   0xF887 0x01EF      STRB     R0,[R7, #+495]
   3778              ST_WORD(tbl+BS_55AA, 0xAA55);
   \   00000492   0x.... 0x....      BL       ?Subroutine15
   3779              disk_write(pdrv, tbl, b_vol + 1, 1);  /* Write original (VBR+1) */
   \                     ??CrossCallReturnLabel_55:
   \   00000496   0x9802             LDR      R0,[SP, #+8]
   \   00000498   0x1C42             ADDS     R2,R0,#+1
   \   0000049A   0x.... 0x....      BL       ?Subroutine5
   3780              disk_write(pdrv, tbl, b_vol + 7, 1);  /* Write backup (VBR+7) */
   \                     ??CrossCallReturnLabel_13:
   \   0000049E   0x2301             MOVS     R3,#+1
   \   000004A0   0x9802             LDR      R0,[SP, #+8]
   \   000004A2   0x1DC2             ADDS     R2,R0,#+7
   \   000004A4   0x.... 0x....      BL       ?Subroutine5
   3781            }
   3782          
   3783            return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   \                     ??CrossCallReturnLabel_12:
   \   000004A8   0x2200             MOVS     R2,#+0
   \   000004AA   0x2100             MOVS     R1,#+0
   \   000004AC   0x4608             MOV      R0,R1
   \   000004AE   0x.... 0x....      BL       disk_ioctl
   \   000004B2   0xB100             CBZ.N    R0,??f_mkfs_1
   \                     ??f_mkfs_6:
   \   000004B4   0x2001             MOVS     R0,#+1
   \                     ??f_mkfs_1:
   \   000004B6   0xB007             ADD      SP,SP,#+28
   \   000004B8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3784          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15:
   \   00000000   0x2055             MOVS     R0,#+85
   \   00000002   0xF887 0x01FE      STRB     R0,[R7, #+510]
   \   00000006   0x20AA             MOVS     R0,#+170
   \   00000008   0xF887 0x01FF      STRB     R0,[R7, #+511]
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13:
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x9800             LDR      R0,[SP, #+0]
   \   00000004   0x7038             STRB     R0,[R7, #+0]
   \   00000006   0x9800             LDR      R0,[SP, #+0]
   \   00000008   0x0400             LSLS     R0,R0,#+16
   \   0000000A   0x0E00             LSRS     R0,R0,#+24
   \   0000000C   0x7078             STRB     R0,[R7, #+1]
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0x0C00             LSRS     R0,R0,#+16
   \   00000012   0x70B8             STRB     R0,[R7, #+2]
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x0E00             LSRS     R0,R0,#+24
   \   00000018   0x70F8             STRB     R0,[R7, #+3]
   \   0000001A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10:
   \   00000000   0xF44F 0x7200      MOV      R2,#+512
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x4638             MOV      R0,R7
   \   00000008   0x.... 0x....      B.W      mem_set

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0x4639             MOV      R1,R7
   \                     ??Subroutine5_0:
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      B.W      disk_write

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x4632             MOV      R2,R6
   \   00000004   0x4639             MOV      R1,R7
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      B.W      disk_write

   \                                 In section .text, align 4, keep-with-next
   \                     ??vst:
   \   00000000   0x0400 0x0200      DC16 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 0
   \              0x0100 0x0080
   \              0x0040 0x0020
   \              0x0010 0x0008
   \              0x0004 0x0002
   \              0x0000       
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??cst:
   \   00000000   0x8000 0x4000      DC16 32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512
   \              0x2000 0x1000
   \              0x0800 0x4000
   \              0x2000 0x1000
   \              0x0800 0x0400
   \              0x0200       
   \   00000016   0x00 0x00          DC8 0, 0
   3785          
   3786          
   3787          #if _MULTI_PARTITION == 2
   3788          /*-----------------------------------------------------------------------*/
   3789          /* Divide Physical Drive                                                 */
   3790          /*-----------------------------------------------------------------------*/
   3791          
   3792          FRESULT f_fdisk (
   3793            BYTE pdrv,      /* Physical drive number */
   3794            const DWORD szt[],  /* Pointer to the size table for each partitions */
   3795            void* work      /* Pointer to the working buffer */
   3796          )
   3797          {
   3798            UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   3799            BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   3800            DSTATUS stat;
   3801            DWORD sz_disk, sz_part, s_part;
   3802          
   3803          
   3804            stat = disk_initialize(pdrv);
   3805            if (stat & STA_NOINIT) return FR_NOT_READY;
   3806            if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3807            if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   3808          
   3809            /* Determine CHS in the table regardless of the drive geometry */
   3810            for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   3811            if (n == 256) n--;
   3812            e_hd = n - 1;
   3813            sz_cyl = 63 * n;
   3814            tot_cyl = sz_disk / sz_cyl;
   3815          
   3816            /* Create partition table */
   3817            mem_set(buf, 0, _MAX_SS);
   3818            p = buf + MBR_Table; b_cyl = 0;
   3819            for (i = 0; i < 4; i++, p += SZ_PTE) {
   3820              p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   3821              if (!p_cyl) continue;
   3822              s_part = (DWORD)sz_cyl * b_cyl;
   3823              sz_part = (DWORD)sz_cyl * p_cyl;
   3824              if (i == 0) { /* Exclude first track of cylinder 0 */
   3825                s_hd = 1;
   3826                s_part += 63; sz_part -= 63;
   3827              } else {
   3828                s_hd = 0;
   3829              }
   3830              e_cyl = b_cyl + p_cyl - 1;
   3831              if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   3832          
   3833              /* Set partition table */
   3834              p[1] = s_hd;            /* Start head */
   3835              p[2] = (BYTE)((b_cyl >> 2) + 1);  /* Start sector */
   3836              p[3] = (BYTE)b_cyl;         /* Start cylinder */
   3837              p[4] = 0x06;            /* System type (temporary setting) */
   3838              p[5] = e_hd;            /* End head */
   3839              p[6] = (BYTE)((e_cyl >> 2) + 63); /* End sector */
   3840              p[7] = (BYTE)e_cyl;         /* End cylinder */
   3841              ST_DWORD(p + 8, s_part);      /* Start sector in LBA */
   3842              ST_DWORD(p + 12, sz_part);      /* Partition size */
   3843          
   3844              /* Next partition */
   3845              b_cyl += p_cyl;
   3846            }
   3847            ST_WORD(p, 0xAA55);
   3848          
   3849            /* Write it to the MBR */
   3850            return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
   3851          }
   3852          
   3853          
   3854          #endif /* _MULTI_PARTITION == 2 */
   3855          #endif /* _USE_MKFS && !_FS_READONLY */
   3856          
   3857          
   3858          
   3859          
   3860          #if _USE_STRFUNC
   3861          /*-----------------------------------------------------------------------*/
   3862          /* Get a string from the file                                            */
   3863          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3864          TCHAR* f_gets (
   3865            TCHAR* buff,  /* Pointer to the string buffer to read */
   3866            int len,    /* Size of string buffer (characters) */
   3867            FIL* fil    /* Pointer to the file object */
   3868          )
   3869          {
   \                     f_gets:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   3870            int n = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
   3871            TCHAR c, *p = buff;
   \   0000000C   0x4626             MOV      R6,R4
   3872            BYTE s[2];
   3873            UINT rc;
   3874          
   3875          
   3876            while (n < len - 1) {     /* Read bytes until buffer gets filled */
   \                     ??f_gets_0:
   \   0000000E   0x1E78             SUBS     R0,R7,#+1
   \   00000010   0x4285             CMP      R5,R0
   \   00000012   0xDA0F             BGE.N    ??f_gets_1
   3877              f_read(fil, s, 1, &rc);
   \   00000014   0xAB00             ADD      R3,SP,#+0
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       f_read
   3878              if (rc != 1) break;     /* Break on EOF or error */
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD106             BNE.N    ??f_gets_1
   3879              c = s[0];
   \   00000026   0xF99D 0x0004      LDRSB    R0,[SP, #+4]
   3880          #if _LFN_UNICODE          /* Read a character in UTF-8 encoding */
   3881              if (c >= 0x80) {
   3882                if (c < 0xC0) continue; /* Skip stray trailer */
   3883                if (c < 0xE0) {     /* Two-byte sequense */
   3884                  f_read(fil, s, 1, &rc);
   3885                  if (rc != 1) break;
   3886                  c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   3887                  if (c < 0x80) c = '?';
   3888                } else {
   3889                  if (c < 0xF0) {   /* Three-byte sequense */
   3890                    f_read(fil, s, 2, &rc);
   3891                    if (rc != 2) break;
   3892                    c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   3893                    if (c < 0x800) c = '?';
   3894                  } else {      /* Reject four-byte sequense */
   3895                    c = '?';
   3896                  }
   3897                }
   3898              }
   3899          #endif
   3900          #if _USE_STRFUNC >= 2
   3901              if (c == '\r') continue;  /* Strip '\r' */
   3902          #endif
   3903              *p++ = c;
   \   0000002A   0xF806 0x0B01      STRB     R0,[R6], #+1
   3904              n++;
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   3905              if (c == '\n') break;   /* Break on EOL */
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xD1EC             BNE.N    ??f_gets_0
   3906            }
   3907            *p = 0;
   \                     ??f_gets_1:
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7030             STRB     R0,[R6, #+0]
   3908            return n ? buff : 0;      /* When no data read (eof or error), return with error. */
   \   00000038   0xB905             CBNZ.N   R5,??f_gets_2
   \   0000003A   0x2400             MOVS     R4,#+0
   \                     ??f_gets_2:
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   3909          }
   3910          
   3911          
   3912          
   3913          #if !_FS_READONLY
   3914          #include <stdarg.h>
   3915          /*-----------------------------------------------------------------------*/
   3916          /* Put a character to the file                                           */
   3917          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3918          int f_putc (
   3919            TCHAR c,  /* A character to be output */
   3920            FIL* fil  /* Pointer to the file object */
   3921          )
   3922          {
   \                     f_putc:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4602             MOV      R2,R0
   \   00000006   0x4608             MOV      R0,R1
   3923            UINT bw, btw;
   3924            BYTE s[3];
   3925          
   3926          
   3927          #if _USE_STRFUNC >= 2
   3928            if (c == '\n') f_putc ('\r', fil);  /* LF -> CRLF conversion */
   3929          #endif
   3930          
   3931          #if _LFN_UNICODE  /* Write the character in UTF-8 encoding */
   3932            if (c < 0x80) {     /* 7-bit */
   3933              s[0] = (BYTE)c;
   3934              btw = 1;
   3935            } else {
   3936              if (c < 0x800) {  /* 11-bit */
   3937                s[0] = (BYTE)(0xC0 | (c >> 6));
   3938                s[1] = (BYTE)(0x80 | (c & 0x3F));
   3939                btw = 2;
   3940              } else {      /* 16-bit */
   3941                s[0] = (BYTE)(0xE0 | (c >> 12));
   3942                s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
   3943                s[2] = (BYTE)(0x80 | (c & 0x3F));
   3944                btw = 3;
   3945              }
   3946            }
   3947          #else       /* Write the character without conversion */
   3948            s[0] = (BYTE)c;
   \   00000008   0xF88D 0x2000      STRB     R2,[SP, #+0]
   3949            btw = 1;
   3950          #endif
   3951            f_write(fil, s, btw, &bw);    /* Write the char to the file */
   \   0000000C   0xAB01             ADD      R3,SP,#+4
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x.... 0x....      BL       f_write
   3952            return (bw == btw) ? 1 : EOF; /* Return the result */
   \   00000016   0x9801             LDR      R0,[SP, #+4]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0xF04F 0x30FF      MOVNE    R0,#-1
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
   3953          }
   3954          
   3955          
   3956          
   3957          
   3958          /*-----------------------------------------------------------------------*/
   3959          /* Put a string to the file                                              */
   3960          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3961          int f_puts (
   3962            const TCHAR* str, /* Pointer to the string to be output */
   3963            FIL* fil      /* Pointer to the file object */
   3964          )
   3965          {
   \                     f_puts:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3966            int n;
   3967          
   3968          
   3969            for (n = 0; *str; str++, n++) {
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE000             B.N      ??f_puts_0
   \                     ??f_puts_1:
   \   0000000A   0x1C76             ADDS     R6,R6,#+1
   \                     ??f_puts_0:
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0xB150             CBZ.N    R0,??f_puts_2
   3970              if (f_putc(*str, fil) == EOF) return EOF;
   \   00000012   0x4629             MOV      R1,R5
   \   00000014   0xF914 0x0B01      LDRSB    R0,[R4], #+1
   \   00000018   0x.... 0x....      BL       f_putc
   \   0000001C   0xF110 0x0F01      CMN      R0,#+1
   \   00000020   0xD1F3             BNE.N    ??f_puts_1
   \   00000022   0xF04F 0x30FF      MOV      R0,#-1
   \   00000026   0xBD70             POP      {R4-R6,PC}
   3971            }
   3972            return n;
   \                     ??f_puts_2:
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
   3973          }
   3974          
   3975          
   3976          
   3977          
   3978          /*-----------------------------------------------------------------------*/
   3979          /* Put a formatted string to the file                                    */
   3980          /*-----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3981          int f_printf (
   3982            FIL* fil,     /* Pointer to the file object */
   3983            const TCHAR* str, /* Pointer to the format string */
   3984            ...         /* Optional arguments... */
   3985          )
   3986          {
   \                     f_printf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000006   0xB085             SUB      SP,SP,#+20
   \   00000008   0x4681             MOV      R9,R0
   \   0000000A   0x468A             MOV      R10,R1
   3987            va_list arp;
   3988            BYTE f, r;
   3989            UINT i, j, w;
   3990            ULONG v;
   3991            TCHAR c, d, s[16], *p;
   3992            int res, chc, cc;
   3993          
   3994          
   3995            va_start(arp, str);
   \   0000000C   0xF10D 0x0B38      ADD      R11,SP,#+56
   3996          
   3997            for (cc = res = 0; cc != EOF; res += cc) {
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE006             B.N      ??f_printf_0
   3998              c = *str++;
   3999              if (c == 0) break;      /* End of string */
   4000              if (c != '%') {       /* Non escape character */
   4001                cc = f_putc(c, fil);
   4002                if (cc != EOF) cc = 1;
   \                     ??f_printf_1:
   \   00000014   0x4649             MOV      R1,R9
   \   00000016   0x.... 0x....      BL       f_putc
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD060             BEQ.N    ??f_printf_2
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   4003                continue;
   4004              }
   \                     ??f_printf_0:
   \   00000022   0xF91A 0x0B01      LDRSB    R0,[R10], #+1
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD020             BEQ.N    ??f_printf_3
   \   0000002A   0x2825             CMP      R0,#+37
   \   0000002C   0xD1F2             BNE.N    ??f_printf_1
   4005              w = f = 0;
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x4688             MOV      R8,R1
   4006              c = *str++;
   \   00000032   0xF91A 0x0B01      LDRSB    R0,[R10], #+1
   4007              if (c == '0') {       /* Flag: '0' padding */
   \   00000036   0x2830             CMP      R0,#+48
   \   00000038   0xBF08             IT       EQ 
   \   0000003A   0x2101             MOVEQ    R1,#+1
   4008                f = 1; c = *str++;
   \   0000003C   0xD008             BEQ.N    ??f_printf_4
   4009              } else {
   4010                if (c == '-') {     /* Flag: left justified */
   \   0000003E   0x282D             CMP      R0,#+45
   \   00000040   0xD108             BNE.N    ??f_printf_5
   4011                  f = 2; c = *str++;
   \   00000042   0x2102             MOVS     R1,#+2
   \   00000044   0xE004             B.N      ??f_printf_4
   4012                }
   4013              }
   4014              while (IsDigit(c)) {    /* Precision */
   4015                w = w * 10 + c - '0';
   \                     ??f_printf_6:
   \   00000046   0x220A             MOVS     R2,#+10
   \   00000048   0xFB02 0x0008      MLA      R0,R2,R8,R0
   \   0000004C   0xF1A0 0x0830      SUB      R8,R0,#+48
   4016                c = *str++;
   \                     ??f_printf_4:
   \   00000050   0xF91A 0x0B01      LDRSB    R0,[R10], #+1
   4017              }
   \                     ??f_printf_5:
   \   00000054   0xF1A0 0x0230      SUB      R2,R0,#+48
   \   00000058   0x2A0A             CMP      R2,#+10
   \   0000005A   0xD3F4             BCC.N    ??f_printf_6
   4018              if (c == 'l' || c == 'L') { /* Prefix: Size is long int */
   \   0000005C   0x286C             CMP      R0,#+108
   \   0000005E   0xBF12             ITEE     NE 
   \   00000060   0x284C             CMPNE    R0,#+76
   \   00000062   0xF041 0x0104      ORREQ    R1,R1,#0x4
   \   00000066   0xF91A 0x0B01      LDRSBEQ  R0,[R10], #+1
   4019                f |= 4; c = *str++;
   4020              }
   4021              if (!c) break;
   \   0000006A   0x2800             CMP      R0,#+0
   \                     ??f_printf_3:
   \   0000006C   0xF000 0x80A7      BEQ.W    ??f_printf_7
   4022              d = c;
   \   00000070   0x4606             MOV      R6,R0
   4023              if (IsLower(d)) d -= 0x20;
   \   00000072   0xF1A6 0x0261      SUB      R2,R6,#+97
   \   00000076   0x2A1A             CMP      R2,#+26
   \   00000078   0xBF3C             ITT      CC 
   \   0000007A   0xF1A6 0x0220      SUBCC    R2,R6,#+32
   \   0000007E   0xB256             SXTBCC   R6,R2
   4024              switch (d) {        /* Type is... */
   \   00000080   0x2E42             CMP      R6,#+66
   \   00000082   0xD036             BEQ.N    ??f_printf_8
   \   00000084   0x2E43             CMP      R6,#+67
   \   00000086   0xD02F             BEQ.N    ??f_printf_9
   \   00000088   0x2E44             CMP      R6,#+68
   \   0000008A   0xD04E             BEQ.N    ??f_printf_10
   \   0000008C   0x2E4F             CMP      R6,#+79
   \   0000008E   0xD04A             BEQ.N    ??f_printf_11
   \   00000090   0x2E53             CMP      R6,#+83
   \   00000092   0xD004             BEQ.N    ??f_printf_12
   \   00000094   0x2E55             CMP      R6,#+85
   \   00000096   0xD048             BEQ.N    ??f_printf_10
   \   00000098   0x2E58             CMP      R6,#+88
   \   0000009A   0xD048             BEQ.N    ??f_printf_13
   \   0000009C   0xE049             B.N      ??f_printf_14
   4025              case 'S' :          /* String */
   4026                p = va_arg(arp, TCHAR*);
   \                     ??f_printf_12:
   \   0000009E   0xF85B 0x5B04      LDR      R5,[R11], #+4
   4027                for (j = 0; p[j]; j++) ;
   \   000000A2   0x2700             MOVS     R7,#+0
   \   000000A4   0xE000             B.N      ??f_printf_15
   \                     ??f_printf_16:
   \   000000A6   0x1C7F             ADDS     R7,R7,#+1
   \                     ??f_printf_15:
   \   000000A8   0x5778             LDRSB    R0,[R7, R5]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD1FB             BNE.N    ??f_printf_16
   4028                chc = 0;
   \   000000AE   0x2600             MOVS     R6,#+0
   4029                if (!(f & 2)) {
   \   000000B0   0x0788             LSLS     R0,R1,#+30
   \   000000B2   0xD407             BMI.N    ??f_printf_17
   \   000000B4   0xE002             B.N      ??f_printf_18
   4030                  while (j++ < w) chc += (cc = f_putc(' ', fil));
   \                     ??f_printf_19:
   \   000000B6   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_79:
   \   000000BA   0x1986             ADDS     R6,R0,R6
   \                     ??f_printf_18:
   \   000000BC   0x4638             MOV      R0,R7
   \   000000BE   0x1C47             ADDS     R7,R0,#+1
   \   000000C0   0x4540             CMP      R0,R8
   \   000000C2   0xD3F8             BCC.N    ??f_printf_19
   4031                }
   4032                chc += (cc = f_puts(p, fil));
   \                     ??f_printf_17:
   \   000000C4   0x4649             MOV      R1,R9
   \   000000C6   0x4628             MOV      R0,R5
   \   000000C8   0x.... 0x....      BL       f_puts
   \   000000CC   0x1985             ADDS     R5,R0,R6
   \   000000CE   0xE002             B.N      ??f_printf_20
   4033                while (j++ < w) chc += (cc = f_putc(' ', fil));
   \                     ??f_printf_21:
   \   000000D0   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_78:
   \   000000D4   0x1945             ADDS     R5,R0,R5
   \                     ??f_printf_20:
   \   000000D6   0x4639             MOV      R1,R7
   \   000000D8   0x1C4F             ADDS     R7,R1,#+1
   \   000000DA   0x4541             CMP      R1,R8
   \   000000DC   0xD3F8             BCC.N    ??f_printf_21
   4034                if (cc != EOF) cc = chc;
   \   000000DE   0xF110 0x0F01      CMN      R0,#+1
   \                     ??f_printf_2:
   \   000000E2   0xD069             BEQ.N    ??f_printf_22
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0xE062             B.N      ??f_printf_23
   4035                continue;
   4036              case 'C' :          /* Character */
   4037                cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
   \                     ??f_printf_9:
   \   000000E8   0x4649             MOV      R1,R9
   \   000000EA   0xF85B 0x0B04      LDR      R0,[R11], #+4
   \   000000EE   0xB240             SXTB     R0,R0
   \   000000F0   0xE020             B.N      ??f_printf_24
   4038              case 'B' :          /* Binary */
   4039                r = 2; break;
   \                     ??f_printf_8:
   \   000000F2   0x2202             MOVS     R2,#+2
   4040              case 'O' :          /* Octal */
   4041                r = 8; break;
   4042              case 'D' :          /* Signed decimal */
   4043              case 'U' :          /* Unsigned decimal */
   4044                r = 10; break;
   4045              case 'X' :          /* Hexdecimal */
   4046                r = 16; break;
   4047              default:          /* Unknown type (passthrough) */
   4048                cc = f_putc(c, fil); continue;
   4049              }
   4050          
   4051              /* Get an argument and put it in numeral */
   4052              v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
   \                     ??f_printf_25:
   \   000000F4   0x074B             LSLS     R3,R1,#+29
   \   000000F6   0xD520             BPL.N    ??f_printf_26
   \   000000F8   0xF85B 0x3B04      LDR      R3,[R11], #+4
   4053              if (d == 'D' && (v & 0x80000000)) {
   \   000000FC   0x2E44             CMP      R6,#+68
   \   000000FE   0xD104             BNE.N    ??f_printf_27
   \                     ??f_printf_28:
   \   00000100   0x2B00             CMP      R3,#+0
   \   00000102   0xBF44             ITT      MI 
   \   00000104   0x425B             RSBMI    R3,R3,#+0
   \   00000106   0xF041 0x0108      ORRMI    R1,R1,#0x8
   4054                v = 0 - v;
   4055                f |= 8;
   4056              }
   4057              i = 0;
   \                     ??f_printf_27:
   \   0000010A   0x2500             MOVS     R5,#+0
   4058              do {
   4059                d = (TCHAR)(v % r); v /= r;
   \                     ??f_printf_29:
   \   0000010C   0xFBB3 0xF4F2      UDIV     R4,R3,R2
   \   00000110   0xFB02 0x3614      MLS      R6,R2,R4,R3
   \   00000114   0xB276             SXTB     R6,R6
   \   00000116   0x4623             MOV      R3,R4
   4060                if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   \   00000118   0x2E0A             CMP      R6,#+10
   \   0000011A   0xDB14             BLT.N    ??f_printf_30
   \   0000011C   0x2878             CMP      R0,#+120
   \   0000011E   0xBF0C             ITE      EQ 
   \   00000120   0x2427             MOVEQ    R4,#+39
   \   00000122   0x2407             MOVNE    R4,#+7
   \   00000124   0xE00E             B.N      ??f_printf_31
   \                     ??f_printf_11:
   \   00000126   0x2208             MOVS     R2,#+8
   \   00000128   0xE7E4             B.N      ??f_printf_25
   \                     ??f_printf_10:
   \   0000012A   0x220A             MOVS     R2,#+10
   \   0000012C   0xE7E2             B.N      ??f_printf_25
   \                     ??f_printf_13:
   \   0000012E   0x2210             MOVS     R2,#+16
   \   00000130   0xE7E0             B.N      ??f_printf_25
   \                     ??f_printf_14:
   \   00000132   0x4649             MOV      R1,R9
   \                     ??f_printf_24:
   \   00000134   0x.... 0x....      BL       f_putc
   \   00000138   0xE039             B.N      ??f_printf_23
   \                     ??f_printf_26:
   \   0000013A   0x2E44             CMP      R6,#+68
   \   0000013C   0xF85B 0x3B04      LDR      R3,[R11], #+4
   \   00000140   0xD1E3             BNE.N    ??f_printf_27
   \   00000142   0xE7DD             B.N      ??f_printf_28
   \                     ??f_printf_31:
   \   00000144   0x19A6             ADDS     R6,R4,R6
   4061                s[i++] = d + '0';
   \                     ??f_printf_30:
   \   00000146   0xAC00             ADD      R4,SP,#+0
   \   00000148   0x3630             ADDS     R6,R6,#+48
   \   0000014A   0x552E             STRB     R6,[R5, R4]
   \   0000014C   0x1C6D             ADDS     R5,R5,#+1
   4062              } while (v && i < sizeof(s) / sizeof(s[0]));
   \   0000014E   0xB10B             CBZ.N    R3,??f_printf_32
   \   00000150   0x2D10             CMP      R5,#+16
   \   00000152   0xD3DB             BCC.N    ??f_printf_29
   4063              if (f & 8) s[i++] = '-';
   \                     ??f_printf_32:
   \   00000154   0x0708             LSLS     R0,R1,#+28
   \   00000156   0xD503             BPL.N    ??f_printf_33
   \   00000158   0xA800             ADD      R0,SP,#+0
   \   0000015A   0x222D             MOVS     R2,#+45
   \   0000015C   0x542A             STRB     R2,[R5, R0]
   \   0000015E   0x1C6D             ADDS     R5,R5,#+1
   4064              j = i; d = (f & 1) ? '0' : ' ';
   \                     ??f_printf_33:
   \   00000160   0x462F             MOV      R7,R5
   \   00000162   0x07C8             LSLS     R0,R1,#+31
   \   00000164   0xBF4C             ITE      MI 
   \   00000166   0x2630             MOVMI    R6,#+48
   \   00000168   0x2620             MOVPL    R6,#+32
   4065              res = 0;
   \   0000016A   0x2400             MOVS     R4,#+0
   4066              while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
   \   0000016C   0x0788             LSLS     R0,R1,#+30
   \   0000016E   0xD409             BMI.N    ??f_printf_34
   \   00000170   0xE004             B.N      ??f_printf_35
   \                     ??f_printf_36:
   \   00000172   0x4649             MOV      R1,R9
   \   00000174   0x4630             MOV      R0,R6
   \   00000176   0x.... 0x....      BL       f_putc
   \   0000017A   0x1904             ADDS     R4,R0,R4
   \                     ??f_printf_35:
   \   0000017C   0x4638             MOV      R0,R7
   \   0000017E   0x1C47             ADDS     R7,R0,#+1
   \   00000180   0x4540             CMP      R0,R8
   \   00000182   0xD3F6             BCC.N    ??f_printf_36
   4067              do res += (cc = f_putc(s[--i], fil)); while(i);
   \                     ??f_printf_34:
   \   00000184   0x1E6D             SUBS     R5,R5,#+1
   \   00000186   0x4649             MOV      R1,R9
   \   00000188   0xA800             ADD      R0,SP,#+0
   \   0000018A   0x5628             LDRSB    R0,[R5, R0]
   \   0000018C   0x.... 0x....      BL       f_putc
   \   00000190   0x1904             ADDS     R4,R0,R4
   \   00000192   0x2D00             CMP      R5,#+0
   \   00000194   0xD1F6             BNE.N    ??f_printf_34
   4068              while (j++ < w) res += (cc = f_putc(' ', fil));
   \                     ??f_printf_37:
   \   00000196   0x4639             MOV      R1,R7
   \   00000198   0x1C4F             ADDS     R7,R1,#+1
   \   0000019A   0x4541             CMP      R1,R8
   \   0000019C   0xD203             BCS.N    ??f_printf_38
   \   0000019E   0x.... 0x....      BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_77:
   \   000001A2   0x1904             ADDS     R4,R0,R4
   \   000001A4   0xE7F7             B.N      ??f_printf_37
   4069              if (cc != EOF) cc = res;
   \                     ??f_printf_38:
   \   000001A6   0xF110 0x0F01      CMN      R0,#+1
   \   000001AA   0xD005             BEQ.N    ??f_printf_22
   \   000001AC   0x4620             MOV      R0,R4
   4070            }
   \                     ??f_printf_23:
   \   000001AE   0x1904             ADDS     R4,R0,R4
   \   000001B0   0xF110 0x0F01      CMN      R0,#+1
   \   000001B4   0xF47F 0xAF35      BNE.W    ??f_printf_0
   \                     ??f_printf_22:
   \   000001B8   0xF04F 0x30FF      MOV      R0,#-1
   \   000001BC   0xE000             B.N      ??f_printf_39
   \                     ??f_printf_7:
   \   000001BE   0x4620             MOV      R0,R4
   \                     ??f_printf_39:
   \   000001C0   0xB005             ADD      SP,SP,#+20
   \   000001C2   0xE8BD 0x0FF0      POP      {R4-R11}
   \   000001C6   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   4071          
   4072            va_end(arp);
   4073            return (cc == EOF) ? cc : res;
   4074          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23:
   \   00000000   0x4649             MOV      R1,R9
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x....             B.N      f_putc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\"*+,:;<=>?[]|\\177">`:
   \   00000000   0x22 0x2A          DC8 "\"*+,:;<=>?[]|\177"
   \              0x2B 0x2C    
   \              0x3A 0x3B    
   \              0x3C 0x3D    
   \              0x3E 0x3F    
   \              0x5B 0x5D    
   \              0x7C 0x7F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x00FFFF00         DC32     0xffff00

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\353\\376\\220MSDOS5.0">`:
   \   00000000   0xEB 0xFE          DC8 "\353\376\220MSDOS5.0"
   \              0x90 0x4D    
   \              0x53 0x44    
   \              0x4F 0x53    
   \              0x35 0x2E    
   \              0x30 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "NO NAME    FAT32   ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT32   "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x33 0x32    
   \              0x20 0x20    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "NO NAME    FAT     ">`:
   \   00000000   0x4E 0x4F          DC8 "NO NAME    FAT     "
   \              0x20 0x4E    
   \              0x41 0x4D    
   \              0x45 0x20    
   \              0x20 0x20    
   \              0x20 0x46    
   \              0x41 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x00    
   4075          
   4076          #endif /* !_FS_READONLY */
   4077          #endif /* _USE_STRFUNC */
   4078          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  check_fs
               8 -> disk_read
       24  chk_mounted
              24 -> check_fs
              24 -> disk_initialize
              24 -> disk_read
              24 -> disk_status
        0  clust2sect
       24  create_chain
              24 -> get_fat
              24 -> put_fat
       32  create_name
              32 -> mem_set
       16  dir_find
              16 -> dir_next
              16 -> dir_sdi
              16 -> move_window
       24  dir_next
              24 -> clust2sect
              24 -> create_chain
              24 -> get_fat
              24 -> mem_set
              24 -> move_window
        8  dir_read
               8 -> dir_next
               8 -> move_window
       16  dir_register
              16 -> dir_next
              16 -> dir_sdi
              16 -> mem_cpy
              16 -> mem_set
              16 -> move_window
        8  dir_remove
               8 -> dir_sdi
               8 -> move_window
       16  dir_sdi
              16 -> clust2sect
              16 -> get_fat
       48  f_chdir
              48 -> chk_mounted
              48 -> follow_path
        0  f_chdrive
       56  f_chmod
              56 -> chk_mounted
              56 -> follow_path
              56 -> sync
        8  f_close
               8 -> f_sync
       88  f_getcwd
              88 -> chk_mounted
              88 -> dir_next
              88 -> dir_read
              88 -> dir_sdi
              88 -> get_fileinfo
       40  f_getfree
              40 -> chk_mounted
              40 -> get_fat
              40 -> move_window
       32  f_gets
              32 -> f_read
       24  f_lseek
              24 -> clust2sect
              24 -> create_chain
              24 -> disk_read
              24 -> disk_write
              24 -> get_fat
              24 -> validate
       88  f_mkdir
              88 -> chk_mounted
              88 -> clust2sect
              88 -> create_chain
              88 -> dir_register
              88 -> follow_path
              88 -> get_fattime
              88 -> mem_cpy
              88 -> mem_set
              88 -> move_window
              88 -> remove_chain
              88 -> sync
       64  f_mkfs
              64 -> disk_initialize
              64 -> disk_ioctl
              64 -> disk_write
              64 -> get_fattime
              64 -> mem_cpy
              64 -> mem_set
        0  f_mount
       72  f_open
              72 -> chk_mounted
              72 -> dir_register
              72 -> follow_path
              72 -> get_fattime
              72 -> move_window
              72 -> remove_chain
       24  f_opendir
              24 -> chk_mounted
              24 -> dir_sdi
              24 -> follow_path
       64  f_printf
              64 -> f_putc
              64 -> f_puts
       16  f_putc
              16 -> f_write
       16  f_puts
              16 -> f_putc
       32  f_read
              32 -> clust2sect
              32 -> disk_read
              32 -> disk_write
              32 -> get_fat
              32 -> mem_cpy
              32 -> validate
       24  f_readdir
              24 -> dir_next
              24 -> dir_read
              24 -> dir_sdi
              24 -> get_fileinfo
              24 -> validate
      104  f_rename
             104 -> chk_mounted
             104 -> clust2sect
             104 -> dir_register
             104 -> dir_remove
             104 -> follow_path
             104 -> mem_cpy
             104 -> move_window
             104 -> sync
       56  f_stat
              56 -> chk_mounted
              56 -> follow_path
              56 -> get_fileinfo
       16  f_sync
              16 -> disk_write
              16 -> get_fattime
              16 -> move_window
               0 -> sync
              16 -> validate
       16  f_truncate
              16 -> get_fat
              16 -> put_fat
              16 -> remove_chain
              16 -> validate
       80  f_unlink
              80 -> chk_mounted
              80 -> dir_read
              80 -> dir_remove
              80 -> dir_sdi
              80 -> follow_path
              80 -> mem_cpy
              80 -> remove_chain
              80 -> sync
       56  f_utime
              56 -> chk_mounted
              56 -> follow_path
              56 -> sync
       32  f_write
              32 -> clust2sect
              32 -> create_chain
              32 -> disk_read
              32 -> disk_write
              32 -> mem_cpy
              32 -> validate
       16  follow_path
              16 -> create_name
              16 -> dir_find
              16 -> dir_sdi
       24  get_fat
              24 -> move_window
        8  get_fileinfo
        0  mem_cpy
        0  mem_set
               0 -> __aeabi_memset
       24  move_window
              24 -> disk_read
              24 -> disk_write
       24  put_fat
              24 -> move_window
       24  remove_chain
              24 -> get_fat
              24 -> put_fat
       16  sync
              16 -> disk_ioctl
              16 -> disk_write
              16 -> mem_set
              16 -> move_window
        8  validate
               8 -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "NO NAME    FAT     ">
      20  ?<Constant "NO NAME    FAT32   ">
      16  ?<Constant "\"*+,:;<=>?[]|\177">
      12  ?<Constant "\353\376\220MSDOS5.0">
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable11
       4  ??DataTable11_1
      16  ?Subroutine0
      14  ?Subroutine1
      12  ?Subroutine10
      10  ?Subroutine11
       6  ?Subroutine12
      28  ?Subroutine13
      20  ?Subroutine14
      16  ?Subroutine15
       6  ?Subroutine16
      12  ?Subroutine17
       6  ?Subroutine18
      24  ?Subroutine19
      12  ?Subroutine2
      24  ?Subroutine20
       8  ?Subroutine21
      10  ?Subroutine22
       6  ?Subroutine23
      16  ?Subroutine24
      12  ?Subroutine3
      10  ?Subroutine4
       8  ?Subroutine5
      12  ?Subroutine6
       6  ?Subroutine7
      12  ?Subroutine8
       8  ?Subroutine9
       8  CurrVol
          Fsid
          FatFs
      96  check_fs
     712  chk_mounted
      24  clust2sect
     142  create_chain
     352  create_name
      24  cst
      70  dir_find
     220  dir_next
      54  dir_read
      84  dir_register
      32  dir_remove
     126  dir_sdi
      72  f_chdir
      16  f_chdrive
      62  f_chmod
      16  f_close
     248  f_getcwd
     226  f_getfree
      66  f_gets
     296  f_lseek
     418  f_mkdir
    1212  f_mkfs
      30  f_mount
     322  f_open
      66  f_opendir
     458  f_printf
      34  f_putc
      44  f_puts
     280  f_read
      60  f_readdir
     266  f_rename
      58  f_stat
     168  f_sync
     140  f_truncate
     176  f_unlink
      74  f_utime
     328  f_write
     120  follow_path
     180  get_fat
     120  get_fileinfo
      20  mem_cpy
      14  mem_set
      76  move_window
     216  put_fat
      86  remove_chain
     194  sync
      40  validate
      24  vst

 
     8 bytes in section .bss
 8 568 bytes in section .text
 
 8 568 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: none
