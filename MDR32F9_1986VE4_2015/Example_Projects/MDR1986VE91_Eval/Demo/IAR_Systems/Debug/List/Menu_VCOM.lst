###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     22/Sep/2015  17:25:59 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\src\Menu_VCOM.c                              #
#    Command line =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\src\Menu_VCOM.c --preprocess                 #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -lCN            #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -lB             #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -o              #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\ --debug          #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Proj #
#                    ects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\config\ -I  #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\ -I                            #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\USB_Library\ -I                #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CMSIS #
#                    \CM3\CoreSupport\ -I C:\WORK\Milandr.MDR1986BExx.1.4.0\E #
#                    xample_Projects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\ #
#                    ..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\   #
#                    -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MD #
#                    R1986VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CM #
#                    SIS\CM3\DeviceSupport\MDR32F9Qx\startup\iar\ -I          #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Example_Project #
#                    s\MDR1986VE91_Eval\inc\ -Ohz                             #
#    List file    =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\Menu_VCOM.lst    #
#    Object file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\Menu_VCOM.o       #
#                                                                             #
#                                                                             #
###############################################################################

C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR1986VE91_Eval\src\Menu_VCOM.c
      1          /**
      2            ******************************************************************************
      3            * @file    Menu_VCOM.c
      4            * @author  Phyton Application Team
      5            * @version V1.2.0
      6            * @date    12.09.2011
      7            * @brief   This file contains all the "USB VCOM" menu handlers.
      8            ******************************************************************************
      9            * <br><br>
     10            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     11            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     12            * TIME. AS A RESULT, PHYTON SHALL NOT BE HELD LIABLE FOR ANY
     13            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     14            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     15            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     16            *
     17            * <h2><center>&copy; COPYRIGHT 2011 Phyton</center></h2>
     18            */
     19          /* Includes ------------------------------------------------------------------*/
     20          #include "MDR32F9Qx_config.h"
     21          #include <MDR32Fx.h>
     22          #include <MDR32F9Qx_port.h>
     23          #include <MDR32F9Qx_rst_clk.h>
     24          #include <MDR32F9Qx_uart.h>
     25          #include <MDR32F9Qx_usb_handlers.h>
     26          #include "systick.h"
     27          #include "Menu.h"
     28          #include "Menu_items.h"
     29          #include "leds.h"
     30          #include "lcd.h"
     31          #include "text.h"
     32          #include "joystick.h"
     33          #include "demo_init.h"

   \                                 In section .bss, align 4
     34          #include "MDR32F9Qx_it.h"
     35          
     36          /** @addtogroup __MDR32F9Qx_Eval_Demo MDR32F9Qx Demonstration Example
     37            * @{
     38            */
     39          
     40          /** @addtogroup Menu Menu
     41            * @{
     42            */
     43          
     44          /** @addtogroup Menu_USB Menu USB VCOM
     45            * @{
     46            */
     47          
     48          /** @defgroup Menu_USB_Private_Constants Menu USB VCOM Private Constants
     49            * @{
     50            */
     51          
     52          #define BUFFER_LENGTH                        100
     53          
     54          #if defined (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1)
     55          #define UART                                 MDR_UART2
     56          #define RST_CLK_PCLK_UART                    RST_CLK_PCLK_UART2
     57          #define UART_IRQn                            UART2_IRQn
     58          #else
     59          #define UART                                 MDR_UART1
     60          #define RST_CLK_PCLK_UART                    RST_CLK_PCLK_UART1
     61          #define UART_IRQn                            UART1_IRQn
     62          #endif /* (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1) */
     63          
     64          /** @} */ /* End of group Menu_USB_Private_Constants */
     65          
     66          /** @defgroup Menu_USB_Private_Types Menu USB VCOM Private Types
     67            * @{
     68            */
     69          
     70          /** @} */ /* End of group Menu_USB_Private_Types */
     71          
     72          /** @defgroup Menu_USB_Private_Macros Menu USB VCOM Private Macros
     73            * @{
     74            */
     75          
     76          /** @} */ /* End of group Menu_USB_Private_Macros */
     77          
     78          /** @defgroup Menu_USB_Private_Variables Menu USB VCOM Private Variables
     79            * @{
     80            */
     81          
     82          static uint8_t SendBuffer[BUFFER_LENGTH];
     83          static uint8_t ReceiveBuffer[BUFFER_LENGTH];
     84          
     85          static vuint32_t send_data_length = 0;
     86          static vuint32_t send_data_pos = 0;
     87          static vuint32_t receive_data_length = 0;
     88          
     89          USB_Clock_TypeDef USB_Clock_InitStruct;
     90          USB_DeviceBUSParam_TypeDef USB_DeviceBUSParam;
     91          
     92          static UART_InitTypeDef UARTInitStructure;
     93          
     94          static uint32_t temp_CPU_CLOCK, temp_PLL_CONTROL;
     95          
     96          #ifdef USB_CDC_LINE_CODING_SUPPORTED
     97          static USB_CDC_LineCoding_TypeDef LineCoding;
   \                     LineCoding:
   \   00000000                      DS8 8
   \   00000008                      DS8 12
   \   00000014                      DS8 16
   \                     USB_DeviceBUSParam:
   \   00000024                      DS8 12
   \                     USB_Clock_InitStruct:
   \   00000030                      DS8 8
   \   00000038                      DS8 4
   \   0000003C                      DS8 4

   \                                 In section .bss, align 4
   \                     SendBuffer:
   \   00000000                      DS8 100
   \   00000064                      DS8 4
   \   00000068                      DS8 4

   \                                 In section .bss, align 4
   \                     ReceiveBuffer:
   \   00000000                      DS8 100
   \   00000064                      DS8 4
     98          #endif /* USB_CDC_LINE_CODING_SUPPORTED */
     99          
    100          #if defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1)
    101          static MDR_PORT_TypeDef PORTB_Configuration;
    102          #endif /* defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1) */
    103          
    104          /** @} */ /* End of group Menu_USB_Private_Variables */
    105          
    106          /** @defgroup Menu_USB_Private_Functions Menu USB VCOM Private Functions
    107            * @{
    108            */
    109          
    110          /* Private function prototypes -----------------------------------------------*/
    111          static void Setup_CPU_Clock(void);
    112          static void Setup_USB(void);
    113          static void UARTConfiguration(void);
    114          static void SenderFunc(void);
    115          static void ReceiverFunc(void);
    116          #ifdef USB_CDC_STATE_REPORTING_SUPPORTED
    117          static void LineStateFunc(uint32_t events);
    118          #endif /* USB_CDC_STATE_REPORTING_SUPPORTED */
    119          
    120          /* Private functions ---------------------------------------------------------*/
    121          
    122          /*******************************************************************************
    123          * Function Name  : Setup_CPU_Clock
    124          * Description    : Frequencies setup
    125          * Output         : None
    126          * Return         : USB_Result
    127          *******************************************************************************/
    128          static void Setup_CPU_Clock(void)
    129          {
    130            /* Enable HSE */
    131            RST_CLK_HSEconfig(RST_CLK_HSE_ON);
    132            if (RST_CLK_HSEstatus() != SUCCESS)
    133            {
    134              /* Trap */
    135              while (1)
    136              {
    137              }
    138            }
    139          
    140            /* CPU_C1_SEL = HSE */
    141            RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv1, RST_CLK_CPU_PLLmul10);
    142            RST_CLK_CPU_PLLcmd(ENABLE);
    143            if (RST_CLK_CPU_PLLstatus() != SUCCESS)
    144            {
    145              /* Trap */
    146              while (1)
    147              {
    148              }
    149            }
    150          
    151            /* CPU_C3_SEL = CPU_C2_SEL */
    152            RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV1);
    153            /* CPU_C2_SEL = PLL */
    154            RST_CLK_CPU_PLLuse(ENABLE);
    155            /* HCLK_SEL = CPU_C3_SEL */
    156            RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
    157          }
    158          
    159          /*******************************************************************************
    160          * Function Name  : Setup_USB
    161          * Description    : USB Device layer setup and powering on
    162          * Output         : None
    163          * Return         : USB_Result
    164          *******************************************************************************/
    165          static void Setup_USB(void)
    166          {
    167            /* Enables the CPU_CLK clock on USB */
    168            RST_CLK_PCLKcmd(RST_CLK_PCLK_USB, ENABLE);
    169          
    170            /* Device layer initialization */
    171            USB_Clock_InitStruct.USB_USBC1_Source = USB_C1HSEdiv2;
    172            USB_Clock_InitStruct.USB_PLLUSBMUL    = USB_PLLUSBMUL12;
    173          
    174            USB_DeviceBUSParam.MODE  = USB_SC_SCFSP_Full;
    175            USB_DeviceBUSParam.SPEED = USB_SC_SCFSR_12Mb;
    176            USB_DeviceBUSParam.PULL  = USB_HSCR_DP_PULLUP_Set;
    177          
    178            USB_DeviceInit(&USB_Clock_InitStruct, &USB_DeviceBUSParam);
    179          
    180            /* Enable all USB interrupts */
    181            USB_SetSIM(USB_SIS_Msk);
    182          
    183            USB_DevicePowerOn();
    184          
    185            /* Enable interrupt on USB */
    186          #ifdef USB_INT_HANDLE_REQUIRED
    187            NVIC_EnableIRQ(USB_IRQn);
    188          #endif /* USB_INT_HANDLE_REQUIRED */
    189          
    190            USB_DEVICE_HANDLE_RESET;
    191          }
    192          
    193          
    194          /*******************************************************************************
    195          * Function Name  : USB_CDC_RecieveData
    196          * Description    : CDC data reception handler.
    197          *                : Transfers received data to UART
    198          * Output         : None
    199          * Return         : USB_Result
    200          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    201          USB_Result USB_CDC_RecieveData(uint8_t* Buffer, uint32_t Length)
    202          {
   \                     USB_CDC_RecieveData:
   \   00000000   0xB580             PUSH     {R7,LR}
    203            /* Initiate UART transmission */
    204            send_data_length = Length;
   \   00000002   0x....             LDR.N    R0,??DataTable8
   \   00000004   0x6641             STR      R1,[R0, #+100]
    205            send_data_pos = 0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6681             STR      R1,[R0, #+104]
    206          
    207            SenderFunc();
   \   0000000A   0x.... 0x....      BL       SenderFunc
    208          
    209            return USB_SUCCESS;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    210          }
    211          
    212          
    213          #ifdef USB_CDC_LINE_CODING_SUPPORTED
    214          
    215          /*******************************************************************************
    216          * Function Name  : USB_CDC_GetLineCoding
    217          * Description    : GetLineCoding CDC request handler.
    218          *                : Sends back current line coding settings.
    219          * Output         : None
    220          * Return         : USB_Result
    221          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    222          USB_Result USB_CDC_GetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA)
    223          {
    224            assert_param(DATA);
    225            if (wINDEX != 0)
   \                     USB_CDC_GetLineCoding:
   \   00000000   0xB108             CBZ.N    R0,??USB_CDC_GetLineCoding_0
    226            {
    227              /* Invalid interface */
    228              return USB_ERR_INV_REQ;
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x4770             BX       LR
    229            }
    230          
    231            /* Just send back settings stored earlier */
    232            *DATA = LineCoding;
   \                     ??USB_CDC_GetLineCoding_0:
   \   00000006   0x....             LDR.N    R0,??DataTable8_1
   \   00000008   0xE9D0 0x2300      LDRD     R2,R3,[R0, #+0]
   \   0000000C   0xE9C1 0x2300      STRD     R2,R3,[R1, #+0]
    233          
    234            return USB_SUCCESS;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
    235          }
    236          
    237          
    238          /*******************************************************************************
    239          * Function Name  : USB_CDC_SetLineCoding
    240          * Description    : SetLineCoding CDC request handler.
    241          *                : Stores received line coding settings and adjusts UART.
    242          * Output         : None
    243          * Return         : USB_Result
    244          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    245          USB_Result USB_CDC_SetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA)
    246          {
   \                     USB_CDC_SetLineCoding:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    247            assert_param(DATA);
    248            if (wINDEX != 0)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD13E             BNE.N    ??USB_CDC_SetLineCoding_0
    249            {
    250              /* Invalid interface */
    251              return USB_ERR_INV_REQ;
    252            }
    253          
    254            /* Adjust UART settings */
    255          
    256            /* Baud rate */
    257            UARTInitStructure.UART_BaudRate = DATA->dwDTERate;
   \   00000008   0x....             LDR.N    R5,??DataTable8_1
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x6168             STR      R0,[R5, #+20]
    258          
    259            /* Stop bits */
    260            switch (DATA->bCharFormat)
   \   0000000E   0x7920             LDRB     R0,[R4, #+4]
   \   00000010   0xB110             CBZ.N    R0,??USB_CDC_SetLineCoding_1
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD137             BNE.N    ??USB_CDC_SetLineCoding_0
    261            {
    262              case USB_CDC_STOP_BITS1:
    263                UARTInitStructure.UART_StopBits = UART_StopBits1;
    264                break;
    265              case USB_CDC_STOP_BITS2:
    266                UARTInitStructure.UART_StopBits = UART_StopBits2;
   \   00000016   0x2008             MOVS     R0,#+8
    267                break;
   \                     ??USB_CDC_SetLineCoding_1:
   \   00000018   0x8368             STRH     R0,[R5, #+26]
    268              default :
    269                return USB_ERR_INV_REQ;
    270            }
    271          
    272            /* Parity */
    273            switch (DATA->bParityType)
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0xB168             CBZ.N    R0,??USB_CDC_SetLineCoding_2
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD006             BEQ.N    ??USB_CDC_SetLineCoding_3
   \   00000022   0xD303             BCC.N    ??USB_CDC_SetLineCoding_4
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xD007             BEQ.N    ??USB_CDC_SetLineCoding_5
   \   00000028   0xD304             BCC.N    ??USB_CDC_SetLineCoding_6
   \   0000002A   0xE02C             B.N      ??USB_CDC_SetLineCoding_0
    274            {
    275              case USB_CDC_PARITY_NONE:
    276                UARTInitStructure.UART_Parity = UART_Parity_No;
    277                break;
    278              case USB_CDC_PARITY_ODD:
    279                UARTInitStructure.UART_Parity = UART_Parity_Odd;
   \                     ??USB_CDC_SetLineCoding_4:
   \   0000002C   0x2002             MOVS     R0,#+2
    280                break;
   \   0000002E   0xE004             B.N      ??USB_CDC_SetLineCoding_2
    281              case USB_CDC_PARITY_EVEN:
    282                UARTInitStructure.UART_Parity = UART_Parity_Even;
   \                     ??USB_CDC_SetLineCoding_3:
   \   00000030   0x2006             MOVS     R0,#+6
    283                break;
   \   00000032   0xE002             B.N      ??USB_CDC_SetLineCoding_2
    284              case USB_CDC_PARITY_MARK:
    285                UARTInitStructure.UART_Parity = UART_Parity_0;
   \                     ??USB_CDC_SetLineCoding_6:
   \   00000034   0x2086             MOVS     R0,#+134
    286                break;
   \   00000036   0xE000             B.N      ??USB_CDC_SetLineCoding_2
    287              case USB_CDC_PARITY_SPACE:
    288                UARTInitStructure.UART_Parity = UART_Parity_1;
   \                     ??USB_CDC_SetLineCoding_5:
   \   00000038   0x2082             MOVS     R0,#+130
    289                break;
   \                     ??USB_CDC_SetLineCoding_2:
   \   0000003A   0x83A8             STRH     R0,[R5, #+28]
    290              default :
    291                return USB_ERR_INV_REQ;
    292            }
    293          
    294            /* Data bits */
    295            switch (DATA->bDataBits)
   \   0000003C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000003E   0x2805             CMP      R0,#+5
   \   00000040   0xD006             BEQ.N    ??USB_CDC_SetLineCoding_7
   \   00000042   0xD320             BCC.N    ??USB_CDC_SetLineCoding_0
   \   00000044   0x2807             CMP      R0,#+7
   \   00000046   0xD01A             BEQ.N    ??USB_CDC_SetLineCoding_8
   \   00000048   0xD317             BCC.N    ??USB_CDC_SetLineCoding_9
   \   0000004A   0x2808             CMP      R0,#+8
   \   0000004C   0xD019             BEQ.N    ??USB_CDC_SetLineCoding_10
   \   0000004E   0xE01A             B.N      ??USB_CDC_SetLineCoding_0
    296            {
    297              case USB_CDC_DATA_BITS5:
    298                UARTInitStructure.UART_WordLength = UART_WordLength5b;
   \                     ??USB_CDC_SetLineCoding_7:
   \   00000050   0x2000             MOVS     R0,#+0
    299                break;
   \                     ??USB_CDC_SetLineCoding_11:
   \   00000052   0x8328             STRH     R0,[R5, #+24]
    300              case USB_CDC_DATA_BITS6:
    301                UARTInitStructure.UART_WordLength = UART_WordLength6b;
    302                break;
    303              case USB_CDC_DATA_BITS7:
    304                UARTInitStructure.UART_WordLength = UART_WordLength7b;
    305                break;
    306              case USB_CDC_DATA_BITS8:
    307                UARTInitStructure.UART_WordLength = UART_WordLength8b;
    308                break;
    309              default :
    310                return USB_ERR_INV_REQ;
    311            }
    312          
    313            /* Re-initialize UART */
    314            UART_Cmd(UART, DISABLE);
   \   00000054   0x....             LDR.N    R6,??DataTable8_2  ;; 0x40038000
   \   00000056   0x.... 0x....      BL       ?Subroutine0
    315            UART_DeInit(UART);
   \                     ??CrossCallReturnLabel_3:
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       UART_DeInit
    316            UART_Init(UART, &UARTInitStructure);
   \   00000060   0x.... 0x....      BL       ?Subroutine1
    317            /* Enable sender, receiver and line state interrupts */
    318            UART_ITConfig (UART, UART_IT_TX | UART_IT_RX
    319          #ifdef USB_CDC_STATE_REPORTING_SUPPORTED
    320                        | UART_LINE_STATE_EVENTS
    321          #endif /* USB_CDC_STATE_REPORTING_SUPPORTED */
    322                        , ENABLE);
   \                     ??CrossCallReturnLabel_5:
   \   00000064   0x.... 0x....      BL       ?Subroutine2
    323            UART_Cmd(UART, ENABLE);
   \                     ??CrossCallReturnLabel_7:
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x.... 0x....      BL       ??Subroutine0_0
    324          
    325            /* On success, store new values for GetLineCoding request fastening */
    326            LineCoding = *DATA;
   \                     ??CrossCallReturnLabel_1:
   \   0000006E   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   00000072   0xE9C5 0x0100      STRD     R0,R1,[R5, #+0]
    327          
    328            return USB_SUCCESS;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??USB_CDC_SetLineCoding_9:
   \   0000007A   0x2020             MOVS     R0,#+32
   \   0000007C   0xE7E9             B.N      ??USB_CDC_SetLineCoding_11
   \                     ??USB_CDC_SetLineCoding_8:
   \   0000007E   0x2040             MOVS     R0,#+64
   \   00000080   0xE7E7             B.N      ??USB_CDC_SetLineCoding_11
   \                     ??USB_CDC_SetLineCoding_10:
   \   00000082   0x2060             MOVS     R0,#+96
   \   00000084   0xE7E5             B.N      ??USB_CDC_SetLineCoding_11
   \                     ??USB_CDC_SetLineCoding_0:
   \   00000086   0x2002             MOVS     R0,#+2
   \   00000088   0xBD70             POP      {R4-R6,PC}
    329          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x2130             MOVS     R1,#+48
   \   00000004   0x4630             MOV      R0,R6
   \   00000006   0x.... 0x....      B.W      UART_ITConfig

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xF105 0x0114      ADD      R1,R5,#+20
   \   00000004   0x4630             MOV      R0,R6
   \   00000006   0x.... 0x....      B.W      UART_Init

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x2100             MOVS     R1,#+0
   \                     ??Subroutine0_0:
   \   00000002   0x4630             MOV      R0,R6
   \   00000004   0x.... 0x....      B.W      UART_Cmd
    330          
    331          #endif /* USB_CDC_LINE_CODING_SUPPORTED */
    332          
    333          #if defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1)
    334          /*******************************************************************************
    335          * Function Name  : PORTBSaveConfig
    336          * Description    : Save the current PORTB configuration.
    337          * Output         : None
    338          * Return         : None
    339          *******************************************************************************/
    340          void PORTBSaveConfig(void)
    341          {
    342            PORTB_Configuration.ANALOG = MDR_PORTB->ANALOG;
    343            PORTB_Configuration.FUNC   = MDR_PORTB->FUNC;
    344            PORTB_Configuration.GFEN   = MDR_PORTB->GFEN;
    345            PORTB_Configuration.OE     = MDR_PORTB->OE;
    346            PORTB_Configuration.PD     = MDR_PORTB->PD;
    347            PORTB_Configuration.PULL   = MDR_PORTB->PULL;
    348            PORTB_Configuration.PWR    = MDR_PORTB->PWR;
    349          }
    350          
    351          /*******************************************************************************
    352          * Function Name  : PORTBRestoreConfig
    353          * Description    : Restore saved PORTB configuration.
    354          * Output         : None
    355          * Return         : None
    356          *******************************************************************************/
    357          void PORTBRestoreConfig(void)
    358          {
    359            MDR_PORTB->ANALOG = PORTB_Configuration.ANALOG;
    360            MDR_PORTB->FUNC   = PORTB_Configuration.FUNC;
    361            MDR_PORTB->GFEN   = PORTB_Configuration.GFEN;
    362            MDR_PORTB->OE     = PORTB_Configuration.OE;
    363            MDR_PORTB->PD     = PORTB_Configuration.PD;
    364            MDR_PORTB->PULL   = PORTB_Configuration.PULL;
    365            MDR_PORTB->PWR    = PORTB_Configuration.PWR;
    366          }
    367          #endif /* defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1) */
    368          
    369          
    370          /*******************************************************************************
    371          * Function Name  : UARTConfiguration
    372          * Description    : Configures the UART.
    373          *                : Configures the HCLK division factor and RTCHSE clock for UART.
    374          * Output         : None
    375          * Return         : None
    376          *******************************************************************************/
    377          static void UARTConfiguration(void)
    378          {
    379            /* Enable the RTCHSE clock on UART */
    380            RST_CLK_PCLKcmd(RST_CLK_PCLK_UART, ENABLE);
    381          
    382            /* Set the UART HCLK division factor */
    383            UART_BRGInit(UART, UART_HCLKdiv16);
    384          
    385            UART_DeInit(UART);
    386          
    387          #if defined (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1)
    388            /* Configure PORTF pins for data transfer to/from UART */
    389            PortInitStructure.PORT_Pin   = PORT_Pin_0 | PORT_Pin_1;
    390            PortInitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
    391            PortInitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
    392            PortInitStructure.PORT_SPEED = PORT_SPEED_MAXFAST;
    393            PORT_Init(MDR_PORTF, &PortInitStructure);
    394          #else
    395          #if defined (USE_MDR32F9Q2_Rev0) && !defined (USE_MDR32F9Q2_Rev1)
    396            PORTBSaveConfig();
    397          #endif /* defined (USE_MDR32F9Q2_Rev0) && !defined (USE_MDR32F9Q2_Rev1) */
    398            /* Configure PORTB pins for data transfer to/from UART */
    399            PortInitStructure.PORT_Pin   = PORT_Pin_5 | PORT_Pin_6;
    400            PortInitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
    401            PortInitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
    402            PortInitStructure.PORT_SPEED = PORT_SPEED_MAXFAST;
    403            PORT_Init(MDR_PORTB, &PortInitStructure);
    404          #endif /* defined (USE_MDR32F9Q1_Rev0) || defined (USE_MDR32F9Q1_Rev1) */
    405          
    406            /* Enable interrupt on UART */
    407            NVIC_EnableIRQ(UART_IRQn);
    408          }
    409          
    410          /*******************************************************************************
    411          * Function Name  : VCOMHelp
    412          * Description    : Prints hint to the screen.
    413          * Input          : None
    414          * Output         : None
    415          * Return         : None
    416          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    417          void VCOMHelp(void)
    418          {
   \                     VCOMHelp:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    419            sFONT *OldFont = CurrentFont;
   \   00000002   0x....             LDR.N    R4,??DataTable8_3
   \   00000004   0x6825             LDR      R5,[R4, #+0]
    420            LCD_Method OldMethod = CurrentMethod;
   \   00000006   0x....             LDR.N    R6,??DataTable8_4
   \   00000008   0x7837             LDRB     R7,[R6, #+0]
    421          
    422            LCD_CLS();
   \   0000000A   0x.... 0x....      BL       LCD_CLS
    423            CurrentMethod = MET_AND;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x7030             STRB     R0,[R6, #+0]
    424            CurrentFont = &Font_6x8;
   \   00000012   0x....             LDR.N    R0,??DataTable8_5
   \   00000014   0x6020             STR      R0,[R4, #+0]
    425            DisplayMenuTitle("MDR_USB. Virtual COM");
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "MDR_USB. Virtual COM">`
   \   0000001A   0x.... 0x....      BL       DisplayMenuTitle
    426            WAIT_UNTIL_KEY_RELEASED(SEL);
   \                     ??VCOMHelp_0:
   \   0000001E   0x.... 0x....      BL       GetKey
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0FB             BEQ.N    ??VCOMHelp_0
    427            LCD_PUTS(0, CurrentFont->Height * 2 + 2,     "  To stop Press SEL");
   \   00000026   0x.... 0x....      ADR.W    R2,`?<Constant "  To stop Press SEL">`
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0040             LSLS     R0,R0,#+1
   \   00000030   0x1C81             ADDS     R1,R0,#+2
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      BL       LCD_PUTS
    428          
    429            CurrentMethod = OldMethod;
   \   0000003A   0x7037             STRB     R7,[R6, #+0]
    430            CurrentFont = OldFont;
   \   0000003C   0x6025             STR      R5,[R4, #+0]
    431          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    432          
    433          /*******************************************************************************
    434          * Function Name  : SenderFunc
    435          * Description    : Sender interrupt handler.
    436          * Input          : None
    437          * Output         : None
    438          * Return         : None
    439          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          static void SenderFunc(void)
    441          {
   \                     SenderFunc:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable8_2  ;; 0x40038000
   \   00000004   0x....             LDR.N    R5,??DataTable8
   \   00000006   0xE007             B.N      ??SenderFunc_0
    442            for (; (send_data_pos < send_data_length && (UART_GetFlagStatus (UART, UART_FLAG_TXFF) == RESET)); send_data_pos++)
    443            {
    444              UART_SendData(UART, SendBuffer[send_data_pos]);
   \                     ??SenderFunc_1:
   \   00000008   0x6EA8             LDR      R0,[R5, #+104]
   \   0000000A   0x5D41             LDRB     R1,[R0, R5]
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       UART_SendData
    445            }
   \   00000012   0x6EA8             LDR      R0,[R5, #+104]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x66A8             STR      R0,[R5, #+104]
   \                     ??SenderFunc_0:
   \   00000018   0x6EA8             LDR      R0,[R5, #+104]
   \   0000001A   0x6E69             LDR      R1,[R5, #+100]
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD205             BCS.N    ??SenderFunc_2
   \   00000020   0x2120             MOVS     R1,#+32
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       UART_GetFlagStatus
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD0ED             BEQ.N    ??SenderFunc_1
    446          }
   \                     ??SenderFunc_2:
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    447          
    448          /*******************************************************************************
    449          * Function Name  : ReceiverFunc
    450          * Description    : Receiver interrupt handler.
    451          * Input          : None
    452          * Output         : None
    453          * Return         : None
    454          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    455          static void ReceiverFunc(void)
    456          {
   \                     ReceiverFunc:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    457            uint16_t receive_data;
    458          
    459            /* Read data from UART */
    460            for (receive_data_length = 0; ((UART_GetFlagStatus(UART, UART_FLAG_RXFE) == RESET) && (receive_data_length < BUFFER_LENGTH)); )
   \   00000002   0x....             LDR.N    R4,??DataTable8_6
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6660             STR      R0,[R4, #+100]
   \   00000008   0x....             LDR.N    R5,??DataTable8_2  ;; 0x40038000
   \   0000000A   0xE009             B.N      ??ReceiverFunc_0
    461            {
    462              receive_data = UART_ReceiveData(UART);
   \                     ??ReceiverFunc_1:
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       UART_ReceiveData
    463          
    464              if (UART_Flags(receive_data) == 0)
   \   00000012   0x0401             LSLS     R1,R0,#+16
   \   00000014   0x0E09             LSRS     R1,R1,#+24
   \   00000016   0xD103             BNE.N    ??ReceiverFunc_0
    465              {
    466                ReceiveBuffer[receive_data_length++] = UART_Data(receive_data);
   \   00000018   0x6E61             LDR      R1,[R4, #+100]
   \   0000001A   0x1C4A             ADDS     R2,R1,#+1
   \   0000001C   0x6662             STR      R2,[R4, #+100]
   \   0000001E   0x5508             STRB     R0,[R1, R4]
    467              }
    468            }
   \                     ??ReceiverFunc_0:
   \   00000020   0x2110             MOVS     R1,#+16
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       UART_GetFlagStatus
   \   00000028   0xB910             CBNZ.N   R0,??ReceiverFunc_2
   \   0000002A   0x6E60             LDR      R0,[R4, #+100]
   \   0000002C   0x2864             CMP      R0,#+100
   \   0000002E   0xD3ED             BCC.N    ??ReceiverFunc_1
    469            /* Initiate data portion sending via USB */
    470            USB_CDC_SendData(ReceiveBuffer, receive_data_length);
   \                     ??ReceiverFunc_2:
   \   00000030   0x6E61             LDR      R1,[R4, #+100]
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000038   0x.... 0x....      B.W      USB_CDC_SendData
    471          }
    472          
    473          #ifdef USB_CDC_STATE_REPORTING_SUPPORTED
    474          /*******************************************************************************
    475          * Function Name  : LineStateFunc
    476          * Description    : Line state event interrupt handler.
    477          * Input          : None
    478          * Output         : None
    479          * Return         : None
    480          *******************************************************************************/
    481          static void LineStateFunc(uint32_t events)
    482          {
    483            uint16_t lineState = 0;
    484            if (events & UART_IT_OE)
    485            {
    486            lineState |= USB_CDC_bOverRun;
    487            }
    488            if (events & UART_IT_BE)
    489            {
    490            lineState |= USB_CDC_bBreak;
    491            }
    492            if (events & UART_IT_PE)
    493            {
    494            lineState |= USB_CDC_bParity;
    495            }
    496            if (events & UART_IT_FE)
    497            {
    498            lineState |= USB_CDC_bFraming;
    499            }
    500            if (events & UART_IT_DSR)
    501            {
    502            lineState |= USB_CDC_bTxCarrier;
    503            }
    504            if (events & UART_IT_DCD)
    505            {
    506            lineState |= USB_CDC_bRxCarrier;
    507            }
    508            if (events & UART_IT_RI)
    509            {
    510            lineState |= USB_CDC_bRingSignal;
    511            }
    512          
    513            if (lineState)
    514            {
    515              USB_CDC_ReportState(lineState);
    516            }
    517          }
    518          #endif /* USB_CDC_STATE_REPORTING_SUPPORTED */
    519          
    520          /*******************************************************************************
    521          * Function Name  : VCOMFunc
    522          * Description    : Demonstration of USB-to-UART VCOM bridge.
    523          *                : Displays prompt on LCD, enables the bridge and waits for
    524          *                : joystick SEL key pressed to stop bridging and return
    525          *                : to main menu.
    526          * Input          : None
    527          * Output         : None
    528          * Return         : None
    529          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    530          void VCOMFunc(void) {
   \                     VCOMFunc:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    531            uint32_t key;
    532          
    533            /* Display prompt */
    534            VCOMHelp();
   \   00000002   0x.... 0x....      BL       VCOMHelp
    535          
    536            /* Save current CPU CLOCK configuration */
    537            temp_CPU_CLOCK   = MDR_RST_CLK->CPU_CLOCK;
   \   00000006   0x....             LDR.N    R4,??DataTable8_7  ;; 0x40020004
   \   00000008   0x....             LDR.N    R5,??DataTable8_1
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x63A8             STR      R0,[R5, #+56]
    538            temp_PLL_CONTROL = MDR_RST_CLK->PLL_CONTROL;
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x63E8             STR      R0,[R5, #+60]
    539          
    540            Setup_CPU_Clock();
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       RST_CLK_HSEconfig
   \   00000018   0x.... 0x....      BL       RST_CLK_HSEstatus
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD000             BEQ.N    ??VCOMFunc_0
   \                     ??VCOMFunc_1:
   \   00000020   0xE7FE             B.N      ??VCOMFunc_1
   \                     ??VCOMFunc_0:
   \   00000022   0x2109             MOVS     R1,#+9
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x.... 0x....      BL       RST_CLK_CPU_PLLconfig
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      BL       RST_CLK_CPU_PLLcmd
   \   00000030   0x.... 0x....      BL       RST_CLK_CPU_PLLstatus
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD000             BEQ.N    ??VCOMFunc_2
   \                     ??VCOMFunc_3:
   \   00000038   0xE7FE             B.N      ??VCOMFunc_3
   \                     ??VCOMFunc_2:
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       RST_CLK_CPUclkPrescaler
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       RST_CLK_CPU_PLLuse
   \   00000046   0xF44F 0x7080      MOV      R0,#+256
   \   0000004A   0x.... 0x....      BL       RST_CLK_CPUclkSelection
    541          
    542            UARTConfiguration();
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x2080             MOVS     R0,#+128
   \   00000052   0x.... 0x....      BL       RST_CLK_PCLKcmd
   \   00000056   0x....             LDR.N    R6,??DataTable8_2  ;; 0x40038000
   \   00000058   0x2104             MOVS     R1,#+4
   \   0000005A   0x4630             MOV      R0,R6
   \   0000005C   0x.... 0x....      BL       UART_BRGInit
   \   00000060   0x4630             MOV      R0,R6
   \   00000062   0x.... 0x....      BL       UART_DeInit
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x8128             STRH     R0,[R5, #+8]
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x74A8             STRB     R0,[R5, #+18]
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0x7428             STRB     R0,[R5, #+16]
   \   00000072   0x7468             STRB     R0,[R5, #+17]
   \   00000074   0xF105 0x0108      ADD      R1,R5,#+8
   \   00000078   0x....             LDR.N    R0,??DataTable8_8  ;; 0x400e8000
   \   0000007A   0x.... 0x....      BL       PORT_Init
   \   0000007E   0x....             LDR.N    R7,??DataTable8_9  ;; 0xe000e100
   \   00000080   0x2080             MOVS     R0,#+128
   \   00000082   0x6038             STR      R0,[R7, #+0]
    543          
    544            /* CDC layer initialization */
    545            USB_CDC_Init(SendBuffer, 1, SET);
   \   00000084   0x2201             MOVS     R2,#+1
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0x....             LDR.N    R0,??DataTable8
   \   0000008A   0x.... 0x....      BL       USB_CDC_Init
    546          
    547            /* UART configuration */
    548            UARTInitStructure.UART_BaudRate                = 14400;
   \   0000008E   0xF44F 0x5061      MOV      R0,#+14400
   \   00000092   0x6168             STR      R0,[R5, #+20]
    549            UARTInitStructure.UART_WordLength              = UART_WordLength8b;
   \   00000094   0x2060             MOVS     R0,#+96
   \   00000096   0x8328             STRH     R0,[R5, #+24]
    550            UARTInitStructure.UART_StopBits                = UART_StopBits1;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x8368             STRH     R0,[R5, #+26]
    551            UARTInitStructure.UART_Parity                  = UART_Parity_No;
   \   0000009C   0x61E8             STR      R0,[R5, #+28]
    552            UARTInitStructure.UART_FIFOMode                = UART_FIFO_OFF;
    553            UARTInitStructure.UART_HardwareFlowControl     = UART_HardwareFlowControl_RXE | \
    554                                                             UART_HardwareFlowControl_TXE;
   \   0000009E   0xF44F 0x7040      MOV      R0,#+768
   \   000000A2   0x8428             STRH     R0,[R5, #+32]
    555            /* With LBE bit set, output line of UARTTXD transmitter becomes to be bound to
    556             * UARTRXD receiver input. In order to run this example with UART physically
    557             * connected to PC, just comment this line */
    558          /*  UARTInitStructure.UART_HardwareFlowControl     |= UART_HardwareFlowControl_LBE; */
    559          
    560            UART_Init (UART,&UARTInitStructure);
   \   000000A4   0x.... 0x....      BL       ?Subroutine1
    561          
    562          #ifdef USB_CDC_LINE_CODING_SUPPORTED
    563            /* Set line coding initial settings accordingly to UART ones above */
    564            LineCoding.dwDTERate = UARTInitStructure.UART_BaudRate;
   \                     ??CrossCallReturnLabel_4:
   \   000000A8   0x6968             LDR      R0,[R5, #+20]
   \   000000AA   0x6028             STR      R0,[R5, #+0]
    565            LineCoding.bCharFormat = USB_CDC_STOP_BITS1;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x80A8             STRH     R0,[R5, #+4]
    566            LineCoding.bParityType = USB_CDC_PARITY_NONE;
    567            LineCoding.bDataBits = USB_CDC_DATA_BITS8;
   \   000000B0   0x2008             MOVS     R0,#+8
   \   000000B2   0x71A8             STRB     R0,[R5, #+6]
    568          #endif /* USB_CDC_LINE_CODING_SUPPORTED */
    569          
    570            /* Set interrupt handlers */
    571            pfUARTReceiverFunc = ReceiverFunc;
   \   000000B4   0x....             LDR.N    R0,??DataTable8_10
   \   000000B6   0x....             LDR.N    R1,??DataTable8_11
   \   000000B8   0x6001             STR      R1,[R0, #+0]
    572            pfUARTSenderFunc = SenderFunc;
   \   000000BA   0x....             LDR.N    R0,??DataTable8_12
   \   000000BC   0x....             LDR.N    R1,??DataTable8_13
   \   000000BE   0x6001             STR      R1,[R0, #+0]
    573          #ifdef USB_CDC_STATE_REPORTING_SUPPORTED
    574            pfUARTLineStateFunc = LineStateFunc;
    575          #endif /* USB_CDC_STATE_REPORTING_SUPPORTED */
    576          
    577            /* Enable sender, receiver and line state interrupts */
    578            UART_ITConfig (UART, UART_IT_TX | UART_IT_RX
    579          #ifdef USB_CDC_STATE_REPORTING_SUPPORTED
    580                        | UART_LINE_STATE_EVENTS
    581          #endif /* USB_CDC_STATE_REPORTING_SUPPORTED */
    582                        , ENABLE);
   \   000000C0   0x.... 0x....      BL       ?Subroutine2
    583          
    584            /* Enable bridge */
    585            UART_Cmd(UART, ENABLE);
   \                     ??CrossCallReturnLabel_6:
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x.... 0x....      BL       ??Subroutine0_0
    586            Setup_USB();
   \                     ??CrossCallReturnLabel_0:
   \   000000CA   0x2101             MOVS     R1,#+1
   \   000000CC   0x2004             MOVS     R0,#+4
   \   000000CE   0x.... 0x....      BL       RST_CLK_PCLKcmd
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0x6328             STR      R0,[R5, #+48]
   \   000000D6   0x200B             MOVS     R0,#+11
   \   000000D8   0x6368             STR      R0,[R5, #+52]
   \   000000DA   0x2010             MOVS     R0,#+16
   \   000000DC   0x62E8             STR      R0,[R5, #+44]
   \   000000DE   0x2020             MOVS     R0,#+32
   \   000000E0   0x62A8             STR      R0,[R5, #+40]
   \   000000E2   0x2010             MOVS     R0,#+16
   \   000000E4   0x6268             STR      R0,[R5, #+36]
   \   000000E6   0xF105 0x0124      ADD      R1,R5,#+36
   \   000000EA   0xF105 0x0030      ADD      R0,R5,#+48
   \   000000EE   0x.... 0x....      BL       USB_DeviceInit
   \   000000F2   0x201F             MOVS     R0,#+31
   \   000000F4   0x.... 0x....      BL       USB_SetSIM
   \   000000F8   0x.... 0x....      BL       USB_DevicePowerOn
   \   000000FC   0x2004             MOVS     R0,#+4
   \   000000FE   0x6038             STR      R0,[R7, #+0]
   \   00000100   0x.... 0x....      BL       USB_CDC_Reset
    587          
    588            /* Wait for SEL to quit */
    589            key = GetKey();
    590            for (; key != SEL; key = GetKey())
   \                     ??VCOMFunc_4:
   \   00000104   0x.... 0x....      BL       GetKey
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD1FB             BNE.N    ??VCOMFunc_4
    591            {
    592            }
    593            WAIT_UNTIL_KEY_RELEASED(SEL);
   \                     ??VCOMFunc_5:
   \   0000010C   0x.... 0x....      BL       GetKey
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD0FB             BEQ.N    ??VCOMFunc_5
    594          
    595            /* Disable bridge */
    596            UART_Cmd(UART, DISABLE);
   \   00000114   0x.... 0x....      BL       ?Subroutine0
    597          #if defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1)
    598            PORTBRestoreConfig();
    599          #endif /* defined (USE_MDR32F9Q2_Rev0) || defined (USE_MDR32F9Q2_Rev1) */
    600            USB_CDC_ReceiveStop();
   \                     ??CrossCallReturnLabel_2:
   \   00000118   0x.... 0x....      BL       USB_CDC_ReceiveStop
    601            USB_DevicePowerOff();
   \   0000011C   0x.... 0x....      BL       USB_DevicePowerOff
    602          
    603            /* Restore original CPU CLOCK configuration */
    604            MDR_RST_CLK->CPU_CLOCK   = temp_CPU_CLOCK;
   \   00000120   0x6BA8             LDR      R0,[R5, #+56]
   \   00000122   0x60A0             STR      R0,[R4, #+8]
    605            MDR_RST_CLK->PLL_CONTROL = temp_PLL_CONTROL;
   \   00000124   0x6BE8             LDR      R0,[R5, #+60]
   \   00000126   0x6020             STR      R0,[R4, #+0]
    606          
    607            DisplayMenu();
   \   00000128   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   0000012C   0x.... 0x....      B.W      DisplayMenu
    608          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     SendBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     LineCoding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40038000         DC32     0x40038000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     CurrentFont

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     CurrentMethod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     Font_6x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     ReceiveBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x40020004         DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x400E8000         DC32     0x400e8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     pfUARTReceiverFunc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     ReceiverFunc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     pfUARTSenderFunc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x........         DC32     SenderFunc

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MDR_USB. Virtual COM">`:
   \   00000000   0x4D 0x44          DC8 "MDR_USB. Virtual COM"
   \              0x52 0x5F    
   \              0x55 0x53    
   \              0x42 0x2E    
   \              0x20 0x56    
   \              0x69 0x72    
   \              0x74 0x75    
   \              0x61 0x6C    
   \              0x20 0x43    
   \              0x4F 0x4D    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "  To stop Press SEL">`:
   \   00000000   0x20 0x20          DC8 "  To stop Press SEL"
   \              0x54 0x6F    
   \              0x20 0x73    
   \              0x74 0x6F    
   \              0x70 0x20    
   \              0x50 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x53 0x45    
   \              0x4C 0x00    
    609          
    610          
    611          /** @} */ /* End of group Menu_USB_Private_Functions */
    612          
    613          /** @} */ /* End of group Menu_USB */
    614          
    615          /** @} */ /* End of group Menu */
    616          
    617          /** @} */ /* End of group __MDR32F9Qx_Eval_Demo */
    618          
    619          /******************* (C) COPYRIGHT 2011 Phyton *******************
    620          *
    621          * END OF FILE Menu_VCOM.c */
    622          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  ReceiverFunc
             16 -> UART_GetFlagStatus
             16 -> UART_ReceiveData
              0 -> USB_CDC_SendData
       16  SenderFunc
             16 -> UART_GetFlagStatus
             16 -> UART_SendData
        0  USB_CDC_GetLineCoding
        8  USB_CDC_RecieveData
              8 -> SenderFunc
       16  USB_CDC_SetLineCoding
             16 -> UART_Cmd
             16 -> UART_DeInit
             16 -> UART_ITConfig
             16 -> UART_Init
       24  VCOMFunc
              0 -> DisplayMenu
             24 -> GetKey
             24 -> PORT_Init
             24 -> RST_CLK_CPU_PLLcmd
             24 -> RST_CLK_CPU_PLLconfig
             24 -> RST_CLK_CPU_PLLstatus
             24 -> RST_CLK_CPU_PLLuse
             24 -> RST_CLK_CPUclkPrescaler
             24 -> RST_CLK_CPUclkSelection
             24 -> RST_CLK_HSEconfig
             24 -> RST_CLK_HSEstatus
             24 -> RST_CLK_PCLKcmd
             24 -> UART_BRGInit
             24 -> UART_Cmd
             24 -> UART_DeInit
             24 -> UART_ITConfig
             24 -> UART_Init
             24 -> USB_CDC_Init
             24 -> USB_CDC_ReceiveStop
             24 -> USB_CDC_Reset
             24 -> USB_DeviceInit
             24 -> USB_DevicePowerOff
             24 -> USB_DevicePowerOn
             24 -> USB_SetSIM
             24 -> VCOMHelp
       24  VCOMHelp
             24 -> DisplayMenuTitle
             24 -> GetKey
             24 -> LCD_CLS
             24 -> LCD_PUTS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "  To stop Press SEL">
      24  ?<Constant "MDR_USB. Virtual COM">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       8  ?Subroutine0
      10  ?Subroutine1
      10  ?Subroutine2
      64  LineCoding
          PortInitStructure
          UARTInitStructure
          USB_DeviceBUSParam
          USB_Clock_InitStruct
          temp_CPU_CLOCK
          temp_PLL_CONTROL
     104  ReceiveBuffer
          receive_data_length
      60  ReceiverFunc
     108  SendBuffer
          send_data_length
          send_data_pos
      46  SenderFunc
      20  USB_CDC_GetLineCoding
      18  USB_CDC_RecieveData
     138  USB_CDC_SetLineCoding
     304  VCOMFunc
      64  VCOMHelp

 
 276 bytes in section .bss
 778 bytes in section .text
 
 778 bytes of CODE memory
 276 bytes of DATA memory

Errors: none
Warnings: 1
