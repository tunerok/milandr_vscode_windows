###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.2.53884/W32 for ARM     22/Sep/2015  17:26:03 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\src_fatfs\mmc.c                              #
#    Command line =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\src_fatfs\mmc.c --preprocess                 #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -lCN            #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -lB             #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\ -o              #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\ --debug          #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Proj #
#                    ects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\config\ -I  #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\ -I                            #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\MDR32 #
#                    F9Qx_StdPeriph_Driver\inc\USB_Library\ -I                #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CMSIS #
#                    \CM3\CoreSupport\ -I C:\WORK\Milandr.MDR1986BExx.1.4.0\E #
#                    xample_Projects\MDR1986VE91_Eval\Demo\IAR_Systems\..\..\ #
#                    ..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc\   #
#                    -I C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MD #
#                    R1986VE91_Eval\Demo\IAR_Systems\..\..\..\..\Libraries\CM #
#                    SIS\CM3\DeviceSupport\MDR32F9Qx\startup\iar\ -I          #
#                    C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\..\..\..\..\Example_Project #
#                    s\MDR1986VE91_Eval\inc\ -Ohz                             #
#    List file    =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\List\mmc.lst          #
#    Object file  =  C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR19 #
#                    86VE91_Eval\Demo\IAR_Systems\Debug\Obj\mmc.o             #
#                                                                             #
#                                                                             #
###############################################################################

C:\WORK\Milandr.MDR1986BExx.1.4.0\Example_Projects\MDR1986VE91_Eval\src_fatfs\mmc.c
      1          /*------------------------------------------------------------------------*/
      2          /* MMCv3/SDv1/SDv2 (SPI mode) control module                              */
      3          /*------------------------------------------------------------------------*/
      4          /*
      5          /  Copyright (C) 2011, ChaN, all right reserved.
      6          /  Copyright (C) 2012, Milandr.
      7          /
      8          / * This software is a free software and there is NO WARRANTY.
      9          / * No restriction on use. You can use, modify and redistribute it for
     10          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     11          / * Redistributions of source code must retain the above copyright notice.
     12          /
     13          /-------------------------------------------------------------------------*/
     14          
     15          #define CCLK        80000000UL  /* cclk frequency [Hz] */
     16          #define PCLK_SSP    80000000UL  /* PCLK frequency for SSP [Hz] */
     17          #define SCLK_FAST   20000000UL  /* SCLK frequency under normal operation [Hz] */
     18          #define SCLK_SLOW   400000UL  /* SCLK frequency under initialization [Hz] */
     19          
     20          #define INS         1 /* Socket status (true:Inserted, false:Empty) */
     21          #define WP          0 /* Card write protection (true:yes, false:no) */
     22          #define _BV(bit) (1<<(bit))
     23          
     24          #define SSPxDR      MDR_SSP2->DR
     25          #define SSPxSR      MDR_SSP2->SR
     26          #define SSPxCR0     MDR_SSP2->CR0
     27          #define SSPxCR1     MDR_SSP2->CR1
     28          #define SSPxCPSR    MDR_SSP2->CPSR
     29          #define CS_LOW()    {MDR_PORTD->RXTX &= ~0x0008;} /* Set PD3 low */
     30          #define CS_HIGH()   {MDR_PORTD->RXTX |= 0x0008;;} /* Set PD3 high */
     31          
     32          #if PCLK_SSP * 1 == CCLK
     33          #define PCLKDIV_SSP PCLKDIV_1
     34          #elif PCLK_SSP * 2 == CCLK
     35          #define PCLKDIV_SSP PCLKDIV_2
     36          #elif PCLK_SSP * 4 == CCLK
     37          #define PCLKDIV_SSP PCLKDIV_4
     38          #elif PCLK_SSP * 8 == CCLK
     39          #define PCLKDIV_SSP PCLKDIV_8
     40          #else
     41          #error Invalid clock frequency.
     42          #endif
     43          
     44          
     45          #define FCLK_FAST()     { SSPxCPSR = (PCLK_SSP / SCLK_FAST) & ~1; }
     46          #define FCLK_SLOW()     { SSPxCPSR = (PCLK_SSP / SCLK_SLOW) & ~1; }
     47          
     48          
     49          /*--------------------------------------------------------------------------
     50          
     51             Module Private Functions
     52          
     53          ---------------------------------------------------------------------------*/
     54          
     55          #include "diskio.h"
     56          #include <MDR32Fx.h>
     57          
     58          
     59          /* MMC/SD command */
     60          #define CMD0  (0)     /* GO_IDLE_STATE */
     61          #define CMD1  (1)     /* SEND_OP_COND (MMC) */
     62          #define ACMD41  (0x80+41) /* SEND_OP_COND (SDC) */
     63          #define CMD8  (8)     /* SEND_IF_COND */
     64          #define CMD9  (9)     /* SEND_CSD */
     65          #define CMD10 (10)    /* SEND_CID */
     66          #define CMD12 (12)    /* STOP_TRANSMISSION */
     67          #define ACMD13  (0x80+13) /* SD_STATUS (SDC) */
     68          #define CMD16 (16)    /* SET_BLOCKLEN */
     69          #define CMD17 (17)    /* READ_SINGLE_BLOCK */
     70          #define CMD18 (18)    /* READ_MULTIPLE_BLOCK */
     71          #define CMD23 (23)    /* SET_BLOCK_COUNT (MMC) */
     72          #define ACMD23  (0x80+23) /* SET_WR_BLK_ERASE_COUNT (SDC) */
     73          #define CMD24 (24)    /* WRITE_BLOCK */
     74          #define CMD25 (25)    /* WRITE_MULTIPLE_BLOCK */
     75          #define CMD32 (32)    /* ERASE_ER_BLK_START */
     76          #define CMD33 (33)    /* ERASE_ER_BLK_END */
     77          #define CMD38 (38)    /* ERASE */
     78          #define CMD55 (55)    /* APP_CMD */
     79          #define CMD58 (58)    /* READ_OCR */
     80          
     81          /* Card type flags (CardType) */
     82          #define CT_MMC    0x01    /* MMC ver 3 */
     83          #define CT_SD1    0x02    /* SD ver 1 */
     84          #define CT_SD2    0x04    /* SD ver 2 */
     85          #define CT_SDC    (CT_SD1|CT_SD2) /* SD */
     86          #define CT_BLOCK  0x08    /* Block addressing */
     87          
     88          
     89          static volatile

   \                                 In section .data, align 4
     90          DSTATUS Stat = STA_NOINIT;  /* Physical drive status */
   \                     Stat:
   \   00000000   0x01               DC8 1
   \   00000001   0x00               DC8 0
   \   00000002   0x00 0x00          DC8 0, 0
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000008   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
     91          
     92          static volatile
     93          UINT Timer1, Timer2;  /* 1kHz decrement timer stopped at zero (disk_timerproc()) */
     94          
     95          static
     96          BYTE CardType;      /* Card type flags */
     97          
     98          
     99          
    100          /*-----------------------------------------------------------------------*/
    101          /* Send/Receive data to the MMC  (Platform dependent)                    */
    102          /*-----------------------------------------------------------------------*/
    103          
    104          /* Exchange a byte */

   \                                 In section .text, align 2, keep-with-next
    105          static
    106          BYTE xchg_spi (
    107            BYTE dat  /* Data to send */
    108          )
    109          {
    110            SSPxDR = dat;
   \                     xchg_spi:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable11  ;; 0x400a0008
   \   00000004   0x6008             STR      R0,[R1, #+0]
    111            while (SSPxSR & 0x10) ;
   \                     ??xchg_spi_0:
   \   00000006   0x6848             LDR      R0,[R1, #+4]
   \   00000008   0x06C0             LSLS     R0,R0,#+27
   \   0000000A   0xD4FC             BMI.N    ??xchg_spi_0
    112            return SSPxDR;
   \   0000000C   0x6808             LDR      R0,[R1, #+0]
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x4770             BX       LR               ;; return
    113          }
    114          
    115          
    116          /* Receive multiple byte */
    117          static
    118          void rcvr_spi_multi (
    119            BYTE *buff,   /* Pointer to data buffer */
    120            UINT btr    /* Number of bytes to receive (16, 64 or 512) */
    121          )
    122          {
    123            UINT n = 512;
    124            WORD d;
    125          
    126          
    127            SSPxCR0 = 0x000F;       /* Select 16-bit mode */
    128          
    129            for (n = 0; n < 8; n++)     /* Push 8 frames into pipeline  */
    130              SSPxDR = 0xFFFF;
    131            btr -= 16;
    132            while (btr) {         /* Receive the data block into buffer */
    133              while (!(SSPxSR & _BV(2))) ;
    134              d = SSPxDR;
    135              SSPxDR = 0xFFFF;
    136              *buff++ = d >> 8;
    137              *buff++ = d;
    138              btr -= 2;
    139            }
    140            for (n = 0; n < 8; n++) {   /* Pop remaining frames from pipeline */
    141              while (!(SSPxSR & _BV(2))) ;
    142              d = SSPxDR;
    143              *buff++ = d >> 8;
    144              *buff++ = d;
    145            }
    146          
    147            SSPxCR0 = 0x0007;       /* Select 8-bit mode */
    148          }
    149          
    150          
    151          /* Send multiple byte */
    152          static
    153          void xmit_spi_multi (
    154            const BYTE *buff, /* Pointer to the data */
    155            UINT btx      /* Number of bytes to send (512) */
    156          )
    157          {
    158            UINT n = 512;
    159            WORD d;
    160          
    161          
    162            SSPxCR0 = 0x000F;     /* Select 16-bit mode */
    163          
    164            for (n = 0; n < 8; n++) { /* Push 8 frames into pipeline  */
    165              d = *buff++;
    166              d = (d << 8) | *buff++;
    167              SSPxDR = d;
    168            }
    169            btx -= 16;
    170            do {            /* Transmit data block */
    171              d = *buff++;
    172              d = (d << 8) | *buff++;
    173              while (!(SSPxSR & _BV(2))) ;
    174              SSPxDR; SSPxDR = d;
    175            } while (btx -= 2);
    176            for (n = 0; n < 8; n++) {
    177              while (!(SSPxSR & _BV(2))) ;
    178              SSPxDR;
    179            }
    180          
    181            SSPxCR0 = 0x0007;     /* Select 8-bit mode */
    182          }
    183          
    184          
    185          
    186          /*-----------------------------------------------------------------------*/
    187          /* Wait for card ready                                                   */
    188          /*-----------------------------------------------------------------------*/
    189          

   \                                 In section .text, align 2, keep-with-next
    190          static
    191          int wait_ready (  /* 1:Ready, 0:Timeout */
    192            UINT wt     /* Timeout [ms] */
    193          )
    194          {
   \                     wait_ready:
   \   00000000   0xB510             PUSH     {R4,LR}
    195            BYTE d;
    196          
    197          
    198            Timer2 = wt;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable11_1
   \   00000006   0x60A0             STR      R0,[R4, #+8]
    199            do {
    200              d = xchg_spi(0xFF);
    201              /* This loop takes a time. Insert rot_rdq() here for multitask envilonment. */
    202            } while (d != 0xFF && Timer2);  /* Wait for card goes ready or timeout */
   \                     ??wait_ready_0:
   \   00000008   0x.... 0x....      BL       ??Subroutine0_1
   \                     ??CrossCallReturnLabel_12:
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD003             BEQ.N    ??wait_ready_1
   \   00000010   0x68A0             LDR      R0,[R4, #+8]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD1F8             BNE.N    ??wait_ready_0
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??wait_ready_1:
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD10             POP      {R4,PC}
    203          
    204            return (d == 0xFF) ? 1 : 0;
    205          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x2107             MOVS     R1,#+7
   \                     ??Subroutine0_0:
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \                     ??Subroutine0_1:
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0x....             B.N      xchg_spi
    206          
    207          
    208          
    209          /*-----------------------------------------------------------------------*/
    210          /* Deselect card and release SPI                                         */
    211          /*-----------------------------------------------------------------------*/
    212          

   \                                 In section .text, align 2, keep-with-next
    213          static
    214          void deselect (void)
    215          {
    216            CS_HIGH();    /* CS = H */
   \                     deselect:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x400c0000
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    217            xchg_spi(0xFF); /* Dummy clock (force DO hi-z for multiple slave SPI) */
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x....             B.N      xchg_spi
    218          
    219          }
    220          
    221          
    222          
    223          /*-----------------------------------------------------------------------*/
    224          /* Select card and wait for ready                                        */
    225          /*-----------------------------------------------------------------------*/
    226          

   \                                 In section .text, align 2, keep-with-next
    227          static
    228          int select (void) /* 1:OK, 0:Timeout */
    229          {
   \                     select:
   \   00000000   0xB580             PUSH     {R7,LR}
    230            CS_LOW();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x400c0000
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF021 0x0108      BIC      R1,R1,#0x8
   \   0000000C   0x.... 0x....      BL       ??Subroutine0_0
    231            xchg_spi(0xFF); /* Dummy clock (force DO enabled) */
    232          
    233            if (wait_ready(500)) return 1;  /* OK */
   \                     ??CrossCallReturnLabel_13:
   \   00000010   0xF44F 0x70FA      MOV      R0,#+500
   \   00000014   0x.... 0x....      BL       wait_ready
   \   00000018   0xB108             CBZ.N    R0,??select_0
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD02             POP      {R1,PC}
    234            deselect();
   \                     ??select_0:
   \   0000001E   0x.... 0x....      BL       deselect
    235            return 0; /* Timeout */
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
    236          }
    237          
    238          
    239          
    240          /*-----------------------------------------------------------------------*/
    241          /* Control SPI module (Platform dependent)                               */
    242          /*-----------------------------------------------------------------------*/
    243          
    244          static
    245          void power_on (void)  /* Enable SSP module and attach it to I/O pads */
    246          {
    247            MDR_RST_CLK->PER_CLOCK |= 1 << 20 | 1 << 24;    /* Enable SSP, PD module clock */
    248              MDR_RST_CLK->SSP_CLOCK = 2 << RST_CLK_SSP_CLOCK_SSP2_BRG_Pos | 1 << RST_CLK_SSP_CLOCK_SSP2_CLK_EN_Pos;
    249                                                  /* Select frequency for SSP */
    250          
    251            SSPxCR0 = 0x0007;     /* Set mode: SPI mode 0, 8-bit */
    252            SSPxCR1 = 0x2;        /* Enable SSP with Master */
    253          
    254            // Attach SCK1, MISO1, MOSI1 and CS# to I/O pad
    255              MDR_PORTD->ANALOG &= 0xFF93;
    256              MDR_PORTD->ANALOG |= 0x006C;
    257              MDR_PORTD->FUNC   &= 0xFFFFC30F;
    258              MDR_PORTD->FUNC   |= 0x00002820;
    259              MDR_PORTD->PWR    |= 0x00003CF0;
    260          
    261              MDR_PORTD->OE |= _BV(6)|_BV(5)|_BV(3);  /* Set SCK1, MOSI1 and CS# as output */
    262          
    263            CS_HIGH();          /* Set CS# high */
    264          }
    265          
    266          
    267          static
    268          void power_off (void)   /* Disable SPI function */
    269          {
    270            select();       /* Wait for card ready */
    271            deselect();
    272          }
    273          
    274          
    275          
    276          /*-----------------------------------------------------------------------*/
    277          /* Receive a data packet from the MMC                                    */
    278          /*-----------------------------------------------------------------------*/
    279          

   \                                 In section .text, align 2, keep-with-next
    280          static
    281          int rcvr_datablock (  /* 1:OK, 0:Error */
    282            BYTE *buff,     /* Data buffer */
    283            UINT btr      /* Data block length (byte) */
    284          )
    285          {
   \                     rcvr_datablock:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    286            BYTE token;
    287          
    288          
    289            Timer1 = 200;
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable11_1
   \   0000000A   0x20C8             MOVS     R0,#+200
   \   0000000C   0x6070             STR      R0,[R6, #+4]
    290            do {              /* Wait for DataStart token in timeout of 200ms */
    291              token = xchg_spi(0xFF);
   \                     ??rcvr_datablock_0:
   \   0000000E   0x.... 0x....      BL       ??Subroutine0_1
    292              /* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */
    293            } while ((token == 0xFF) && Timer1);
   \                     ??CrossCallReturnLabel_11:
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xD103             BNE.N    ??rcvr_datablock_1
   \   00000016   0x6870             LDR      R0,[R6, #+4]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F8             BNE.N    ??rcvr_datablock_0
   \   0000001C   0xE001             B.N      ??rcvr_datablock_2
    294            if(token != 0xFE) return 0;   /* Function fails if invalid DataStart token or timeout */
   \                     ??rcvr_datablock_1:
   \   0000001E   0x28FE             CMP      R0,#+254
   \   00000020   0xD001             BEQ.N    ??rcvr_datablock_3
   \                     ??rcvr_datablock_2:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xBD70             POP      {R4-R6,PC}
    295          
    296            rcvr_spi_multi(buff, btr);    /* Store trailing data to the buffer */
   \                     ??rcvr_datablock_3:
   \   00000026   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_18:
   \   0000002A   0xF64F 0x72FF      MOVW     R2,#+65535
   \                     ??rcvr_datablock_4:
   \   0000002E   0x6082             STR      R2,[R0, #+8]
   \   00000030   0x1E49             SUBS     R1,R1,#+1
   \   00000032   0xD1FC             BNE.N    ??rcvr_datablock_4
   \   00000034   0xF1B5 0x0110      SUBS     R1,R5,#+16
   \   00000038   0xE008             B.N      ??rcvr_datablock_5
   \                     ??rcvr_datablock_6:
   \   0000003A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_16:
   \   0000003E   0x041D             LSLS     R5,R3,#+16
   \   00000040   0x0E2D             LSRS     R5,R5,#+24
   \   00000042   0xF804 0x5B01      STRB     R5,[R4], #+1
   \   00000046   0xF804 0x3B01      STRB     R3,[R4], #+1
   \   0000004A   0x1E89             SUBS     R1,R1,#+2
   \                     ??rcvr_datablock_5:
   \   0000004C   0xD1F5             BNE.N    ??rcvr_datablock_6
   \   0000004E   0x2108             MOVS     R1,#+8
   \                     ??rcvr_datablock_7:
   \   00000050   0x68C2             LDR      R2,[R0, #+12]
   \   00000052   0x0752             LSLS     R2,R2,#+29
   \   00000054   0xD5FC             BPL.N    ??rcvr_datablock_7
   \   00000056   0x6882             LDR      R2,[R0, #+8]
   \   00000058   0x0413             LSLS     R3,R2,#+16
   \   0000005A   0x0E1B             LSRS     R3,R3,#+24
   \   0000005C   0xF804 0x3B01      STRB     R3,[R4], #+1
   \   00000060   0xF804 0x2B01      STRB     R2,[R4], #+1
   \   00000064   0x1E49             SUBS     R1,R1,#+1
   \   00000066   0xD1F3             BNE.N    ??rcvr_datablock_7
   \   00000068   0x.... 0x....      BL       ?Subroutine0
    297            xchg_spi(0xFF); xchg_spi(0xFF);     /* Discard CRC */
   \                     ??CrossCallReturnLabel_15:
   \   0000006C   0x.... 0x....      BL       ??Subroutine0_1
    298          
    299            return 1;           /* Function succeeded */
   \                     ??CrossCallReturnLabel_10:
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    300          }
    301          
    302          
    303          
    304          /*-----------------------------------------------------------------------*/
    305          /* Send a data packet to the MMC                                         */
    306          /*-----------------------------------------------------------------------*/
    307          

   \                                 In section .text, align 2, keep-with-next
    308          static
    309          int xmit_datablock (  /* 1:OK, 0:Failed */
    310            const BYTE *buff, /* Ponter to 512 byte data to be sent */
    311            BYTE token      /* Token */
    312          )
    313          {
   \                     xmit_datablock:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    314            BYTE resp;
    315          
    316          
    317            if (!wait_ready(500)) return 0;   /* Wait for card ready */
   \   00000006   0xF44F 0x70FA      MOV      R0,#+500
   \   0000000A   0x.... 0x....      BL       wait_ready
   \   0000000E   0xB318             CBZ.N    R0,??xmit_datablock_0
    318          
    319            xchg_spi(token);          /* Send token */
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       xchg_spi
    320            if (token != 0xFD) {        /* Send data if token is other than StopTran */
   \   00000016   0x2DFD             CMP      R5,#+253
   \   00000018   0xD020             BEQ.N    ??xmit_datablock_1
    321              xmit_spi_multi(buff, 512);    /* Data */
   \   0000001A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_19:
   \   0000001E   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_20:
   \   00000022   0x6082             STR      R2,[R0, #+8]
   \   00000024   0x1E49             SUBS     R1,R1,#+1
   \   00000026   0xD1FA             BNE.N    ??CrossCallReturnLabel_19
   \   00000028   0x21F8             MOVS     R1,#+248
   \                     ??xmit_datablock_2:
   \   0000002A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_21:
   \   0000002E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_17:
   \   00000032   0x1E49             SUBS     R1,R1,#+1
   \   00000034   0xD1F9             BNE.N    ??xmit_datablock_2
   \   00000036   0x2108             MOVS     R1,#+8
   \                     ??xmit_datablock_3:
   \   00000038   0x68C2             LDR      R2,[R0, #+12]
   \   0000003A   0x0752             LSLS     R2,R2,#+29
   \   0000003C   0xD5FC             BPL.N    ??xmit_datablock_3
   \   0000003E   0x6882             LDR      R2,[R0, #+8]
   \   00000040   0x1E49             SUBS     R1,R1,#+1
   \   00000042   0xD1F9             BNE.N    ??xmit_datablock_3
   \   00000044   0x.... 0x....      BL       ?Subroutine0
    322              xchg_spi(0xFF); xchg_spi(0xFF); /* Dummy CRC */
   \                     ??CrossCallReturnLabel_14:
   \   00000048   0x.... 0x....      BL       ??Subroutine0_1
    323          
    324              resp = xchg_spi(0xFF);        /* Receive data resp */
    325              if ((resp & 0x1F) != 0x05)    /* Function fails if the data packet was not accepted */
   \                     ??CrossCallReturnLabel_9:
   \   0000004C   0x.... 0x....      BL       ??Subroutine0_1
   \                     ??CrossCallReturnLabel_8:
   \   00000050   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000054   0x2805             CMP      R0,#+5
   \   00000056   0xD001             BEQ.N    ??xmit_datablock_1
    326                return 0;
   \                     ??xmit_datablock_0:
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}
    327            }
    328            return 1;
   \                     ??xmit_datablock_1:
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    329          }
    330          
    331          
    332          
    333          /*-----------------------------------------------------------------------*/
    334          /* Send a command packet to the MMC                                      */
    335          /*-----------------------------------------------------------------------*/
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static
    338          BYTE send_cmd (   /* Return value: R1 resp (bit7==1:Failed to send) */
    339            BYTE cmd,   /* Command index */
    340            DWORD arg   /* Argument */
    341          )
    342          {
   \                     send_cmd:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    343            BYTE n, res;
    344          
    345          
    346            if (cmd & 0x80) { /* Send a CMD55 prior to ACMD<n> */
   \   00000006   0x0620             LSLS     R0,R4,#+24
   \   00000008   0xD507             BPL.N    ??send_cmd_0
    347              cmd &= 0x7F;
   \   0000000A   0xF004 0x047F      AND      R4,R4,#0x7F
    348              res = send_cmd(CMD55, 0);
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2037             MOVS     R0,#+55
   \   00000012   0xF7FF 0xFFF5      BL       send_cmd
    349              if (res > 1) return res;
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD22D             BCS.N    ??send_cmd_1
    350            }
    351          
    352            /* Select card */
    353            deselect();
   \                     ??send_cmd_0:
   \   0000001A   0x.... 0x....      BL       deselect
    354            if (!select()) return 0xFF;
   \   0000001E   0x.... 0x....      BL       select
   \   00000022   0xB908             CBNZ.N   R0,??send_cmd_2
   \   00000024   0x20FF             MOVS     R0,#+255
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    355          
    356            /* Send command packet */
    357            xchg_spi(0x40 | cmd);       /* Start + command index */
   \                     ??send_cmd_2:
   \   00000028   0xF044 0x0040      ORR      R0,R4,#0x40
   \   0000002C   0x.... 0x....      BL       xchg_spi
    358            xchg_spi((BYTE)(arg >> 24));    /* Argument[31..24] */
   \   00000030   0x0E28             LSRS     R0,R5,#+24
   \   00000032   0x.... 0x....      BL       xchg_spi
    359            xchg_spi((BYTE)(arg >> 16));    /* Argument[23..16] */
   \   00000036   0x0228             LSLS     R0,R5,#+8
   \   00000038   0x0E00             LSRS     R0,R0,#+24
   \   0000003A   0x.... 0x....      BL       xchg_spi
    360            xchg_spi((BYTE)(arg >> 8));     /* Argument[15..8] */
   \   0000003E   0x0428             LSLS     R0,R5,#+16
   \   00000040   0x0E00             LSRS     R0,R0,#+24
   \   00000042   0x.... 0x....      BL       xchg_spi
    361            xchg_spi((BYTE)arg);        /* Argument[7..0] */
   \   00000046   0xB2E8             UXTB     R0,R5
   \   00000048   0x.... 0x....      BL       xchg_spi
    362            n = 0x01;             /* Dummy CRC + Stop */
   \   0000004C   0x2001             MOVS     R0,#+1
    363            if (cmd == CMD0) n = 0x95;      /* Valid CRC for CMD0(0) */
   \   0000004E   0xB90C             CBNZ.N   R4,??send_cmd_3
   \   00000050   0x2095             MOVS     R0,#+149
   \   00000052   0xE002             B.N      ??send_cmd_4
    364            if (cmd == CMD8) n = 0x87;      /* Valid CRC for CMD8(0x1AA) */
   \                     ??send_cmd_3:
   \   00000054   0x2C08             CMP      R4,#+8
   \   00000056   0xBF08             IT       EQ 
   \   00000058   0x2087             MOVEQ    R0,#+135
    365            xchg_spi(n);
   \                     ??send_cmd_4:
   \   0000005A   0x.... 0x....      BL       xchg_spi
    366          
    367            /* Receive command resp */
    368            if (cmd == CMD12) xchg_spi(0xFF); /* Diacard following one byte when CMD12 */
   \   0000005E   0x2C0C             CMP      R4,#+12
   \   00000060   0xBF04             ITT      EQ 
   \   00000062   0x20FF             MOVEQ    R0,#+255
   \   00000064   0x.... 0x....      BLEQ     xchg_spi
    369            n = 10;               /* Wait for response (10 bytes max) */
   \   00000068   0x240A             MOVS     R4,#+10
    370            do
    371              res = xchg_spi(0xFF);
   \                     ??send_cmd_5:
   \   0000006A   0x.... 0x....      BL       ??Subroutine0_1
    372            while ((res & 0x80) && --n);
   \                     ??CrossCallReturnLabel_7:
   \   0000006E   0x0601             LSLS     R1,R0,#+24
   \   00000070   0xD501             BPL.N    ??send_cmd_1
   \   00000072   0x1E64             SUBS     R4,R4,#+1
   \   00000074   0xD1F9             BNE.N    ??send_cmd_5
    373          
    374            return res;             /* Return received response */
   \                     ??send_cmd_1:
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    375          }
    376          
    377          
    378          
    379          /*--------------------------------------------------------------------------
    380          
    381             Public Functions
    382          
    383          ---------------------------------------------------------------------------*/
    384          
    385          
    386          /*-----------------------------------------------------------------------*/
    387          /* Initialize disk drive                                                 */
    388          /*-----------------------------------------------------------------------*/
    389          

   \                                 In section .text, align 2, keep-with-next
    390          DSTATUS disk_initialize (
    391            BYTE drv    /* Physical drive number (0) */
    392          )
    393          {
   \                     disk_initialize:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
    394            BYTE n, cmd, ty, ocr[4];
    395          
    396          
    397            if (drv) return STA_NOINIT;     /* Supports only drive 0 */
   \   00000006   0xB108             CBZ.N    R0,??disk_initialize_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE0AE             B.N      ??disk_initialize_1
    398            if (Stat & STA_NODISK) return Stat; /* Is card existing in the soket? */
   \                     ??disk_initialize_0:
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable11_1
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x0780             LSLS     R0,R0,#+30
   \   00000014   0xF100 0x80A8      BMI.W    ??disk_initialize_2
    399          
    400            power_on();             /* Initialize SPI */
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x4002001c
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xF041 0x7188      ORR      R1,R1,#0x1100000
   \   00000022   0x6001             STR      R1,[R0, #+0]
   \   00000024   0xF04F 0x2102      MOV      R1,#+33554944
   \   00000028   0x6101             STR      R1,[R0, #+16]
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable11_3  ;; 0x400a0000
   \   0000002E   0x2007             MOVS     R0,#+7
   \   00000030   0x6028             STR      R0,[R5, #+0]
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x6068             STR      R0,[R5, #+4]
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable11_2  ;; 0x400c0000
   \   0000003A   0x68C1             LDR      R1,[R0, #+12]
   \   0000003C   0xF64F 0x7293      MOVW     R2,#+65427
   \   00000040   0x4011             ANDS     R1,R2,R1
   \   00000042   0x60C1             STR      R1,[R0, #+12]
   \   00000044   0x68C1             LDR      R1,[R0, #+12]
   \   00000046   0xF041 0x016C      ORR      R1,R1,#0x6C
   \   0000004A   0x60C1             STR      R1,[R0, #+12]
   \   0000004C   0x6881             LDR      R1,[R0, #+8]
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable11_5  ;; 0xffffc30f
   \   00000052   0x4011             ANDS     R1,R2,R1
   \   00000054   0x6081             STR      R1,[R0, #+8]
   \   00000056   0x6881             LDR      R1,[R0, #+8]
   \   00000058   0xF441 0x5120      ORR      R1,R1,#0x2800
   \   0000005C   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000060   0x6081             STR      R1,[R0, #+8]
   \   00000062   0x6981             LDR      R1,[R0, #+24]
   \   00000064   0xF441 0x5170      ORR      R1,R1,#0x3C00
   \   00000068   0xF041 0x01F0      ORR      R1,R1,#0xF0
   \   0000006C   0x6181             STR      R1,[R0, #+24]
   \   0000006E   0x6841             LDR      R1,[R0, #+4]
   \   00000070   0xF041 0x0168      ORR      R1,R1,#0x68
   \   00000074   0x6041             STR      R1,[R0, #+4]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    401            FCLK_SLOW();
   \   0000007E   0x20C8             MOVS     R0,#+200
   \   00000080   0x6128             STR      R0,[R5, #+16]
    402            for (n = 10; n; n--) xchg_spi(0xFF);  /* Send 80 dummy clocks */
   \   00000082   0x270A             MOVS     R7,#+10
   \                     ??disk_initialize_3:
   \   00000084   0x.... 0x....      BL       ??Subroutine0_1
   \                     ??CrossCallReturnLabel_6:
   \   00000088   0x1E7F             SUBS     R7,R7,#+1
   \   0000008A   0xD1FB             BNE.N    ??disk_initialize_3
    403          
    404            ty = 0;
   \   0000008C   0x2600             MOVS     R6,#+0
    405            if (send_cmd(CMD0, 0) == 1) {     /* Put the card SPI/Idle state */
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x4608             MOV      R0,R1
   \   00000092   0x.... 0x....      BL       send_cmd
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD156             BNE.N    ??disk_initialize_4
    406              Timer1 = 1000;            /* Initialization timeout = 1 sec */
   \   0000009A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000009E   0x6060             STR      R0,[R4, #+4]
    407              if (send_cmd(CMD8, 0x1AA) == 1) { /* SDv2? */
   \   000000A0   0xF44F 0x71D5      MOV      R1,#+426
   \   000000A4   0x2008             MOVS     R0,#+8
   \   000000A6   0x.... 0x....      BL       send_cmd
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xF10D 0x0800      ADD      R8,SP,#+0
   \   000000B0   0xD12E             BNE.N    ??disk_initialize_5
    408                for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);  /* Get 32 bit return value of R7 resp */
   \                     ??disk_initialize_6:
   \   000000B2   0x.... 0x....      BL       ??Subroutine0_1
   \                     ??CrossCallReturnLabel_5:
   \   000000B6   0xF807 0x0008      STRB     R0,[R7, R8]
   \   000000BA   0x1C78             ADDS     R0,R7,#+1
   \   000000BC   0xB2C7             UXTB     R7,R0
   \   000000BE   0x2F04             CMP      R7,#+4
   \   000000C0   0xD3F7             BCC.N    ??disk_initialize_6
    409                if (ocr[2] == 0x01 && ocr[3] == 0xAA) {       /* Is the card supports vcc of 2.7-3.6V? */
   \   000000C2   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   000000C6   0x2801             CMP      R0,#+1
   \   000000C8   0xBF04             ITT      EQ 
   \   000000CA   0xF89D 0x0003      LDRBEQ   R0,[SP, #+3]
   \   000000CE   0x28AA             CMPEQ    R0,#+170
   \   000000D0   0xD13A             BNE.N    ??disk_initialize_4
    410          //                send_cmd(CMD0, 0);
    411          //                send_cmd(CMD8, 0x1AA);
    412          //        while (Timer1 && send_cmd(ACMD41, 0)) ; /* Wait for end of initialization with ACMD41(HCS) */
    413                  while (Timer1 && send_cmd(ACMD41, 1UL << 30)) ; /* Wait for end of initialization with ACMD41(HCS) */
   \                     ??disk_initialize_7:
   \   000000D2   0x6860             LDR      R0,[R4, #+4]
   \   000000D4   0xB130             CBZ.N    R0,??disk_initialize_8
   \   000000D6   0xF04F 0x4180      MOV      R1,#+1073741824
   \   000000DA   0x20A9             MOVS     R0,#+169
   \   000000DC   0x.... 0x....      BL       send_cmd
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD1F6             BNE.N    ??disk_initialize_7
    414                  if (Timer1 && send_cmd(CMD58, 0) == 0) {    /* Check CCS bit in the OCR */
   \                     ??disk_initialize_8:
   \   000000E4   0x6860             LDR      R0,[R4, #+4]
   \   000000E6   0xB378             CBZ.N    R0,??disk_initialize_4
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x203A             MOVS     R0,#+58
   \   000000EC   0x.... 0x....      BL       send_cmd
   \   000000F0   0xBB50             CBNZ.N   R0,??disk_initialize_4
    415                    for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
   \   000000F2   0x2700             MOVS     R7,#+0
   \                     ??disk_initialize_9:
   \   000000F4   0x.... 0x....      BL       ??Subroutine0_1
   \                     ??CrossCallReturnLabel_4:
   \   000000F8   0xF807 0x0008      STRB     R0,[R7, R8]
   \   000000FC   0x1C7F             ADDS     R7,R7,#+1
   \   000000FE   0x2F04             CMP      R7,#+4
   \   00000100   0xD3F8             BCC.N    ??disk_initialize_9
    416                    ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;  /* Card id SDv2 */
   \   00000102   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000106   0x0640             LSLS     R0,R0,#+25
   \   00000108   0xBF54             ITE      PL 
   \   0000010A   0x2604             MOVPL    R6,#+4
   \   0000010C   0x260C             MOVMI    R6,#+12
   \   0000010E   0xE01B             B.N      ??disk_initialize_4
    417                  }
    418                }
    419              } else {  /* Not SDv2 card */
    420                if (send_cmd(ACMD41, 0) <= 1)   { /* SDv1 or MMC? */
   \                     ??disk_initialize_5:
   \   00000110   0x2100             MOVS     R1,#+0
   \   00000112   0x20A9             MOVS     R0,#+169
   \   00000114   0x.... 0x....      BL       send_cmd
   \   00000118   0x2802             CMP      R0,#+2
   \   0000011A   0xBF39             ITTEE    CC 
   \   0000011C   0x2602             MOVCC    R6,#+2
   \   0000011E   0xF04F 0x08A9      MOVCC    R8,#+169
   \   00000122   0x2601             MOVCS    R6,#+1
   \   00000124   0x46B0             MOVCS    R8,R6
    421                  ty = CT_SD1; cmd = ACMD41;  /* SDv1 (ACMD41(0)) */
    422                } else {
    423                  ty = CT_MMC; cmd = CMD1;  /* MMCv3 (CMD1(0)) */
    424                }
    425                while (Timer1 && send_cmd(cmd, 0)) ;    /* Wait for end of initialization */
   \                     ??disk_initialize_10:
   \   00000126   0x6860             LDR      R0,[R4, #+4]
   \   00000128   0xB128             CBZ.N    R0,??disk_initialize_11
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0x4640             MOV      R0,R8
   \   0000012E   0x.... 0x....      BL       send_cmd
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD1F7             BNE.N    ??disk_initialize_10
    426                if (!Timer1 || send_cmd(CMD16, 512) != 0) /* Set block length: 512 */
   \                     ??disk_initialize_11:
   \   00000136   0x6860             LDR      R0,[R4, #+4]
   \   00000138   0xB128             CBZ.N    R0,??disk_initialize_12
   \   0000013A   0xF44F 0x7100      MOV      R1,#+512
   \   0000013E   0x2010             MOVS     R0,#+16
   \   00000140   0x.... 0x....      BL       send_cmd
   \   00000144   0xB100             CBZ.N    R0,??disk_initialize_4
    427                  ty = 0;
   \                     ??disk_initialize_12:
   \   00000146   0x2600             MOVS     R6,#+0
    428              }
    429            }
    430            CardType = ty;  /* Card type */
   \                     ??disk_initialize_4:
   \   00000148   0x7066             STRB     R6,[R4, #+1]
    431            deselect();
   \   0000014A   0x.... 0x....      BL       deselect
    432          
    433            if (ty) {     /* OK */
   \   0000014E   0xB12E             CBZ.N    R6,??disk_initialize_13
    434              FCLK_FAST();      /* Set fast clock */
   \   00000150   0x2004             MOVS     R0,#+4
   \   00000152   0x6128             STR      R0,[R5, #+16]
    435              Stat &= ~STA_NOINIT;  /* Clear STA_NOINIT flag */
   \   00000154   0x7820             LDRB     R0,[R4, #+0]
   \   00000156   0xF000 0x00FE      AND      R0,R0,#0xFE
   \   0000015A   0xE004             B.N      ??disk_initialize_14
    436            } else {      /* Failed */
    437              power_off();
   \                     ??disk_initialize_13:
   \   0000015C   0x.... 0x....      BL       select
   \   00000160   0x.... 0x....      BL       deselect
    438              Stat = STA_NOINIT;
   \   00000164   0x2001             MOVS     R0,#+1
   \                     ??disk_initialize_14:
   \   00000166   0x7020             STRB     R0,[R4, #+0]
    439            }
    440          
    441            return Stat;
   \                     ??disk_initialize_2:
   \   00000168   0x7820             LDRB     R0,[R4, #+0]
   \                     ??disk_initialize_1:
   \   0000016A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    442          }
    443          
    444          
    445          
    446          /*-----------------------------------------------------------------------*/
    447          /* Get disk status                                                       */
    448          /*-----------------------------------------------------------------------*/
    449          

   \                                 In section .text, align 2, keep-with-next
    450          DSTATUS disk_status (
    451            BYTE drv    /* Physical drive number (0) */
    452          )
    453          {
    454            if (drv) return STA_NOINIT;   /* Supports only drive 0 */
   \                     disk_status:
   \   00000000   0xB108             CBZ.N    R0,??disk_status_0
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR
    455          
    456            return Stat;  /* Return disk status */
   \                     ??disk_status_0:
   \   00000006   0x....             LDR.N    R0,??DataTable11_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x4770             BX       LR               ;; return
    457          }
    458          
    459          
    460          
    461          /*-----------------------------------------------------------------------*/
    462          /* Read sector(s)                                                        */
    463          /*-----------------------------------------------------------------------*/
    464          

   \                                 In section .text, align 2, keep-with-next
    465          DRESULT disk_read (
    466            BYTE drv,   /* Physical drive number (0) */
    467            BYTE *buff,   /* Pointer to the data buffer to store read data */
    468            DWORD sector, /* Start sector number (LBA) */
    469            BYTE count    /* Number of sectors to read (1..128) */
    470          )
    471          {
   \                     disk_read:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4611             MOV      R1,R2
   \   00000006   0x461D             MOV      R5,R3
    472            if (drv || !count) return RES_PARERR;   /* Check parameter */
   \   00000008   0xB900             CBNZ.N   R0,??disk_read_0
   \   0000000A   0xB90D             CBNZ.N   R5,??disk_read_1
   \                     ??disk_read_0:
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    473            if (Stat & STA_NOINIT) return RES_NOTRDY; /* Check if drive is ready */
   \                     ??disk_read_1:
   \   00000010   0x....             LDR.N    R0,??DataTable11_1
   \   00000012   0x7802             LDRB     R2,[R0, #+0]
   \   00000014   0x07D2             LSLS     R2,R2,#+31
   \   00000016   0xD501             BPL.N    ??disk_read_2
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    474          
    475            if (!(CardType & CT_BLOCK)) sector *= 512;  /* LBA ot BA conversion (byte addressing cards) */
   \                     ??disk_read_2:
   \   0000001C   0x7840             LDRB     R0,[R0, #+1]
   \   0000001E   0x0700             LSLS     R0,R0,#+28
   \   00000020   0xBF58             IT       PL 
   \   00000022   0x0249             LSLPL    R1,R1,#+9
    476          
    477            if (count == 1) { /* Single sector read */
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD108             BNE.N    ??disk_read_3
    478              if ((send_cmd(CMD17, sector) == 0)  /* READ_SINGLE_BLOCK */
    479                && rcvr_datablock(buff, 512))
   \   00000028   0x2011             MOVS     R0,#+17
   \   0000002A   0x.... 0x....      BL       send_cmd
   \   0000002E   0xB9B0             CBNZ.N   R0,??disk_read_4
   \   00000030   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_26:
   \   00000034   0xB198             CBZ.N    R0,??disk_read_4
    480                count = 0;
   \   00000036   0x2500             MOVS     R5,#+0
   \   00000038   0xE011             B.N      ??disk_read_4
    481            }
    482            else {        /* Multiple sector read */
    483              if (send_cmd(CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
   \                     ??disk_read_3:
   \   0000003A   0x2012             MOVS     R0,#+18
   \   0000003C   0x.... 0x....      BL       send_cmd
   \   00000040   0xB968             CBNZ.N   R0,??disk_read_4
    484                do {
    485                  if (!rcvr_datablock(buff, 512)) break;
   \                     ??disk_read_5:
   \   00000042   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_25:
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xBF1F             ITTTT    NE 
   \   0000004A   0xF504 0x7400      ADDNE    R4,R4,#+512
   \   0000004E   0x1E6D             SUBNE    R5,R5,#+1
   \   00000050   0xB2ED             UXTBNE   R5,R5
   \   00000052   0x2D00             CMPNE    R5,#+0
    486                  buff += 512;
    487                } while (--count);
   \   00000054   0xD1F5             BNE.N    ??disk_read_5
    488                send_cmd(CMD12, 0);       /* STOP_TRANSMISSION */
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x200C             MOVS     R0,#+12
   \   0000005A   0x.... 0x....      BL       send_cmd
    489              }
    490            }
    491            deselect();
   \                     ??disk_read_4:
   \   0000005E   0x.... 0x....      BL       deselect
    492          
    493            return count ? RES_ERROR : RES_OK;  /* Return result */
   \   00000062   0x0028             MOVS     R0,R5
   \   00000064   0xBF18             IT       NE 
   \   00000066   0x2001             MOVNE    R0,#+1
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    494          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0xF44F 0x7100      MOV      R1,#+512
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x....             B.N      rcvr_datablock
    495          
    496          
    497          
    498          /*-----------------------------------------------------------------------*/
    499          /* Write sector(s)                                                       */
    500          /*-----------------------------------------------------------------------*/
    501          

   \                                 In section .text, align 2, keep-with-next
    502          DRESULT disk_write (
    503            BYTE drv,     /* Physical drive number (0) */
    504            const BYTE *buff, /* Ponter to the data to write */
    505            DWORD sector,   /* Start sector number (LBA) */
    506            BYTE count      /* Number of sectors to write (1..128) */
    507          )
    508          {
   \                     disk_write:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x461E             MOV      R6,R3
    509            if (drv || !count) return RES_PARERR;   /* Check parameter */
   \   00000008   0xB900             CBNZ.N   R0,??disk_write_0
   \   0000000A   0xB90E             CBNZ.N   R6,??disk_write_1
   \                     ??disk_write_0:
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    510            if (Stat & STA_NOINIT) return RES_NOTRDY; /* Check drive status */
   \                     ??disk_write_1:
   \   00000010   0x....             LDR.N    R0,??DataTable11_1
   \   00000012   0x7801             LDRB     R1,[R0, #+0]
   \   00000014   0x07C9             LSLS     R1,R1,#+31
   \   00000016   0xD501             BPL.N    ??disk_write_2
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0xBD70             POP      {R4-R6,PC}
    511            if (Stat & STA_PROTECT) return RES_WRPRT; /* Check write protect */
   \                     ??disk_write_2:
   \   0000001C   0x7801             LDRB     R1,[R0, #+0]
   \   0000001E   0x0749             LSLS     R1,R1,#+29
   \   00000020   0xD501             BPL.N    ??disk_write_3
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xBD70             POP      {R4-R6,PC}
    512          
    513            if (!(CardType & CT_BLOCK)) sector *= 512;  /* LBA ==> BA conversion (byte addressing cards) */
   \                     ??disk_write_3:
   \   00000026   0x7840             LDRB     R0,[R0, #+1]
   \   00000028   0x0701             LSLS     R1,R0,#+28
   \   0000002A   0xBF58             IT       PL 
   \   0000002C   0x026D             LSLPL    R5,R5,#+9
    514          
    515            if (count == 1) { /* Single sector write */
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD10B             BNE.N    ??disk_write_4
    516              if ((send_cmd(CMD24, sector) == 0)  /* WRITE_BLOCK */
    517                && xmit_datablock(buff, 0xFE))
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x2018             MOVS     R0,#+24
   \   00000036   0x.... 0x....      BL       send_cmd
   \   0000003A   0xBB20             CBNZ.N   R0,??disk_write_5
   \   0000003C   0x21FE             MOVS     R1,#+254
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       xmit_datablock
   \   00000044   0xB1F8             CBZ.N    R0,??disk_write_5
    518                count = 0;
   \   00000046   0x2600             MOVS     R6,#+0
   \   00000048   0xE01D             B.N      ??disk_write_5
    519            }
    520            else {        /* Multiple sector write */
    521              if (CardType & CT_SDC) send_cmd(ACMD23, count); /* Predefine number of sectors */
   \                     ??disk_write_4:
   \   0000004A   0x2106             MOVS     R1,#+6
   \   0000004C   0x4208             TST      R0,R1
   \   0000004E   0xD003             BEQ.N    ??disk_write_6
   \   00000050   0x4631             MOV      R1,R6
   \   00000052   0x2097             MOVS     R0,#+151
   \   00000054   0x.... 0x....      BL       send_cmd
    522              if (send_cmd(CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
   \                     ??disk_write_6:
   \   00000058   0x4629             MOV      R1,R5
   \   0000005A   0x2019             MOVS     R0,#+25
   \   0000005C   0x.... 0x....      BL       send_cmd
   \   00000060   0xB988             CBNZ.N   R0,??disk_write_5
    523                do {
    524                  if (!xmit_datablock(buff, 0xFC)) break;
   \                     ??disk_write_7:
   \   00000062   0x21FC             MOVS     R1,#+252
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       xmit_datablock
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xBF1F             ITTTT    NE 
   \   0000006E   0xF504 0x7400      ADDNE    R4,R4,#+512
   \   00000072   0x1E76             SUBNE    R6,R6,#+1
   \   00000074   0xB2F6             UXTBNE   R6,R6
   \   00000076   0x2E00             CMPNE    R6,#+0
    525                  buff += 512;
    526                } while (--count);
   \   00000078   0xD1F3             BNE.N    ??disk_write_7
    527                if (!xmit_datablock(0, 0xFD)) /* STOP_TRAN token */
   \   0000007A   0x21FD             MOVS     R1,#+253
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      BL       xmit_datablock
   \   00000082   0xB900             CBNZ.N   R0,??disk_write_5
    528                  count = 1;
   \   00000084   0x2601             MOVS     R6,#+1
    529              }
    530            }
    531            deselect();
   \                     ??disk_write_5:
   \   00000086   0x.... 0x....      BL       deselect
    532          
    533            return count ? RES_ERROR : RES_OK;  /* Return result */
   \   0000008A   0x0030             MOVS     R0,R6
   \   0000008C   0xBF18             IT       NE 
   \   0000008E   0x2001             MOVNE    R0,#+1
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
    534          }
    535          
    536          
    537          
    538          /*-----------------------------------------------------------------------*/
    539          /* Miscellaneous drive controls other than data read/write               */
    540          /*-----------------------------------------------------------------------*/
    541          

   \                                 In section .text, align 4, keep-with-next
    542          DRESULT disk_ioctl (
    543            BYTE drv,   /* Physical drive number (0) */
    544            BYTE ctrl,    /* Control command code */
    545            void *buff    /* Pointer to the conrtol data */
    546          )
    547          {
   \                     disk_ioctl:
   \   00000000   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \   00000004   0x4614             MOV      R4,R2
    548            DRESULT res;
    549            BYTE n, csd[16], *ptr = buff;
   \   00000006   0x46A0             MOV      R8,R4
    550            WORD csize;
    551            DWORD *dp, st, ed;
    552          
    553          
    554            if (drv) return RES_PARERR;         /* Check parameter */
   \   00000008   0xB108             CBZ.N    R0,??disk_ioctl_1
   \   0000000A   0x2004             MOVS     R0,#+4
   \                     ??disk_ioctl_2:
   \   0000000C   0xE0E8             B.N      ??disk_ioctl_3
    555            if (Stat & STA_NOINIT) return RES_NOTRDY; /* Check if drive is ready */
   \                     ??disk_ioctl_1:
   \   0000000E   0x....             LDR.N    R6,??DataTable11_1
   \   00000010   0x7830             LDRB     R0,[R6, #+0]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xBF48             IT       MI 
   \   00000016   0x2003             MOVMI    R0,#+3
   \   00000018   0xD4F8             BMI.N    ??disk_ioctl_2
    556          
    557            res = RES_ERROR;
   \   0000001A   0x2701             MOVS     R7,#+1
    558          
    559            switch (ctrl) {
   \   0000001C   0x7870             LDRB     R0,[R6, #+1]
   \   0000001E   0xAD00             ADD      R5,SP,#+0
   \   00000020   0x290E             CMP      R1,#+14
   \   00000022   0xF200 0x80D9      BHI.W    ??disk_ioctl_4
   \   00000026   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??disk_ioctl_0:
   \   0000002A   0x08 0x0F          DC8      0x8,0xF,0x3F,0x43
   \              0x3F 0x43    
   \   0000002E   0x82 0xD7          DC8      0x82,0xD7,0xD7,0xD7
   \              0xD7 0xD7    
   \   00000032   0xD7 0xD7          DC8      0xD7,0xD7,0xAF,0xB2
   \              0xAF 0xB2    
   \   00000036   0xB5 0xBC          DC8      0xB5,0xBC,0xC9,0x0
   \              0xC9 0x00    
    560            case CTRL_SYNC :    /* Wait for end of internal write process of the drive */
    561              if (select()) {
   \                     ??disk_ioctl_5:
   \   0000003A   0x.... 0x....      BL       select
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD057             BEQ.N    ??disk_ioctl_6
    562                deselect();
   \   00000042   0x.... 0x....      BL       deselect
    563                res = RES_OK;
   \   00000046   0xE0C5             B.N      ??disk_ioctl_7
    564              }
    565              break;
    566          
    567            case GET_SECTOR_COUNT : /* Get drive capacity in unit of sector (DWORD) */
    568              if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
   \                     ??disk_ioctl_8:
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x2009             MOVS     R0,#+9
   \   0000004C   0x.... 0x....      BL       send_cmd
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD14A             BNE.N    ??disk_ioctl_9
   \   00000054   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_24:
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD04A             BEQ.N    ??disk_ioctl_6
    569                if ((csd[0] >> 6) == 1) { /* SDC ver 2.00 */
   \   0000005C   0x7A29             LDRB     R1,[R5, #+8]
   \   0000005E   0x7A68             LDRB     R0,[R5, #+9]
   \   00000060   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000064   0x0992             LSRS     R2,R2,#+6
   \   00000066   0x2A01             CMP      R2,#+1
   \   00000068   0xD105             BNE.N    ??disk_ioctl_10
    570                  csize = csd[9] + ((WORD)csd[8] << 8) + 1;
    571                  *(DWORD*)buff = (DWORD)csize << 10;
   \   0000006A   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x0400             LSLS     R0,R0,#+16
   \   00000072   0x0980             LSRS     R0,R0,#+6
   \   00000074   0xE059             B.N      ??disk_ioctl_11
    572                } else {          /* SDC ver 1.XX or MMC ver 3 */
    573                  n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    574                  csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    575                  *(DWORD*)buff = (DWORD)csize << (n - 9);
   \                     ??disk_ioctl_10:
   \   00000076   0x0989             LSRS     R1,R1,#+6
   \   00000078   0x79EA             LDRB     R2,[R5, #+7]
   \   0000007A   0xEB01 0x0182      ADD      R1,R1,R2, LSL #+2
   \   0000007E   0x79AA             LDRB     R2,[R5, #+6]
   \   00000080   0xF002 0x0203      AND      R2,R2,#0x3
   \   00000084   0xEB01 0x2182      ADD      R1,R1,R2, LSL #+10
   \   00000088   0x1C49             ADDS     R1,R1,#+1
   \   0000008A   0xB289             UXTH     R1,R1
   \   0000008C   0x796A             LDRB     R2,[R5, #+5]
   \   0000008E   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000092   0x7AAB             LDRB     R3,[R5, #+10]
   \   00000094   0xEB02 0x12D3      ADD      R2,R2,R3, LSR #+7
   \   00000098   0xF000 0x0003      AND      R0,R0,#0x3
   \   0000009C   0xEB02 0x0040      ADD      R0,R2,R0, LSL #+1
   \   000000A0   0x1FC0             SUBS     R0,R0,#+7
   \   000000A2   0xFA01 0xF000      LSL      R0,R1,R0
   \   000000A6   0xE040             B.N      ??disk_ioctl_11
    576                }
    577                res = RES_OK;
    578              }
    579              break;
    580          
    581            case GET_SECTOR_SIZE :  /* Get sector size in unit of byte (WORD) */
    582              *(WORD*)buff = 512;
   \                     ??disk_ioctl_12:
   \   000000A8   0xF44F 0x7000      MOV      R0,#+512
   \   000000AC   0x8020             STRH     R0,[R4, #+0]
    583              res = RES_OK;
   \   000000AE   0xE091             B.N      ??disk_ioctl_7
    584              break;
    585          
    586            case GET_BLOCK_SIZE : /* Get erase block size in unit of sector (DWORD) */
    587              if (CardType & CT_SD2) {  /* SDC ver 2.00 */
   \                     ??disk_ioctl_13:
   \   000000B0   0x0740             LSLS     R0,R0,#+29
   \   000000B2   0xD515             BPL.N    ??disk_ioctl_14
    588                if (send_cmd(ACMD13, 0) == 0) { /* Read SD status */
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x208D             MOVS     R0,#+141
   \   000000B8   0x.... 0x....      BL       send_cmd
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD114             BNE.N    ??disk_ioctl_9
    589                  xchg_spi(0xFF);
   \   000000C0   0x.... 0x....      BL       ??Subroutine0_1
    590                  if (rcvr_datablock(csd, 16)) {        /* Read partial block */
   \                     ??CrossCallReturnLabel_3:
   \   000000C4   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_23:
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD012             BEQ.N    ??disk_ioctl_6
    591                    for (n = 64 - 16; n; n--) xchg_spi(0xFF); /* Purge trailing data */
   \   000000CC   0x2630             MOVS     R6,#+48
   \                     ??disk_ioctl_15:
   \   000000CE   0x.... 0x....      BL       ??Subroutine0_1
   \                     ??CrossCallReturnLabel_2:
   \   000000D2   0x1E76             SUBS     R6,R6,#+1
   \   000000D4   0xD1FB             BNE.N    ??disk_ioctl_15
    592                    *(DWORD*)buff = 16UL << (csd[10] >> 4);
   \   000000D6   0x2010             MOVS     R0,#+16
   \   000000D8   0x7AA9             LDRB     R1,[R5, #+10]
   \   000000DA   0x0909             LSRS     R1,R1,#+4
   \   000000DC   0x4088             LSLS     R0,R0,R1
   \   000000DE   0xE024             B.N      ??disk_ioctl_11
    593                    res = RES_OK;
    594                  }
    595                }
    596              } else {          /* SDC ver 1.XX or MMC */
    597                if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {  /* Read CSD */
   \                     ??disk_ioctl_14:
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x2009             MOVS     R0,#+9
   \   000000E4   0x.... 0x....      BL       send_cmd
   \   000000E8   0x2800             CMP      R0,#+0
   \                     ??disk_ioctl_9:
   \   000000EA   0xD176             BNE.N    ??disk_ioctl_16
   \   000000EC   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_22:
   \   000000F0   0x2800             CMP      R0,#+0
   \                     ??disk_ioctl_6:
   \   000000F2   0xD072             BEQ.N    ??disk_ioctl_16
    598                  if (CardType & CT_SD1) {  /* SDC ver 1.XX */
   \   000000F4   0x7AE8             LDRB     R0,[R5, #+11]
   \   000000F6   0x7AA9             LDRB     R1,[R5, #+10]
   \   000000F8   0x7872             LDRB     R2,[R6, #+1]
   \   000000FA   0x0792             LSLS     R2,R2,#+30
   \   000000FC   0xD50B             BPL.N    ??disk_ioctl_17
    599                    *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1);
   \   000000FE   0xF001 0x013F      AND      R1,R1,#0x3F
   \   00000102   0x09C0             LSRS     R0,R0,#+7
   \   00000104   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   00000108   0x1C40             ADDS     R0,R0,#+1
   \   0000010A   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \   0000010E   0x0989             LSRS     R1,R1,#+6
   \   00000110   0x1E49             SUBS     R1,R1,#+1
   \   00000112   0x4088             LSLS     R0,R0,R1
   \   00000114   0xE009             B.N      ??disk_ioctl_11
    600                  } else {          /* MMC */
    601                    *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1);
   \                     ??disk_ioctl_17:
   \   00000116   0xF3C1 0x0184      UBFX     R1,R1,#+2,#+5
   \   0000011A   0x1C49             ADDS     R1,R1,#+1
   \   0000011C   0xF000 0x0203      AND      R2,R0,#0x3
   \   00000120   0x0940             LSRS     R0,R0,#+5
   \   00000122   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000126   0x1C40             ADDS     R0,R0,#+1
   \   00000128   0x4348             MULS     R0,R0,R1
   \                     ??disk_ioctl_11:
   \   0000012A   0x6020             STR      R0,[R4, #+0]
    602                  }
    603                  res = RES_OK;
   \   0000012C   0xE052             B.N      ??disk_ioctl_7
    604                }
    605              }
    606              break;
    607          
    608            case CTRL_ERASE_SECTOR :  /* Erase a block of sectors (used when _USE_ERASE == 1) */
    609              if (!(CardType & CT_SDC)) break;        /* Check if the card is SDC */
   \                     ??disk_ioctl_18:
   \   0000012E   0x2106             MOVS     R1,#+6
   \   00000130   0x4208             TST      R0,R1
   \   00000132   0xD052             BEQ.N    ??disk_ioctl_16
    610              if (disk_ioctl(drv, MMC_GET_CSD, csd)) break; /* Get CSD */
   \   00000134   0xAA00             ADD      R2,SP,#+0
   \   00000136   0x210B             MOVS     R1,#+11
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xF7FF 0xFF61      BL       disk_ioctl
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD14B             BNE.N    ??disk_ioctl_16
    611              if (!(csd[0] >> 6) && !(csd[10] & 0x40)) break; /* Check if sector erase can be applied to the card */
   \   00000142   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000146   0x0980             LSRS     R0,R0,#+6
   \   00000148   0xD102             BNE.N    ??disk_ioctl_19
   \   0000014A   0x7AA8             LDRB     R0,[R5, #+10]
   \   0000014C   0x0640             LSLS     R0,R0,#+25
   \   0000014E   0xD544             BPL.N    ??disk_ioctl_16
    612              dp = buff; st = dp[0]; ed = dp[1];        /* Load sector block */
   \                     ??disk_ioctl_19:
   \   00000150   0x6821             LDR      R1,[R4, #+0]
   \   00000152   0x6864             LDR      R4,[R4, #+4]
    613              if (!(CardType & CT_BLOCK)) {
   \   00000154   0x7870             LDRB     R0,[R6, #+1]
   \   00000156   0x0700             LSLS     R0,R0,#+28
   \   00000158   0xBF5C             ITT      PL 
   \   0000015A   0x0249             LSLPL    R1,R1,#+9
   \   0000015C   0x0264             LSLPL    R4,R4,#+9
    614                st *= 512; ed *= 512;
    615              }
    616              if (send_cmd(CMD32, st) == 0 && send_cmd(CMD33, ed) == 0 && send_cmd(CMD38, 0) == 0 && wait_ready(30000)) /* Erase sector block */
   \   0000015E   0x2020             MOVS     R0,#+32
   \   00000160   0x.... 0x....      BL       send_cmd
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD138             BNE.N    ??disk_ioctl_16
   \   00000168   0x4621             MOV      R1,R4
   \   0000016A   0x2021             MOVS     R0,#+33
   \   0000016C   0x.... 0x....      BL       send_cmd
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0xD132             BNE.N    ??disk_ioctl_16
   \   00000174   0x2100             MOVS     R1,#+0
   \   00000176   0x2026             MOVS     R0,#+38
   \   00000178   0x.... 0x....      BL       send_cmd
   \   0000017C   0xBB68             CBNZ.N   R0,??disk_ioctl_16
   \   0000017E   0xF247 0x5030      MOVW     R0,#+30000
   \   00000182   0x.... 0x....      BL       wait_ready
   \   00000186   0xE024             B.N      ??disk_ioctl_20
    617                res = RES_OK; /* FatFs does not check result of this command */
    618              break;
    619          
    620            /* Following command are not used by FatFs module */
    621          
    622            case MMC_GET_TYPE :   /* Get MMC/SDC type (BYTE) */
    623              *ptr = CardType;
   \                     ??disk_ioctl_21:
   \   00000188   0xF888 0x0000      STRB     R0,[R8, #+0]
    624              res = RES_OK;
   \   0000018C   0xE022             B.N      ??disk_ioctl_7
    625              break;
    626          
    627            case MMC_GET_CSD :    /* Read CSD (16 bytes) */
    628              if (send_cmd(CMD9, 0) == 0    /* READ_CSD */
    629                && rcvr_datablock(ptr, 16))
   \                     ??disk_ioctl_22:
   \   0000018E   0x2100             MOVS     R1,#+0
   \   00000190   0x2009             MOVS     R0,#+9
   \   00000192   0xE001             B.N      ??disk_ioctl_23
    630                res = RES_OK;
    631              break;
    632          
    633            case MMC_GET_CID :    /* Read CID (16 bytes) */
    634              if (send_cmd(CMD10, 0) == 0   /* READ_CID */
    635                && rcvr_datablock(ptr, 16))
   \                     ??disk_ioctl_24:
   \   00000194   0x2100             MOVS     R1,#+0
   \   00000196   0x200A             MOVS     R0,#+10
   \                     ??disk_ioctl_23:
   \   00000198   0x.... 0x....      BL       send_cmd
   \   0000019C   0xB9E8             CBNZ.N   R0,??disk_ioctl_16
   \   0000019E   0x2110             MOVS     R1,#+16
   \   000001A0   0xE014             B.N      ??disk_ioctl_25
    636                res = RES_OK;
    637              break;
    638          
    639            case MMC_GET_OCR :    /* Read OCR (4 bytes) */
    640              if (send_cmd(CMD58, 0) == 0) {  /* READ_OCR */
   \                     ??disk_ioctl_26:
   \   000001A2   0x2100             MOVS     R1,#+0
   \   000001A4   0x203A             MOVS     R0,#+58
   \   000001A6   0x.... 0x....      BL       send_cmd
   \   000001AA   0xB9B0             CBNZ.N   R0,??disk_ioctl_16
    641                for (n = 4; n; n--) *ptr++ = xchg_spi(0xFF);
   \   000001AC   0x2404             MOVS     R4,#+4
   \                     ??disk_ioctl_27:
   \   000001AE   0x.... 0x....      BL       ??Subroutine0_1
   \                     ??CrossCallReturnLabel_1:
   \   000001B2   0xF808 0x0B01      STRB     R0,[R8], #+1
   \   000001B6   0x1E64             SUBS     R4,R4,#+1
   \   000001B8   0xD1F9             BNE.N    ??disk_ioctl_27
    642                res = RES_OK;
   \   000001BA   0xE00B             B.N      ??disk_ioctl_7
    643              }
    644              break;
    645          
    646            case MMC_GET_SDSTAT : /* Read SD status (64 bytes) */
    647              if (send_cmd(ACMD13, 0) == 0) { /* SD_STATUS */
   \                     ??disk_ioctl_28:
   \   000001BC   0x2100             MOVS     R1,#+0
   \   000001BE   0x208D             MOVS     R0,#+141
   \   000001C0   0x.... 0x....      BL       send_cmd
   \   000001C4   0xB948             CBNZ.N   R0,??disk_ioctl_16
    648                xchg_spi(0xFF);
   \   000001C6   0x.... 0x....      BL       ??Subroutine0_1
    649                if (rcvr_datablock(ptr, 64))
   \                     ??CrossCallReturnLabel_0:
   \   000001CA   0x2140             MOVS     R1,#+64
   \                     ??disk_ioctl_25:
   \   000001CC   0x4640             MOV      R0,R8
   \   000001CE   0x.... 0x....      BL       rcvr_datablock
   \                     ??disk_ioctl_20:
   \   000001D2   0xB110             CBZ.N    R0,??disk_ioctl_16
    650                  res = RES_OK;
   \                     ??disk_ioctl_7:
   \   000001D4   0x2700             MOVS     R7,#+0
   \   000001D6   0xE000             B.N      ??disk_ioctl_16
    651              }
    652              break;
    653          
    654            default:
    655              res = RES_PARERR;
   \                     ??disk_ioctl_4:
   \   000001D8   0x2704             MOVS     R7,#+4
    656            }
    657          
    658            deselect();
   \                     ??disk_ioctl_16:
   \   000001DA   0x.... 0x....      BL       deselect
    659          
    660            return res;
   \   000001DE   0x4638             MOV      R0,R7
   \                     ??disk_ioctl_3:
   \   000001E0   0xB004             ADD      SP,SP,#+16
   \   000001E2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    661          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0x2110             MOVS     R1,#+16
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             B.N      rcvr_datablock
    662          
    663          
    664          /*-----------------------------------------------------------------------*/
    665          /* Device timer function  (Platform dependent)                           */
    666          /*-----------------------------------------------------------------------*/
    667          /* This function must be called from timer interrupt routine in period
    668          /  of 1 ms to generate card control timing.
    669          */
    670          

   \                                 In section .text, align 2, keep-with-next
    671          void disk_timerproc (void)
    672          {
    673            WORD n;
    674            BYTE s;
    675          
    676          
    677            n = Timer1;           /* 1kHz decrement timer stopped at 0 */
   \                     disk_timerproc:
   \   00000000   0x....             LDR.N    R0,??DataTable11_1
   \   00000002   0x6841             LDR      R1,[R0, #+4]
    678            if (n) Timer1 = --n;
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0xB111             CBZ.N    R1,??disk_timerproc_0
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0xB289             UXTH     R1,R1
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    679            n = Timer2;
   \                     ??disk_timerproc_0:
   \   0000000E   0x6881             LDR      R1,[R0, #+8]
    680            if (n) Timer2 = --n;
   \   00000010   0xB289             UXTH     R1,R1
   \   00000012   0xB111             CBZ.N    R1,??disk_timerproc_1
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x6081             STR      R1,[R0, #+8]
    681          
    682            s = Stat;
    683            if (WP)   /* Write protected */
    684              s |= STA_PROTECT;
    685            else    /* Write enabled */
    686              s &= ~STA_PROTECT;
    687            if (INS)  /* Card is in socket */
    688              s &= ~STA_NODISK;
    689            else    /* Socket empty */
    690              s |= (STA_NODISK | STA_NOINIT);
    691            Stat = s;
   \                     ??disk_timerproc_1:
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0xF001 0x01F9      AND      R1,R1,#0xF9
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    692          }
   \   00000022   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xF814 0x2B01      LDRB     R2,[R4], #+1
   \   00000004   0xF814 0x3B01      LDRB     R3,[R4], #+1
   \   00000008   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable11_3  ;; 0x400a0000
   \   00000004   0x210F             MOVS     R1,#+15
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0x2108             MOVS     R1,#+8
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x68C3             LDR      R3,[R0, #+12]
   \   00000002   0x075B             LSLS     R3,R3,#+29
   \   00000004   0xD5FC             BPL.N    ?Subroutine1
   \   00000006   0x6883             LDR      R3,[R0, #+8]
   \   00000008   0x6082             STR      R2,[R0, #+8]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x400A0008         DC32     0x400a0008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x400C0000         DC32     0x400c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x400A0000         DC32     0x400a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x4002001C         DC32     0x4002001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0xFFFFC30F         DC32     0xffffc30f
    693          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  deselect
              0 -> xchg_spi
       32  disk_initialize
             32 -> deselect
             32 -> select
             32 -> send_cmd
             32 -> xchg_spi
       40  disk_ioctl
             40 -> deselect
             40 -> disk_ioctl
             40 -> rcvr_datablock
             40 -> select
             40 -> send_cmd
             40 -> wait_ready
             40 -> xchg_spi
       16  disk_read
             16 -> deselect
             16 -> rcvr_datablock
             16 -> send_cmd
        0  disk_status
        0  disk_timerproc
       16  disk_write
             16 -> deselect
             16 -> send_cmd
             16 -> xmit_datablock
       16  rcvr_datablock
             16 -> xchg_spi
        8  select
              8 -> deselect
              8 -> wait_ready
              8 -> xchg_spi
       16  send_cmd
             16 -> deselect
             16 -> select
             16 -> send_cmd
             16 -> xchg_spi
        8  wait_ready
              8 -> xchg_spi
        0  xchg_spi
       16  xmit_datablock
             16 -> wait_ready
             16 -> xchg_spi


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       8  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine2
      14  ?Subroutine3
       6  ?Subroutine4
       8  ?Subroutine5
      12  Stat
          CardType
          Timer1
          Timer2
      16  deselect
     366  disk_initialize
     486  disk_ioctl
     106  disk_read
      12  disk_status
      36  disk_timerproc
     146  disk_write
     116  rcvr_datablock
      38  select
     120  send_cmd
      28  wait_ready
      18  xchg_spi
      96  xmit_datablock

 
    12 bytes in section .data
 1 668 bytes in section .text
 
 1 668 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
