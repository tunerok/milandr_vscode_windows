; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_bkp.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_bkp.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_bkp.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_bkp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  BKP_DeInit PROC
;;;101      */
;;;102    void BKP_DeInit(void)
000000  4938              LDR      r1,|L1.228|
;;;103    {
;;;104      #define BKP_RTC_CS_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CS) - BKP_OFFSET)/4)
;;;105      #define BKP_REG_0F_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0F) - BKP_OFFSET)/4)
;;;106      #define BKP_REG_0E_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0E) - BKP_OFFSET)/4)
;;;107      #define BKP_RTC_CNT_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CNT) - BKP_OFFSET)/4)
;;;108    
;;;109      uint32_t * _bkp = (uint32_t *) MDR_BKP_BASE;
;;;110      uint32_t i;
;;;111    
;;;112      for ( i = 0; i < BKP_REG_0E_NUM; i++)
000002  2000              MOVS     r0,#0
000004  e003              B        |L1.14|
                  |L1.6|
;;;113      {
;;;114        _bkp[i] = 0;
000006  2200              MOVS     r2,#0
000008  f8412020          STR      r2,[r1,r0,LSL #2]
00000c  1c40              ADDS     r0,r0,#1              ;112
                  |L1.14|
00000e  280e              CMP      r0,#0xe               ;112
000010  d3f9              BCC      |L1.6|
;;;115      }
;;;116    
;;;117      for ( i = BKP_RTC_CNT_NUM; i <= BKP_RTC_CS_NUM; i++)
000012  2010              MOVS     r0,#0x10
000014  e003              B        |L1.30|
                  |L1.22|
;;;118      {
;;;119        _bkp[i] = 0;
000016  2200              MOVS     r2,#0
000018  f8412020          STR      r2,[r1,r0,LSL #2]
00001c  1c40              ADDS     r0,r0,#1              ;117
                  |L1.30|
00001e  2814              CMP      r0,#0x14              ;117
000020  d9f9              BLS      |L1.22|
;;;120      }
;;;121    
;;;122      MDR_BKP -> REG_0E |= (uint32_t) (BKP_REG_0E_ON);
000022  4a30              LDR      r2,|L1.228|
000024  6b92              LDR      r2,[r2,#0x38]
000026  f4426200          ORR      r2,r2,#0x800
00002a  4b2e              LDR      r3,|L1.228|
00002c  639a              STR      r2,[r3,#0x38]
;;;123      MDR_BKP -> REG_0E &= (uint32_t) (BKP_REG_0E_OFF);
00002e  461a              MOV      r2,r3
000030  6b92              LDR      r2,[r2,#0x38]
000032  4b2d              LDR      r3,|L1.232|
000034  401a              ANDS     r2,r2,r3
000036  4b2b              LDR      r3,|L1.228|
000038  639a              STR      r2,[r3,#0x38]
;;;124      MDR_BKP -> REG_0F = (uint32_t) (BKP_REG_0F_LSI_ON);
00003a  f44f4200          MOV      r2,#0x8000
00003e  63da              STR      r2,[r3,#0x3c]
;;;125    }
000040  4770              BX       lr
;;;126    
                          ENDP

                  BKP_JTAGA_CMD PROC
;;;134      */
;;;135    void BKP_JTAGA_CMD(FunctionalState NewState)
000042  492a              LDR      r1,|L1.236|
;;;136    {
;;;137      /* Check the parameters */
;;;138      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;139    
;;;140      *(__IO uint32_t *) BKP_JTAGA_BB = (uint32_t)NewState;
000044  6008              STR      r0,[r1,#0]
;;;141    }
000046  4770              BX       lr
;;;142    
                          ENDP

                  BKP_JTAGB_CMD PROC
;;;150      */
;;;151    void BKP_JTAGB_CMD(FunctionalState NewState)
000048  4928              LDR      r1,|L1.236|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;155    
;;;156      *(__IO uint32_t *) BKP_JTAGB_BB = (uint32_t)NewState;
00004a  1d09              ADDS     r1,r1,#4
00004c  6008              STR      r0,[r1,#0]
;;;157    }
00004e  4770              BX       lr
;;;158    #endif
                          ENDP

                  BKP_RTCclkSource PROC
;;;168      */
;;;169    void BKP_RTCclkSource(uint32_t RTC_CLK)
000050  4a24              LDR      r2,|L1.228|
;;;170    {
;;;171    	uint32_t tmpreg;
;;;172    
;;;173    	/* Check the parameters */
;;;174    	assert_param(IS_RTC_CLK_SOURCE(RTC_CLK));
;;;175    	/* Clear BKP_REG0F[3:2] bits */
;;;176    	tmpreg = MDR_BKP ->REG_0F & (uint32_t) (~BKP_REG_0F_RTC_SEL_Msk );
000052  6bd2              LDR      r2,[r2,#0x3c]
000054  f022010c          BIC      r1,r2,#0xc
;;;177    	/* Set BKP_REG0F[3:2] bits according to RTC clock source*/
;;;178    	tmpreg |= BKP_REG_0F_RTC_SEL_Msk & RTC_CLK;
000058  f000020c          AND      r2,r0,#0xc
00005c  4311              ORRS     r1,r1,r2
;;;179    	MDR_BKP ->REG_0F = tmpreg;
00005e  4a21              LDR      r2,|L1.228|
000060  63d1              STR      r1,[r2,#0x3c]
;;;180    
;;;181    }
000062  4770              BX       lr
;;;182    
                          ENDP

                  BKP_RTC_Enable PROC
;;;190      */
;;;191    void BKP_RTC_Enable ( FunctionalState NewState )
000064  4921              LDR      r1,|L1.236|
;;;192    {
;;;193    	/* Check the parameters */
;;;194    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;195    #if defined (USE_MDR1986VE9x)
;;;196    	*(__IO uint32_t *) RTC_ENABLE_BB = (uint32_t) NewState;
000066  3178              ADDS     r1,r1,#0x78
000068  6008              STR      r0,[r1,#0]
;;;197    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;198    	if(NewState != DISABLE){
;;;199    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_EN;
;;;200    	}
;;;201    	else{
;;;202    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_EN;
;;;203    	}
;;;204    #endif
;;;205    }
00006a  4770              BX       lr
;;;206    
                          ENDP

                  BKP_RTC_Calibration PROC
;;;212      */
;;;213    void BKP_RTC_Calibration(uint32_t RTC_Calibration)
00006c  4a1d              LDR      r2,|L1.228|
;;;214    {
;;;215      uint32_t tmpreg;
;;;216    
;;;217      /* Check the parameters */
;;;218      assert_param(IS_RTC_CALIBRATION(RTC_Calibration));
;;;219      /* Clear BKP_REG0F[12:5] bits */
;;;220      tmpreg  = MDR_BKP -> REG_0F & (uint32_t) (~BKP_REG_0F_CAL_Msk);
00006e  6bd2              LDR      r2,[r2,#0x3c]
000070  f42251ff          BIC      r1,r2,#0x1fe0
;;;221      /* Set BKP_REG0F[12:5] bits according to RTC clock source*/
;;;222      tmpreg |= BKP_REG_0F_CAL_Msk & (RTC_Calibration << BKP_REG_0F_CAL_Pos);
000074  f44f52ff          MOV      r2,#0x1fe0
000078  ea021240          AND      r2,r2,r0,LSL #5
00007c  4311              ORRS     r1,r1,r2
;;;223      MDR_BKP -> REG_0F = tmpreg;
00007e  4a19              LDR      r2,|L1.228|
000080  63d1              STR      r1,[r2,#0x3c]
;;;224    }
000082  4770              BX       lr
;;;225    
                          ENDP

                  BKP_RTC_Reset PROC
;;;233      */
;;;234    void BKP_RTC_Reset ( FunctionalState NewState )
000084  4919              LDR      r1,|L1.236|
;;;235    {
;;;236    	/* Check the parameters */
;;;237    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;238    
;;;239    #if defined (USE_MDR1986VE9x)
;;;240    	*(__IO uint32_t *) RTC_RESET_BB = (uint32_t) NewState;
000086  31e4              ADDS     r1,r1,#0xe4
000088  6008              STR      r0,[r1,#0]
;;;241    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;242    	if(NewState != DISABLE){
;;;243    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_RESET;
;;;244    	}
;;;245    	else{
;;;246    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_RESET;
;;;247    	}
;;;248    #endif // #elif defined (USE_MDR1986VE3)
;;;249    }
00008a  4770              BX       lr
;;;250    
                          ENDP

                  BKP_RTC_ITConfig PROC
;;;261      */
;;;262    void BKP_RTC_ITConfig(uint32_t BKP_RTC_IT, FunctionalState NewState)
00008c  b129              CBZ      r1,|L1.154|
;;;263    {
;;;264      /* Check the parameters */
;;;265      assert_param(IS_RTC_CLK_IT(BKP_RTC_IT));
;;;266      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;267    
;;;268      if (NewState != DISABLE)
;;;269      {
;;;270        MDR_BKP->RTC_CS |= BKP_RTC_IT;
00008e  4a15              LDR      r2,|L1.228|
000090  6d12              LDR      r2,[r2,#0x50]
000092  4302              ORRS     r2,r2,r0
000094  4b13              LDR      r3,|L1.228|
000096  651a              STR      r2,[r3,#0x50]
000098  e004              B        |L1.164|
                  |L1.154|
;;;271      }
;;;272      else
;;;273      {
;;;274        MDR_BKP->RTC_CS &= (uint32_t)~BKP_RTC_IT;
00009a  4a12              LDR      r2,|L1.228|
00009c  6d12              LDR      r2,[r2,#0x50]
00009e  4382              BICS     r2,r2,r0
0000a0  4b10              LDR      r3,|L1.228|
0000a2  651a              STR      r2,[r3,#0x50]
                  |L1.164|
;;;275      }
;;;276    }
0000a4  4770              BX       lr
;;;277    
                          ENDP

                  BKP_RTC_GetCounter PROC
;;;282      */
;;;283    uint32_t BKP_RTC_GetCounter(void)
0000a6  480f              LDR      r0,|L1.228|
;;;284    {
;;;285      return MDR_BKP -> RTC_CNT;
0000a8  6c00              LDR      r0,[r0,#0x40]
;;;286    }
0000aa  4770              BX       lr
;;;287    
                          ENDP

                  BKP_RTC_SetCounter PROC
;;;292      */
;;;293    void BKP_RTC_SetCounter(uint32_t CounterValue)
0000ac  490d              LDR      r1,|L1.228|
;;;294    {
;;;295      MDR_BKP -> RTC_CNT = CounterValue;
0000ae  6408              STR      r0,[r1,#0x40]
;;;296    }
0000b0  4770              BX       lr
;;;297    
                          ENDP

                  BKP_RTC_SetAlarm PROC
;;;302      */
;;;303    void  BKP_RTC_SetAlarm(uint32_t AlarmValue)
0000b2  490c              LDR      r1,|L1.228|
;;;304    {
;;;305      MDR_BKP -> RTC_ALRM = AlarmValue;
0000b4  64c8              STR      r0,[r1,#0x4c]
;;;306    }
0000b6  4770              BX       lr
;;;307    
                          ENDP

                  BKP_RTC_GetDivider PROC
;;;312      */
;;;313    uint32_t BKP_RTC_GetDivider(void)
0000b8  480a              LDR      r0,|L1.228|
;;;314    {
;;;315      return MDR_BKP -> RTC_DIV;
0000ba  6c40              LDR      r0,[r0,#0x44]
;;;316    }
0000bc  4770              BX       lr
;;;317    
                          ENDP

                  BKP_RTC_SetPrescaler PROC
;;;323      */
;;;324    void BKP_RTC_SetPrescaler(uint32_t PrescalerValue)
0000be  4909              LDR      r1,|L1.228|
;;;325    {
;;;326      /* Check the parameter */
;;;327      assert_param(IS_BKP_PRESCALER_VALUE(PrescalerValue));
;;;328    
;;;329      MDR_BKP -> RTC_PRL = PrescalerValue;
0000c0  6488              STR      r0,[r1,#0x48]
;;;330    }
0000c2  4770              BX       lr
;;;331    
                          ENDP

                  BKP_RTC_WaitForUpdate PROC
;;;337      */
;;;338    void BKP_RTC_WaitForUpdate ( void )
0000c4  bf00              NOP      
                  |L1.198|
;;;339    {
;;;340    	/* Loop until WEC flag is set */
;;;341    #if defined (USE_MDR1986VE9x)
;;;342    	while (*(__IO uint32_t *) RTC_WEC_BB != 0);
0000c6  480a              LDR      r0,|L1.240|
0000c8  6800              LDR      r0,[r0,#0]
0000ca  2800              CMP      r0,#0
0000cc  d1fb              BNE      |L1.198|
;;;343    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;344    	while((MDR_BKP->RTC_CS & BKP_RTC_CS_WEC) == BKP_RTC_CS_WEC);
;;;345    #endif
;;;346    
;;;347    }
0000ce  4770              BX       lr
;;;348    
                          ENDP

                  BKP_RTC_GetFlagStatus PROC
;;;358      */
;;;359    FlagStatus BKP_RTC_GetFlagStatus(uint32_t BKP_RTC_FLAG)
0000d0  4601              MOV      r1,r0
;;;360    {
;;;361      FlagStatus status;
;;;362    
;;;363      /* Check the parameters */
;;;364      assert_param(IS_BKP_RTC_GET_FLAG(BKP_RTC_FLAG));
;;;365    
;;;366      if ((MDR_BKP -> RTC_CS & BKP_RTC_FLAG) != 0)
0000d2  4a04              LDR      r2,|L1.228|
0000d4  6d12              LDR      r2,[r2,#0x50]
0000d6  420a              TST      r2,r1
0000d8  d001              BEQ      |L1.222|
;;;367      {
;;;368        status = SET;
0000da  2001              MOVS     r0,#1
0000dc  e000              B        |L1.224|
                  |L1.222|
;;;369      }
;;;370      else
;;;371      {
;;;372        status = RESET;
0000de  2000              MOVS     r0,#0
                  |L1.224|
;;;373      }
;;;374      return status;
;;;375    }
0000e0  4770              BX       lr
;;;376    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L1.228|
                          DCD      0x400d8000
                  |L1.232|
                          DCD      0x7ffff8c0
                  |L1.236|
                          DCD      0x43b00718
                  |L1.240|
                          DCD      0x43b00a18

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_bkp.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH|
#line 144
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
