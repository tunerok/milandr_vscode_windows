; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_can.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_can.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_can.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_can.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;69       */
;;;70     void CAN_DeInit(MDR_CAN_TypeDef* CANx)
000000  2200              MOVS     r2,#0
;;;71     {
;;;72       uint32_t i;
;;;73     
;;;74       /* Check the parameters */
;;;75       assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;76     
;;;77       CANx->CONTROL = 0;
000002  6002              STR      r2,[r0,#0]
;;;78       CANx->STATUS = 0;
000004  6042              STR      r2,[r0,#4]
;;;79       CANx->BITTMNG = 0;
000006  6082              STR      r2,[r0,#8]
;;;80       CANx->INT_EN = 0;
000008  6102              STR      r2,[r0,#0x10]
;;;81       CANx->OVER = 0;
00000a  61c2              STR      r2,[r0,#0x1c]
;;;82       CANx->INT_RX = 0;
00000c  f8c020c0          STR      r2,[r0,#0xc0]
;;;83       CANx->INT_TX = 0;
000010  f8c020c8          STR      r2,[r0,#0xc8]
;;;84     
;;;85       for (i = 0; i < 32; i++)
000014  2100              MOVS     r1,#0
000016  e005              B        |L1.36|
                  |L1.24|
;;;86       {
;;;87         CANx->BUF_CON[i] = 0;
000018  2300              MOVS     r3,#0
00001a  f1000240          ADD      r2,r0,#0x40
00001e  f8423021          STR      r3,[r2,r1,LSL #2]
000022  1c49              ADDS     r1,r1,#1              ;85
                  |L1.36|
000024  2920              CMP      r1,#0x20              ;85
000026  d3f7              BCC      |L1.24|
;;;88       }
;;;89     }
000028  4770              BX       lr
;;;90     
                          ENDP

                  CAN_Init PROC
;;;103      */
;;;104    void CAN_Init(MDR_CAN_TypeDef* CANx, const CAN_InitTypeDef* CAN_InitStruct)
00002a  b570              PUSH     {r4-r6,lr}
;;;105    {
;;;106      uint32_t tmpreg_CONTROL = 0;
00002c  2200              MOVS     r2,#0
;;;107      uint32_t tmpreg_BITTMNG;
;;;108      uint32_t i;
;;;109    
;;;110      /* Check the parameters */
;;;111      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;112      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ROP));
;;;113      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_SAP));
;;;114      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_STM));
;;;115      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ROM));
;;;116      assert_param(IS_CAN_PSEG_VALUE(CAN_InitStruct->CAN_PSEG));
;;;117      assert_param(IS_CAN_SEG1_VALUE(CAN_InitStruct->CAN_SEG1));
;;;118      assert_param(IS_CAN_SEG2_VALUE(CAN_InitStruct->CAN_SEG2));
;;;119      assert_param(IS_CAN_SJW_VALUE(CAN_InitStruct->CAN_SJW));
;;;120      assert_param(IS_CAN_SAMPLING_MODE(CAN_InitStruct->CAN_SB));
;;;121    
;;;122      /* Configure CONTROL register*/
;;;123      if (CAN_InitStruct->CAN_ROP != DISABLE)
00002e  780d              LDRB     r5,[r1,#0]
000030  b10d              CBZ      r5,|L1.54|
;;;124      {
;;;125        tmpreg_CONTROL |= CAN_CONTROL_ROP;
000032  f0420210          ORR      r2,r2,#0x10
                  |L1.54|
;;;126      }
;;;127      if (CAN_InitStruct->CAN_SAP != DISABLE)
000036  784d              LDRB     r5,[r1,#1]
000038  b10d              CBZ      r5,|L1.62|
;;;128      {
;;;129        tmpreg_CONTROL |= CAN_CONTROL_SAP;
00003a  f0420208          ORR      r2,r2,#8
                  |L1.62|
;;;130      }
;;;131      if (CAN_InitStruct->CAN_STM != DISABLE)
00003e  788d              LDRB     r5,[r1,#2]
000040  b10d              CBZ      r5,|L1.70|
;;;132      {
;;;133        tmpreg_CONTROL |= CAN_CONTROL_STM;
000042  f0420204          ORR      r2,r2,#4
                  |L1.70|
;;;134      }
;;;135      if (CAN_InitStruct->CAN_ROM != DISABLE)
000046  78cd              LDRB     r5,[r1,#3]
000048  b10d              CBZ      r5,|L1.78|
;;;136      {
;;;137        tmpreg_CONTROL |= CAN_CONTROL_ROM;
00004a  f0420202          ORR      r2,r2,#2
                  |L1.78|
;;;138      }
;;;139      CANx->CONTROL = tmpreg_CONTROL;
00004e  6002              STR      r2,[r0,#0]
;;;140    
;;;141      /* Configure BITTMNG register*/
;;;142      tmpreg_BITTMNG = CAN_InitStruct->CAN_PSEG + CAN_InitStruct->CAN_SEG1 +
000050  e9d15601          LDRD     r5,r6,[r1,#4]
000054  4435              ADD      r5,r5,r6
000056  68ce              LDR      r6,[r1,#0xc]
000058  4435              ADD      r5,r5,r6
00005a  690e              LDR      r6,[r1,#0x10]
00005c  4435              ADD      r5,r5,r6
00005e  8b0e              LDRH     r6,[r1,#0x18]
000060  19ac              ADDS     r4,r5,r6
;;;143                       CAN_InitStruct->CAN_SEG2 + CAN_InitStruct->CAN_SJW +
;;;144                       (uint32_t)(CAN_InitStruct->CAN_BRP);
;;;145      tmpreg_BITTMNG |= CAN_InitStruct->CAN_SB;
000062  694d              LDR      r5,[r1,#0x14]
000064  432c              ORRS     r4,r4,r5
;;;146      CANx->BITTMNG = tmpreg_BITTMNG;
000066  6084              STR      r4,[r0,#8]
;;;147    
;;;148      /* Initialize Filters */
;;;149      for (i = 0; i < 32; i++)
000068  2300              MOVS     r3,#0
00006a  e00a              B        |L1.130|
                  |L1.108|
;;;150      {
;;;151        CANx->CAN_BUF_FILTER[i].FILTER = 0;
00006c  2600              MOVS     r6,#0
00006e  f50065a0          ADD      r5,r0,#0x500
000072  eb0505c3          ADD      r5,r5,r3,LSL #3
000076  606e              STR      r6,[r5,#4]
;;;152        CANx->CAN_BUF_FILTER[i].MASK = 0;
000078  f50065a0          ADD      r5,r0,#0x500
00007c  f8456033          STR      r6,[r5,r3,LSL #3]
000080  1c5b              ADDS     r3,r3,#1              ;149
                  |L1.130|
000082  2b20              CMP      r3,#0x20              ;149
000084  d3f2              BCC      |L1.108|
;;;153      }
;;;154    
;;;155      /* Configure OVER register*/
;;;156      CANx->OVER = (uint32_t)(CAN_InitStruct->CAN_OVER_ERROR_MAX);
000086  7e8d              LDRB     r5,[r1,#0x1a]
000088  61c5              STR      r5,[r0,#0x1c]
;;;157    }
00008a  bd70              POP      {r4-r6,pc}
;;;158    
                          ENDP

                  CAN_StructInit PROC
;;;164      */
;;;165    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
00008c  2100              MOVS     r1,#0
;;;166    {
;;;167      /* Reset CAN init structure parameters values */
;;;168      /* Own packet reception: disabled */
;;;169      CAN_InitStruct->CAN_ROP = DISABLE;
00008e  7001              STRB     r1,[r0,#0]
;;;170      /* Sending ACK on own packets: disabled */
;;;171      CAN_InitStruct->CAN_SAP = DISABLE;
000090  7041              STRB     r1,[r0,#1]
;;;172      /* Self Test mode: disabled */
;;;173      CAN_InitStruct->CAN_STM = DISABLE;
000092  7081              STRB     r1,[r0,#2]
;;;174      /* Read Only mode: disabled */
;;;175      CAN_InitStruct->CAN_ROM = DISABLE;
000094  70c1              STRB     r1,[r0,#3]
;;;176      /* CAN_PSEG member */
;;;177      CAN_InitStruct->CAN_PSEG = CAN_PSEG_Mul_1TQ;
000096  6041              STR      r1,[r0,#4]
;;;178      /* CAN_SEG1 member */
;;;179      CAN_InitStruct->CAN_SEG1 = CAN_SEG1_Mul_2TQ;
000098  f44f2100          MOV      r1,#0x80000
00009c  6081              STR      r1,[r0,#8]
;;;180      /* CAN_SEG2 member */
;;;181      CAN_InitStruct->CAN_SEG2 = CAN_SEG2_Mul_6TQ;
00009e  f04f71a0          MOV      r1,#0x1400000
0000a2  60c1              STR      r1,[r0,#0xc]
;;;182      /* CAN_SEG2 member */
;;;183      CAN_InitStruct->CAN_SJW = CAN_SJW_Mul_1TQ;
0000a4  2100              MOVS     r1,#0
0000a6  6101              STR      r1,[r0,#0x10]
;;;184      /* Sampling mode member */
;;;185      CAN_InitStruct->CAN_SB = CAN_SB_1_SAMPLE;
0000a8  6141              STR      r1,[r0,#0x14]
;;;186      /* CAN_BRP member */
;;;187      CAN_InitStruct->CAN_BRP = 0;
0000aa  8301              STRH     r1,[r0,#0x18]
;;;188      /* CAN_OVER_ERROR_MAX member */
;;;189      CAN_InitStruct->CAN_OVER_ERROR_MAX = 255;
0000ac  21ff              MOVS     r1,#0xff
0000ae  7681              STRB     r1,[r0,#0x1a]
;;;190    }
0000b0  4770              BX       lr
;;;191    
                          ENDP

                  CAN_FilterInit PROC
;;;201      */
;;;202    void CAN_FilterInit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_FilterInitTypeDef* CAN_FilterInitStruct)
0000b2  b510              PUSH     {r4,lr}
;;;203    {
;;;204      /* Check the parameters */
;;;205      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;206      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;207      assert_param(IS_CAN_ID(CAN_FilterInitStruct->Filter_ID));
;;;208      assert_param(IS_CAN_ID(CAN_FilterInitStruct->Mask_ID));
;;;209    
;;;210      CANx->CAN_BUF_FILTER[BufferNumber].FILTER  = CAN_FilterInitStruct->Filter_ID;
0000b4  f50063a0          ADD      r3,r0,#0x500
0000b8  eb0303c1          ADD      r3,r3,r1,LSL #3
0000bc  6814              LDR      r4,[r2,#0]
0000be  605c              STR      r4,[r3,#4]
;;;211      CANx->CAN_BUF_FILTER[BufferNumber].MASK    = CAN_FilterInitStruct->Mask_ID;
0000c0  f50063a0          ADD      r3,r0,#0x500
0000c4  6854              LDR      r4,[r2,#4]
0000c6  f8434031          STR      r4,[r3,r1,LSL #3]
;;;212    }
0000ca  bd10              POP      {r4,pc}
;;;213    
                          ENDP

                  CAN_ITConfig PROC
;;;225      */
;;;226    void CAN_ITConfig(MDR_CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
0000cc  b11a              CBZ      r2,|L1.214|
;;;227    {
;;;228      /* Check the parameters */
;;;229      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;230      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;231      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;232    
;;;233      if (NewState != DISABLE)
;;;234      {
;;;235        CANx->INT_EN |= CAN_IT;
0000ce  6903              LDR      r3,[r0,#0x10]
0000d0  430b              ORRS     r3,r3,r1
0000d2  6103              STR      r3,[r0,#0x10]
0000d4  e002              B        |L1.220|
                  |L1.214|
;;;236      }
;;;237      else
;;;238      {
;;;239        CANx->INT_EN &= ~CAN_IT;
0000d6  6903              LDR      r3,[r0,#0x10]
0000d8  438b              BICS     r3,r3,r1
0000da  6103              STR      r3,[r0,#0x10]
                  |L1.220|
;;;240      }
;;;241    }
0000dc  4770              BX       lr
;;;242    
                          ENDP

                  CAN_GetDisabledBuffer PROC
;;;251      */
;;;252    uint32_t CAN_GetDisabledBuffer(MDR_CAN_TypeDef* CANx)
0000de  4601              MOV      r1,r0
;;;253    {
;;;254      uint32_t buffer_number;
;;;255    
;;;256      /* Check the parameters */
;;;257      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;258    
;;;259      for (buffer_number = 0;
0000e0  2000              MOVS     r0,#0
0000e2  e000              B        |L1.230|
                  |L1.228|
;;;260    	  ((buffer_number < CAN_BUFFER_NUMBER) &&  ((CANx->BUF_CON[buffer_number] & CAN_STATUS_EN) != 0));
;;;261           buffer_number++)
0000e4  1c40              ADDS     r0,r0,#1
                  |L1.230|
0000e6  2820              CMP      r0,#0x20              ;260
0000e8  d206              BCS      |L1.248|
0000ea  f1010240          ADD      r2,r1,#0x40           ;260
0000ee  f8522020          LDR      r2,[r2,r0,LSL #2]     ;260
0000f2  f0120f01          TST      r2,#1                 ;260
0000f6  d1f5              BNE      |L1.228|
                  |L1.248|
;;;262      {
;;;263      }
;;;264    
;;;265      return buffer_number;
;;;266    }
0000f8  4770              BX       lr
;;;267    
                          ENDP

                  CAN_GetEmptyTransferBuffer PROC
;;;275      */
;;;276    uint32_t CAN_GetEmptyTransferBuffer(MDR_CAN_TypeDef* CANx)
0000fa  4601              MOV      r1,r0
;;;277    {
;;;278      uint32_t buffer_number;
;;;279    
;;;280      /* Check the parameters */
;;;281      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;282    
;;;283      for (buffer_number = 0; (buffer_number < CAN_BUFFER_NUMBER) &&
0000fc  2000              MOVS     r0,#0
0000fe  e000              B        |L1.258|
                  |L1.256|
;;;284            ((CANx->BUF_CON[buffer_number] & (CAN_STATUS_EN | CAN_STATUS_TX_REQ | CAN_STATUS_RX_TXn)) != CAN_STATUS_EN);
;;;285            buffer_number++)
000100  1c40              ADDS     r0,r0,#1
                  |L1.258|
000102  2820              CMP      r0,#0x20              ;283
000104  d207              BCS      |L1.278|
000106  f1010240          ADD      r2,r1,#0x40           ;284
00010a  f8522020          LDR      r2,[r2,r0,LSL #2]     ;284
00010e  f0020223          AND      r2,r2,#0x23           ;284
000112  2a01              CMP      r2,#1                 ;284
000114  d1f4              BNE      |L1.256|
                  |L1.278|
;;;286      {
;;;287      }
;;;288      return buffer_number;
;;;289    }
000116  4770              BX       lr
;;;290    
                          ENDP

                  CAN_Transmit PROC
;;;299      */
;;;300    void CAN_Transmit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_TxMsgTypeDef* TxMessage)
000118  b530              PUSH     {r4,r5,lr}
;;;301    {
00011a  4603              MOV      r3,r0
;;;302      uint32_t tmpreg;
;;;303    
;;;304      /* Check the parameters */
;;;305      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;306      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;307      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;308      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;309      assert_param(IS_FUNCTIONAL_STATE(TxMessage->PRIOR_0));
;;;310      assert_param(IS_CAN_ID(TxMessage->ID));
;;;311    
;;;312      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;313      /* Packet format */
;;;314      if (TxMessage->IDE == CAN_ID_STD)
00011c  7954              LDRB     r4,[r2,#5]
00011e  b91c              CBNZ     r4,|L1.296|
;;;315      {
;;;316        /* Standard */
;;;317        tmpreg = CAN_BUF_DLC_STD + TxMessage->DLC;
000120  7994              LDRB     r4,[r2,#6]
000122  f5046020          ADD      r0,r4,#0xa00
000126  e002              B        |L1.302|
                  |L1.296|
;;;318      }
;;;319      else
;;;320      {
;;;321        /* Extended */
;;;322        tmpreg = CAN_BUF_DLC_EXT + TxMessage->DLC;
000128  7994              LDRB     r4,[r2,#6]
00012a  f50450d0          ADD      r0,r4,#0x1a00
                  |L1.302|
;;;323      }
;;;324      CANx->CAN_BUF[BufferNumber].DLC = tmpreg;
00012e  f5037400          ADD      r4,r3,#0x200
000132  eb041401          ADD      r4,r4,r1,LSL #4
000136  6060              STR      r0,[r4,#4]
;;;325      CANx->CAN_BUF[BufferNumber].ID  = TxMessage->ID;
000138  f5037400          ADD      r4,r3,#0x200
00013c  eb041401          ADD      r4,r4,r1,LSL #4
000140  6815              LDR      r5,[r2,#0]
000142  6025              STR      r5,[r4,#0]
;;;326    
;;;327      /* Buffer data unit */
;;;328      CANx->CAN_BUF[BufferNumber].DATAL = TxMessage->Data[0];
000144  f5037400          ADD      r4,r3,#0x200
000148  eb041401          ADD      r4,r4,r1,LSL #4
00014c  6895              LDR      r5,[r2,#8]
00014e  60a5              STR      r5,[r4,#8]
;;;329      CANx->CAN_BUF[BufferNumber].DATAH = TxMessage->Data[1];
000150  f5037400          ADD      r4,r3,#0x200
000154  eb041401          ADD      r4,r4,r1,LSL #4
000158  68d5              LDR      r5,[r2,#0xc]
00015a  60e5              STR      r5,[r4,#0xc]
;;;330    
;;;331      /* Configure CAN_BUF_CON register */
;;;332      tmpreg = 0;
00015c  2000              MOVS     r0,#0
;;;333      /* Transmission priority */
;;;334      if (TxMessage->PRIOR_0 != DISABLE)
00015e  7914              LDRB     r4,[r2,#4]
000160  b10c              CBZ      r4,|L1.358|
;;;335      {
;;;336        tmpreg |= CAN_BUF_CON_PRIOR_0;
000162  f0400010          ORR      r0,r0,#0x10
                  |L1.358|
;;;337      }
;;;338      /* Set transmission request bit */
;;;339      tmpreg |= CAN_BUF_CON_TX_REQ;
000166  f0400020          ORR      r0,r0,#0x20
;;;340      /* Enable buffer */
;;;341      tmpreg |= CAN_BUF_CON_EN;
00016a  f0400001          ORR      r0,r0,#1
;;;342    
;;;343      CANx->BUF_CON[BufferNumber] = tmpreg;
00016e  f1030440          ADD      r4,r3,#0x40
000172  f8440021          STR      r0,[r4,r1,LSL #2]
;;;344    }
000176  bd30              POP      {r4,r5,pc}
;;;345    
                          ENDP

                  CAN_SendRTR PROC
;;;354      */
;;;355    void CAN_SendRTR(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RTRMessageTypeDef* RTRMessage)
000178  b530              PUSH     {r4,r5,lr}
;;;356    {
00017a  4603              MOV      r3,r0
;;;357      uint32_t tmpreg;
;;;358    
;;;359      /* Check the parameters */
;;;360      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;361      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;362      assert_param(IS_CAN_IDTYPE(RTRMessage->IDE));
;;;363      assert_param(IS_FUNCTIONAL_STATE(RTRMessage->PRIOR_0));
;;;364      assert_param(IS_CAN_ID(RTRMessage->ID));
;;;365    
;;;366      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;367      /* Packet format */
;;;368      if (RTRMessage->IDE == CAN_ID_STD)
00017c  7954              LDRB     r4,[r2,#5]
00017e  b914              CBNZ     r4,|L1.390|
;;;369      {
;;;370        /* Standard */
;;;371        tmpreg = CAN_BUF_DLC_STD;
000180  f44f6020          MOV      r0,#0xa00
000184  e001              B        |L1.394|
                  |L1.390|
;;;372      }
;;;373      else
;;;374      {
;;;375        /* Extended */
;;;376        tmpreg = CAN_BUF_DLC_EXT;
000186  f44f50d0          MOV      r0,#0x1a00
                  |L1.394|
;;;377      }
;;;378      CANx->CAN_BUF[BufferNumber].DLC = tmpreg + CAN_RTR_REMOTE;
00018a  f5007480          ADD      r4,r0,#0x100
00018e  f5037500          ADD      r5,r3,#0x200
000192  eb051501          ADD      r5,r5,r1,LSL #4
000196  606c              STR      r4,[r5,#4]
;;;379      CANx->CAN_BUF[BufferNumber].ID  = RTRMessage->ID;
000198  f5037400          ADD      r4,r3,#0x200
00019c  eb041401          ADD      r4,r4,r1,LSL #4
0001a0  6815              LDR      r5,[r2,#0]
0001a2  6025              STR      r5,[r4,#0]
;;;380    
;;;381      /* Configure CAN_BUF_CON register */
;;;382      tmpreg = 0;
0001a4  2000              MOVS     r0,#0
;;;383      /* Transmission priority */
;;;384      if (RTRMessage->PRIOR_0 != DISABLE)
0001a6  7914              LDRB     r4,[r2,#4]
0001a8  b10c              CBZ      r4,|L1.430|
;;;385      {
;;;386        tmpreg |= CAN_BUF_CON_PRIOR_0;
0001aa  f0400010          ORR      r0,r0,#0x10
                  |L1.430|
;;;387      }
;;;388      /* Set transmission request bit */
;;;389      tmpreg |= CAN_BUF_CON_TX_REQ;
0001ae  f0400020          ORR      r0,r0,#0x20
;;;390      /* Enable buffer */
;;;391      tmpreg |= CAN_BUF_CON_EN;
0001b2  f0400001          ORR      r0,r0,#1
;;;392    
;;;393      CANx->BUF_CON[BufferNumber] = tmpreg;
0001b6  f1030440          ADD      r4,r3,#0x40
0001ba  f8440021          STR      r0,[r4,r1,LSL #2]
;;;394    }
0001be  bd30              POP      {r4,r5,pc}
;;;395    
                          ENDP

                  CAN_RTRReply PROC
;;;405    
;;;406    void CAN_RTRReply(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RTRReplyTypeDef* RTRReplyMessage)
0001c0  b530              PUSH     {r4,r5,lr}
;;;407    {
;;;408      uint32_t tmpreg;
;;;409    
;;;410      /* Check the parameters */
;;;411      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;412      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;413      assert_param(IS_CAN_IDTYPE(RTRReplyMessage->IDE));
;;;414      assert_param(IS_CAN_ID(RTRReplyMessage->ID));
;;;415      assert_param(IS_CAN_DLC(RTRReplyMessage->DLC));
;;;416    
;;;417      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;418      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;419      /* Packet format */
;;;420      if (RTRReplyMessage->IDE == CAN_ID_STD)
0001c2  7914              LDRB     r4,[r2,#4]
0001c4  b91c              CBNZ     r4,|L1.462|
;;;421      {
;;;422        /* Standard */
;;;423        tmpreg = CAN_BUF_DLC_STD + RTRReplyMessage->DLC;
0001c6  7954              LDRB     r4,[r2,#5]
0001c8  f5046320          ADD      r3,r4,#0xa00
0001cc  e002              B        |L1.468|
                  |L1.462|
;;;424      }
;;;425      else
;;;426      {
;;;427        /* Extended */
;;;428        tmpreg = CAN_BUF_DLC_EXT + RTRReplyMessage->DLC;
0001ce  7954              LDRB     r4,[r2,#5]
0001d0  f50453d0          ADD      r3,r4,#0x1a00
                  |L1.468|
;;;429      }
;;;430      CANx->CAN_BUF[BufferNumber].DLC = tmpreg;
0001d4  f5007400          ADD      r4,r0,#0x200
0001d8  eb041401          ADD      r4,r4,r1,LSL #4
0001dc  6063              STR      r3,[r4,#4]
;;;431      CANx->CAN_BUF[BufferNumber].ID  = RTRReplyMessage->ID;
0001de  f5007400          ADD      r4,r0,#0x200
0001e2  eb041401          ADD      r4,r4,r1,LSL #4
0001e6  6815              LDR      r5,[r2,#0]
0001e8  6025              STR      r5,[r4,#0]
;;;432    
;;;433      /* Buffer data unit */
;;;434      CANx->CAN_BUF[BufferNumber].DATAL = RTRReplyMessage->Data[0];
0001ea  f5007400          ADD      r4,r0,#0x200
0001ee  eb041401          ADD      r4,r4,r1,LSL #4
0001f2  6895              LDR      r5,[r2,#8]
0001f4  60a5              STR      r5,[r4,#8]
;;;435      CANx->CAN_BUF[BufferNumber].DATAH = RTRReplyMessage->Data[1];
0001f6  f5007400          ADD      r4,r0,#0x200
0001fa  eb041401          ADD      r4,r4,r1,LSL #4
0001fe  68d5              LDR      r5,[r2,#0xc]
000200  60e5              STR      r5,[r4,#0xc]
;;;436    
;;;437      /* Configure CAN_BUF_CON register */
;;;438      /* Set RTR_EN bit */
;;;439      tmpreg = CAN_STATUS_RTR_EN;
000202  2308              MOVS     r3,#8
;;;440      /* Enable buffer */
;;;441      tmpreg |= CAN_BUF_CON_EN;
000204  f0430301          ORR      r3,r3,#1
;;;442    
;;;443      CANx->BUF_CON[BufferNumber] = tmpreg;
000208  f1000440          ADD      r4,r0,#0x40
00020c  f8443021          STR      r3,[r4,r1,LSL #2]
;;;444    }
000210  bd30              POP      {r4,r5,pc}
;;;445    
                          ENDP

                  CAN_Receive PROC
;;;456      */
;;;457    void CAN_Receive(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, FunctionalState OverWrite)
000212  b510              PUSH     {r4,lr}
;;;458    {
;;;459      uint32_t tmpreg = 0;
000214  2300              MOVS     r3,#0
;;;460    
;;;461      /* Check the parameters */
;;;462      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;463      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;464      assert_param(IS_FUNCTIONAL_STATE(OverWrite));
;;;465    
;;;466      /* Configure CAN_BUF_CON register */
;;;467      /* Overwrite mode */
;;;468      if (OverWrite != DISABLE)
000216  b102              CBZ      r2,|L1.538|
;;;469      {
;;;470        tmpreg = CAN_BUF_CON_OVER_EN;
000218  2304              MOVS     r3,#4
                  |L1.538|
;;;471      }
;;;472      /* Configure buffer for receiving and enable it */
;;;473      tmpreg |= CAN_BUF_CON_RX_TXN | CAN_BUF_CON_EN;
00021a  f0430303          ORR      r3,r3,#3
;;;474    
;;;475      CANx->BUF_CON[BufferNumber] = tmpreg;
00021e  f1000440          ADD      r4,r0,#0x40
000222  f8443021          STR      r3,[r4,r1,LSL #2]
;;;476    }
000226  bd10              POP      {r4,pc}
;;;477    
                          ENDP

                  CAN_ReadBufferSFR PROC
;;;910      */
;;;911    static __INLINE uint32_t CAN_ReadBufferSFR(__IO uint32_t* SFR)
000228  4601              MOV      r1,r0
;;;912    {
;;;913    #ifdef WORKAROUND_MDR32F9QX_ERROR_0002
;;;914      /*
;;;915       * MDR32F9Qx Series Errata Notice, Error 0002:
;;;916       * The registers CAN_BUFxx_ID, CAN_BUFxx_DLC, CAN_BUFxx_DATAL,
;;;917       * CAN_BUFxx_DATAH, CAN_BUFxx_MASK or CAN_BUFxx_FILTER value
;;;918       * may be incorrectly read as 0 if CAN controller accessed any
;;;919       * of that registers at the moment of reading.
;;;920       * In such case, another read should be performed in a time less
;;;921       * than minimum CAN package.
;;;922       */
;;;923      uint32_t tmpreg;
;;;924    
;;;925      __disable_irq();
00022a  b672              CPSID    i
;;;926      tmpreg = *SFR;
00022c  6808              LDR      r0,[r1,#0]
;;;927      if (tmpreg == 0)
00022e  b900              CBNZ     r0,|L1.562|
;;;928      {
;;;929        tmpreg = *SFR;
000230  6808              LDR      r0,[r1,#0]
                  |L1.562|
;;;930      }
;;;931      __enable_irq();
000232  b662              CPSIE    i
;;;932      return tmpreg;
;;;933    #else
;;;934      return *SFR;
;;;935    #endif  /* WORKAROUND_MDR32F9QX_ERROR_0002 */
;;;936    }
000234  4770              BX       lr
;;;937    
                          ENDP

                  CAN_GetReceivedData PROC
;;;486      */
;;;487    void CAN_GetReceivedData(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_DataTypeDef RxBuffer)
000236  b570              PUSH     {r4-r6,lr}
;;;488    {
000238  4604              MOV      r4,r0
00023a  460d              MOV      r5,r1
00023c  4616              MOV      r6,r2
;;;489      /* Check the parameters */
;;;490      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;491      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;492    
;;;493      RxBuffer[0] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAL));
00023e  f5047100          ADD      r1,r4,#0x200
000242  eb011105          ADD      r1,r1,r5,LSL #4
000246  f1010008          ADD      r0,r1,#8
00024a  f7fffffe          BL       CAN_ReadBufferSFR
00024e  6030              STR      r0,[r6,#0]
;;;494      RxBuffer[1] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAH));
000250  f5047100          ADD      r1,r4,#0x200
000254  eb011105          ADD      r1,r1,r5,LSL #4
000258  f101000c          ADD      r0,r1,#0xc
00025c  f7fffffe          BL       CAN_ReadBufferSFR
000260  6070              STR      r0,[r6,#4]
;;;495    }
000262  bd70              POP      {r4-r6,pc}
;;;496    
                          ENDP

                  CAN_GetRawReceivedData PROC
;;;505      */
;;;506    void CAN_GetRawReceivedData(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RxMsgTypeDef* RxMessage)
000264  e92d41f0          PUSH     {r4-r8,lr}
;;;507    {
000268  4605              MOV      r5,r0
00026a  460e              MOV      r6,r1
00026c  4614              MOV      r4,r2
;;;508      uint32_t tmpreg;
;;;509    
;;;510      /* Check the parameters */
;;;511      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;512      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;513    
;;;514      /* Get the DLC */
;;;515      tmpreg = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DLC));
00026e  f5057100          ADD      r1,r5,#0x200
000272  eb011106          ADD      r1,r1,r6,LSL #4
000276  1d08              ADDS     r0,r1,#4
000278  f7fffffe          BL       CAN_ReadBufferSFR
00027c  4607              MOV      r7,r0
;;;516    
;;;517      RxMessage->Rx_Header.DLC = (uint8_t)(tmpreg & CAN_DLC_DATA_LENGTH);
00027e  f007000f          AND      r0,r7,#0xf
000282  71a0              STRB     r0,[r4,#6]
;;;518      /* Get the IDE */
;;;519      RxMessage->Rx_Header.IDE = CAN_ID_STD;
000284  2000              MOVS     r0,#0
000286  7160              STRB     r0,[r4,#5]
;;;520      if ((tmpreg & CAN_DLC_IDE) != 0)
000288  f4175f80          TST      r7,#0x1000
00028c  d001              BEQ      |L1.658|
;;;521      {
;;;522        RxMessage->Rx_Header.IDE = CAN_ID_EXT;
00028e  2001              MOVS     r0,#1
000290  7160              STRB     r0,[r4,#5]
                  |L1.658|
;;;523      }
;;;524      /* Get the OVER_EN */
;;;525      RxMessage->Rx_Header.OVER_EN = DISABLE;
000292  2000              MOVS     r0,#0
000294  7120              STRB     r0,[r4,#4]
;;;526      tmpreg = CAN_ReadBufferSFR(&(CANx->BUF_CON[BufferNumber]));
000296  f1050140          ADD      r1,r5,#0x40
00029a  eb010086          ADD      r0,r1,r6,LSL #2
00029e  f7fffffe          BL       CAN_ReadBufferSFR
0002a2  4607              MOV      r7,r0
;;;527      if ((tmpreg & CAN_BUF_CON_OVER_EN) != 0)
0002a4  f0170f04          TST      r7,#4
0002a8  d001              BEQ      |L1.686|
;;;528      {
;;;529        RxMessage->Rx_Header.OVER_EN = ENABLE;
0002aa  2001              MOVS     r0,#1
0002ac  7120              STRB     r0,[r4,#4]
                  |L1.686|
;;;530      }
;;;531      /* Get the Id */
;;;532      RxMessage->Rx_Header.ID = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].ID));
0002ae  f5057100          ADD      r1,r5,#0x200
0002b2  eb011006          ADD      r0,r1,r6,LSL #4
0002b6  f7fffffe          BL       CAN_ReadBufferSFR
0002ba  6020              STR      r0,[r4,#0]
;;;533    
;;;534      /* Get the data field */
;;;535      RxMessage->Data[0] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAL));
0002bc  f5057100          ADD      r1,r5,#0x200
0002c0  eb011106          ADD      r1,r1,r6,LSL #4
0002c4  f1010008          ADD      r0,r1,#8
0002c8  f7fffffe          BL       CAN_ReadBufferSFR
0002cc  60a0              STR      r0,[r4,#8]
;;;536      RxMessage->Data[1] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAH));
0002ce  f5057100          ADD      r1,r5,#0x200
0002d2  eb011106          ADD      r1,r1,r6,LSL #4
0002d6  f101000c          ADD      r0,r1,#0xc
0002da  f7fffffe          BL       CAN_ReadBufferSFR
0002de  60e0              STR      r0,[r4,#0xc]
;;;537    }
0002e0  e8bd81f0          POP      {r4-r8,pc}
;;;538    
                          ENDP

                  CAN_BufferRelease PROC
;;;546      */
;;;547    void CAN_BufferRelease(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
0002e4  f1000340          ADD      r3,r0,#0x40
;;;548    {
;;;549      uint32_t tmpreg;
;;;550    
;;;551      /* Check the parameters */
;;;552      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;553      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;554    
;;;555      tmpreg = CANx->BUF_CON[BufferNumber];
0002e8  f8532021          LDR      r2,[r3,r1,LSL #2]
;;;556      tmpreg &= ~CAN_STATUS_EN;
0002ec  f0220201          BIC      r2,r2,#1
;;;557      CANx->BUF_CON[BufferNumber] = tmpreg;
0002f0  f8432021          STR      r2,[r3,r1,LSL #2]
;;;558    }
0002f4  4770              BX       lr
;;;559    
                          ENDP

                  CAN_Cmd PROC
;;;568      */
;;;569    void CAN_Cmd(MDR_CAN_TypeDef* CANx, FunctionalState NewState)
0002f6  460a              MOV      r2,r1
;;;570    {
;;;571      uint32_t tmpreg_CONTROL;
;;;572    
;;;573      /* Check the parameters */
;;;574      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;575      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;576    
;;;577      tmpreg_CONTROL = CANx->CONTROL;
0002f8  6801              LDR      r1,[r0,#0]
;;;578    
;;;579      /* Form new value */
;;;580      if (NewState != DISABLE)
0002fa  b112              CBZ      r2,|L1.770|
;;;581      {
;;;582        /* Enable CANx by setting the CAN_EN bit in the CONTROL register */
;;;583        tmpreg_CONTROL |= CAN_CONTROL_CAN_EN;
0002fc  f0410101          ORR      r1,r1,#1
000300  e001              B        |L1.774|
                  |L1.770|
;;;584      }
;;;585      else
;;;586      {
;;;587        /* Disable CANx by resetting the CAN_EN bit in the CONTROL register */
;;;588        tmpreg_CONTROL &= ~CAN_CONTROL_CAN_EN;
000302  f0210101          BIC      r1,r1,#1
                  |L1.774|
;;;589      }
;;;590    
;;;591      /* Configure CONTROL register with new value */
;;;592      CANx->CONTROL = tmpreg_CONTROL;
000306  6001              STR      r1,[r0,#0]
;;;593    }
000308  4770              BX       lr
;;;594    
                          ENDP

                  CAN_GetStatus PROC
;;;601      */
;;;602    uint32_t CAN_GetStatus(MDR_CAN_TypeDef* CANx)
00030a  4601              MOV      r1,r0
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;606    
;;;607      return CANx->STATUS;
00030c  6848              LDR      r0,[r1,#4]
;;;608    }
00030e  4770              BX       lr
;;;609    
                          ENDP

                  CAN_GetBufferStatus PROC
;;;617      */
;;;618    uint32_t CAN_GetBufferStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000310  4602              MOV      r2,r0
;;;619    {
;;;620      /* Check the parameters */
;;;621      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;622      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;623    
;;;624      return CANx->BUF_CON[BufferNumber];
000312  f1020040          ADD      r0,r2,#0x40
000316  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;625    }
00031a  4770              BX       lr
;;;626    
                          ENDP

                  CAN_GetITState PROC
;;;636      */
;;;637    ITStatus CAN_GetITState(MDR_CAN_TypeDef* CANx, uint32_t CAN_IT)
00031c  4602              MOV      r2,r0
;;;638    {
;;;639      ITStatus bitstatus;
;;;640    
;;;641      /* Check the parameters */
;;;642      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;643      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;644    
;;;645      if ((CANx->INT_EN & CAN_IT) == 0)
00031e  6913              LDR      r3,[r2,#0x10]
000320  420b              TST      r3,r1
000322  d101              BNE      |L1.808|
;;;646      {
;;;647        bitstatus = RESET;
000324  2000              MOVS     r0,#0
000326  e000              B        |L1.810|
                  |L1.808|
;;;648      }
;;;649      else
;;;650      {
;;;651        bitstatus = SET;
000328  2001              MOVS     r0,#1
                  |L1.810|
;;;652      }
;;;653    
;;;654      return bitstatus;
;;;655    }
00032a  4770              BX       lr
;;;656    
                          ENDP

                  CAN_ITClearErrorPendingBit PROC
;;;671      */
;;;672    void CAN_ITClearErrorPendingBit(MDR_CAN_TypeDef* CANx, uint32_t Status_Flag)
00032c  6842              LDR      r2,[r0,#4]
;;;673    {
;;;674      /* Check the parameters */
;;;675      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;676      assert_param(IS_CAN_IT_ERROR_FLAG(Status_Flag));
;;;677    
;;;678      CANx->STATUS &= ~Status_Flag;
00032e  438a              BICS     r2,r2,r1
000330  6042              STR      r2,[r0,#4]
;;;679    }
000332  4770              BX       lr
;;;680    
                          ENDP

                  CAN_RxITConfig PROC
;;;692      */
;;;693    void CAN_RxITConfig(MDR_CAN_TypeDef* CANx, uint32_t Buffer_IT, FunctionalState NewState)
000334  b510              PUSH     {r4,lr}
;;;694    {
000336  4613              MOV      r3,r2
;;;695      uint32_t tmpreg;
;;;696    
;;;697      /* Check the parameters */
;;;698      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;699      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;700    
;;;701      tmpreg = CANx->INT_RX;
000338  f8d020c0          LDR      r2,[r0,#0xc0]
;;;702    
;;;703      if (NewState != DISABLE)
00033c  b10b              CBZ      r3,|L1.834|
;;;704      {
;;;705        tmpreg |= Buffer_IT;
00033e  430a              ORRS     r2,r2,r1
000340  e000              B        |L1.836|
                  |L1.834|
;;;706      }
;;;707      else
;;;708      {
;;;709        tmpreg &= ~Buffer_IT;
000342  438a              BICS     r2,r2,r1
                  |L1.836|
;;;710      }
;;;711    
;;;712      CANx->INT_RX = tmpreg;
000344  f8c020c0          STR      r2,[r0,#0xc0]
;;;713    }
000348  bd10              POP      {r4,pc}
;;;714    
                          ENDP

                  CAN_GetRxITStatus PROC
;;;722      */
;;;723    ITStatus CAN_GetRxITStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
00034a  b510              PUSH     {r4,lr}
;;;724    {
00034c  4602              MOV      r2,r0
;;;725      FlagStatus bitstatus;
;;;726    
;;;727      /* Check the parameters */
;;;728      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;729      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;730    
;;;731      if ((CANx->RX & CANx->INT_RX & (((uint32_t)0x1) << BufferNumber)) == 0)
00034e  f8d230c4          LDR      r3,[r2,#0xc4]
000352  f8d240c0          LDR      r4,[r2,#0xc0]
000356  4023              ANDS     r3,r3,r4
000358  2401              MOVS     r4,#1
00035a  408c              LSLS     r4,r4,r1
00035c  4223              TST      r3,r4
00035e  d101              BNE      |L1.868|
;;;732      {
;;;733        bitstatus = RESET;
000360  2000              MOVS     r0,#0
000362  e000              B        |L1.870|
                  |L1.868|
;;;734      }
;;;735      else
;;;736      {
;;;737        bitstatus = SET;
000364  2001              MOVS     r0,#1
                  |L1.870|
;;;738      }
;;;739    
;;;740      return bitstatus;
;;;741    }
000366  bd10              POP      {r4,pc}
;;;742    
                          ENDP

                  CAN_GetRx PROC
;;;749      */
;;;750    uint32_t CAN_GetRx(MDR_CAN_TypeDef* CANx)
000368  4601              MOV      r1,r0
;;;751    {
;;;752      /* Check the parameters */
;;;753      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;754    
;;;755      return CANx->RX;
00036a  f8d100c4          LDR      r0,[r1,#0xc4]
;;;756    }
00036e  4770              BX       lr
;;;757    
                          ENDP

                  CAN_TxITConfig PROC
;;;769      */
;;;770    void CAN_TxITConfig(MDR_CAN_TypeDef* CANx, uint32_t Buffer_IT, FunctionalState NewState)
000370  b510              PUSH     {r4,lr}
;;;771    {
000372  4613              MOV      r3,r2
;;;772      uint32_t tmpreg;
;;;773    
;;;774      /* Check the parameters */
;;;775      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;776      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;777    
;;;778      tmpreg = CANx->INT_TX;
000374  f8d020c8          LDR      r2,[r0,#0xc8]
;;;779    
;;;780      if (NewState != DISABLE)
000378  b10b              CBZ      r3,|L1.894|
;;;781      {
;;;782        tmpreg |= Buffer_IT;
00037a  430a              ORRS     r2,r2,r1
00037c  e000              B        |L1.896|
                  |L1.894|
;;;783      }
;;;784      else
;;;785      {
;;;786        tmpreg &= ~Buffer_IT;
00037e  438a              BICS     r2,r2,r1
                  |L1.896|
;;;787      }
;;;788    
;;;789      CANx->INT_TX = tmpreg;
000380  f8c020c8          STR      r2,[r0,#0xc8]
;;;790    }
000384  bd10              POP      {r4,pc}
;;;791    
                          ENDP

                  CAN_GetTxITStatus PROC
;;;799      */
;;;800    ITStatus CAN_GetTxITStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000386  b510              PUSH     {r4,lr}
;;;801    {
000388  4602              MOV      r2,r0
;;;802      FlagStatus bitstatus;
;;;803    
;;;804      /* Check the parameters */
;;;805      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;806      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;807    
;;;808      if ((CANx->TX & CANx->INT_TX & (((uint32_t)0x1) << BufferNumber)) == 0)
00038a  f8d230cc          LDR      r3,[r2,#0xcc]
00038e  f8d240c8          LDR      r4,[r2,#0xc8]
000392  4023              ANDS     r3,r3,r4
000394  2401              MOVS     r4,#1
000396  408c              LSLS     r4,r4,r1
000398  4223              TST      r3,r4
00039a  d101              BNE      |L1.928|
;;;809      {
;;;810        bitstatus = RESET;
00039c  2000              MOVS     r0,#0
00039e  e000              B        |L1.930|
                  |L1.928|
;;;811      }
;;;812      else
;;;813      {
;;;814        bitstatus = SET;
0003a0  2001              MOVS     r0,#1
                  |L1.930|
;;;815      }
;;;816    
;;;817      return bitstatus;
;;;818    }
0003a2  bd10              POP      {r4,pc}
;;;819    
                          ENDP

                  CAN_ITClearRxTxPendingBit PROC
;;;832      */
;;;833    void CAN_ITClearRxTxPendingBit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, uint32_t Status_Flag)
0003a4  b510              PUSH     {r4,lr}
;;;834    {
;;;835      uint32_t tmpreg;
;;;836    
;;;837      /* Check the parameters */
;;;838      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;839      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;840      assert_param(IS_CAN_IT_RXTX_FLAG(Status_Flag));
;;;841    
;;;842      tmpreg = CANx->BUF_CON[BufferNumber];
0003a6  f1000440          ADD      r4,r0,#0x40
0003aa  f8543021          LDR      r3,[r4,r1,LSL #2]
;;;843    
;;;844      if (Status_Flag == CAN_STATUS_RX_READY)
0003ae  2a01              CMP      r2,#1
0003b0  d102              BNE      |L1.952|
;;;845      {
;;;846        tmpreg &= ~CAN_STATUS_RX_FULL;
0003b2  f0230340          BIC      r3,r3,#0x40
0003b6  e003              B        |L1.960|
                  |L1.952|
;;;847      }
;;;848      else if (Status_Flag == CAN_STATUS_TX_READY)
0003b8  2a02              CMP      r2,#2
0003ba  d101              BNE      |L1.960|
;;;849      {
;;;850        tmpreg |= CAN_STATUS_TX_REQ;
0003bc  f0430320          ORR      r3,r3,#0x20
                  |L1.960|
;;;851      }
;;;852    
;;;853      CANx->BUF_CON[BufferNumber] = tmpreg;
0003c0  f1000440          ADD      r4,r0,#0x40
0003c4  f8443021          STR      r3,[r4,r1,LSL #2]
;;;854    }
0003c8  bd10              POP      {r4,pc}
;;;855    
                          ENDP

                  CAN_BRGInit PROC
;;;873      */
;;;874    void CAN_BRGInit(MDR_CAN_TypeDef* CANx, uint32_t CAN_BRG)
0003ca  4602              MOV      r2,r0
;;;875    {
;;;876      uint32_t tmpreg;
;;;877    
;;;878      /* Check the parameters */
;;;879      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;880      assert_param(IS_CAN_CLOCK_BRG(CAN_BRG));
;;;881    
;;;882      tmpreg = MDR_RST_CLK->CAN_CLOCK;
0003cc  4b0b              LDR      r3,|L1.1020|
0003ce  6a18              LDR      r0,[r3,#0x20]
;;;883    
;;;884      if (CANx == MDR_CAN1)
0003d0  f1b24f80          CMP      r2,#0x40000000
0003d4  d105              BNE      |L1.994|
;;;885      {
;;;886        tmpreg |= RST_CLK_CAN_CLOCK_CAN1_CLK_EN;
0003d6  f0407080          ORR      r0,r0,#0x1000000
;;;887        tmpreg &= ~RST_CLK_CAN_CLOCK_CAN1_BRG_Msk;
0003da  f02000ff          BIC      r0,r0,#0xff
;;;888        tmpreg |= CAN_BRG;
0003de  4308              ORRS     r0,r0,r1
0003e0  e008              B        |L1.1012|
                  |L1.994|
;;;889      }
;;;890      else if (CANx == MDR_CAN2)
0003e2  4b07              LDR      r3,|L1.1024|
0003e4  429a              CMP      r2,r3
0003e6  d105              BNE      |L1.1012|
;;;891      {
;;;892        tmpreg |= RST_CLK_CAN_CLOCK_CAN2_CLK_EN;
0003e8  f0407000          ORR      r0,r0,#0x2000000
;;;893        tmpreg &= ~RST_CLK_CAN_CLOCK_CAN2_BRG_Msk;
0003ec  f420407f          BIC      r0,r0,#0xff00
;;;894        tmpreg |= (CAN_BRG << 8);
0003f0  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.1012|
;;;895      }
;;;896    
;;;897      MDR_RST_CLK->CAN_CLOCK = tmpreg;
0003f4  4b01              LDR      r3,|L1.1020|
0003f6  6218              STR      r0,[r3,#0x20]
;;;898    }
0003f8  4770              BX       lr
;;;899    
                          ENDP

0003fa  0000              DCW      0x0000
                  |L1.1020|
                          DCD      0x40020000
                  |L1.1024|
                          DCD      0x40008000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_can.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_can_c_347dae01____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____REVSH|
#line 144
|__asm___15_MDR32F9Qx_can_c_347dae01____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
