; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_adc.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_adc.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;45       */
;;;46     void ADC_DeInit ( void )
000000  2000              MOVS     r0,#0
;;;47     {
;;;48       MDR_ADC->ADC1_CFG = 0;
000002  49e7              LDR      r1,|L1.928|
000004  6008              STR      r0,[r1,#0]
;;;49       MDR_ADC->ADC2_CFG = 0;
000006  6048              STR      r0,[r1,#4]
;;;50       MDR_ADC->ADC1_H_LEVEL = 0;
000008  6088              STR      r0,[r1,#8]
;;;51       MDR_ADC->ADC1_L_LEVEL = 0;
00000a  6108              STR      r0,[r1,#0x10]
;;;52       MDR_ADC->ADC1_RESULT;
00000c  4608              MOV      r0,r1
00000e  6980              LDR      r0,[r0,#0x18]
;;;53       MDR_ADC->ADC1_STATUS = 0;
000010  2000              MOVS     r0,#0
000012  6208              STR      r0,[r1,#0x20]
;;;54       MDR_ADC->ADC1_CHSEL = 0;
000014  6288              STR      r0,[r1,#0x28]
;;;55     
;;;56     #if defined ( USE_MDR1986VE9x ) /* For Cortex M3 */
;;;57       MDR_ADC->ADC2_H_LEVEL = 0;
000016  60c8              STR      r0,[r1,#0xc]
;;;58       MDR_ADC->ADC2_L_LEVEL = 0;
000018  6148              STR      r0,[r1,#0x14]
;;;59       MDR_ADC->ADC2_RESULT;
00001a  4608              MOV      r0,r1
00001c  69c0              LDR      r0,[r0,#0x1c]
;;;60       MDR_ADC->ADC2_STATUS = 0;
00001e  2000              MOVS     r0,#0
000020  6248              STR      r0,[r1,#0x24]
;;;61       MDR_ADC->ADC2_CHSEL = 0;
000022  62c8              STR      r0,[r1,#0x2c]
;;;62     #endif // #if defined ( USE_MDR1986VE9x ) /* For Cortex M3 */
;;;63     
;;;64     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;65       MDR_ADC->ADC1_TRIM = 0;
;;;66     #endif
;;;67     }
000024  4770              BX       lr
;;;68     
                          ENDP

                  ADC_Init PROC
;;;76       */
;;;77     void ADC_Init(const ADC_InitTypeDef* ADC_InitStruct)
000026  b510              PUSH     {r4,lr}
;;;78     {
;;;79       uint32_t tmpreg_CFG;
;;;80       uint32_t tmpreg_MSK;
;;;81     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;82       uint32_t tmpreg_TRIM;
;;;83     #endif
;;;84     
;;;85       /* Check the parameters */
;;;86     #if defined (USE_MDR1986VE9x)
;;;87       assert_param(IS_ADC_SYNC_MODE(ADC_InitStruct->ADC_SynchronousMode));
;;;88     #endif
;;;89       assert_param(IS_ADC_START_DELAY_VALUE(ADC_InitStruct->ADC_StartDelay));
;;;90       assert_param(IS_ADC_TEMP_SENSOR_CONFIG(ADC_InitStruct->ADC_TempSensor));
;;;91       assert_param(IS_ADC_TEMP_SENSOR_AMP_CONFIG(ADC_InitStruct->ADC_TempSensorAmplifier));
;;;92       assert_param(IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(ADC_InitStruct->ADC_TempSensorConversion));
;;;93       assert_param(IS_ADC_VREF_CONVERSION_CONFIG(ADC_InitStruct->ADC_IntVRefConversion));
;;;94       assert_param(IS_ADC_VREF_TRIMMING_VALUE(ADC_InitStruct->ADC_IntVRefTrimming));
;;;95     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;96       assert_param(IS_ADC_INT_VREF_AMPLIFIER(ADC_InitStruct->ADC_IntVRefAmplifier));
;;;97     #endif
;;;98     
;;;99       tmpreg_CFG = (ADC_InitStruct->ADC_StartDelay << ADC1_CFG_DELAY_ADC_Pos)
000028  7904              LDRB     r4,[r0,#4]
00002a  6883              LDR      r3,[r0,#8]
00002c  eb037304          ADD      r3,r3,r4,LSL #28
000030  68c4              LDR      r4,[r0,#0xc]
000032  4423              ADD      r3,r3,r4
000034  6904              LDR      r4,[r0,#0x10]
000036  4423              ADD      r3,r3,r4
000038  6944              LDR      r4,[r0,#0x14]
00003a  1919              ADDS     r1,r3,r4
;;;100                 + ADC_InitStruct->ADC_TempSensor
;;;101                 + ADC_InitStruct->ADC_TempSensorAmplifier
;;;102                 + ADC_InitStruct->ADC_TempSensorConversion
;;;103                 + ADC_InitStruct->ADC_IntVRefConversion;
;;;104    
;;;105    #if defined( USE_MDR1986VE9x ) /* For Cortex M3*/
;;;106      tmpreg_CFG += (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_CFG_TR_Pos)
00003c  8b04              LDRH     r4,[r0,#0x18]
00003e  6803              LDR      r3,[r0,#0]
000040  eb035344          ADD      r3,r3,r4,LSL #21
000044  4419              ADD      r1,r1,r3
;;;107                 +   ADC_InitStruct->ADC_SynchronousMode;
;;;108    #endif // #if defined(USE_MDR1986VE9x) /* For Cortex M3*/
;;;109    
;;;110      tmpreg_MSK = ADC1_CFG_DELAY_ADC_Msk
000046  4ad7              LDR      r2,|L1.932|
;;;111                 | ADC1_CFG_TS_EN
;;;112                 | ADC1_CFG_TS_BUF_EN
;;;113                 | ADC1_CFG_SEL_TS
;;;114                 | ADC1_CFG_SEL_VREF;
;;;115    #if defined( USE_MDR1986VE9x ) /* For Cortex M3*/
;;;116      tmpreg_MSK |= ADC1_CFG_TR_Msk
000048  4bd7              LDR      r3,|L1.936|
00004a  431a              ORRS     r2,r2,r3
;;;117                 |  ADC1_CFG_SYNC_CONVER;
;;;118    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;119      tmpreg_TRIM = (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_TRIM_TS_TRIM_Pos)
;;;120              | ADC_InitStruct->ADC_IntVRefAmplifier;
;;;121      MDR_ADC->ADC1_TRIM  = tmpreg_TRIM;
;;;122    #endif
;;;123    
;;;124      MDR_ADC->ADC1_CFG = (MDR_ADC->ADC1_CFG & ~tmpreg_MSK) + tmpreg_CFG;
00004c  4bd4              LDR      r3,|L1.928|
00004e  681b              LDR      r3,[r3,#0]
000050  4393              BICS     r3,r3,r2
000052  440b              ADD      r3,r3,r1
000054  4cd2              LDR      r4,|L1.928|
000056  6023              STR      r3,[r4,#0]
;;;125    }
000058  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  ADC_StructInit PROC
;;;132      */
;;;133    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
00005a  2100              MOVS     r1,#0
;;;134    {
;;;135    
;;;136    #if defined( USE_MDR1986VE9x )
;;;137      ADC_InitStruct->ADC_SynchronousMode     = ADC_SyncMode_Independent;
00005c  6001              STR      r1,[r0,#0]
;;;138    #endif
;;;139    
;;;140      ADC_InitStruct->ADC_StartDelay        	= 0;
00005e  6041              STR      r1,[r0,#4]
;;;141      ADC_InitStruct->ADC_TempSensor        	= ADC_TEMP_SENSOR_Disable;
000060  6081              STR      r1,[r0,#8]
;;;142      ADC_InitStruct->ADC_TempSensorAmplifier   = ADC_TEMP_SENSOR_AMPLIFIER_Disable;
000062  60c1              STR      r1,[r0,#0xc]
;;;143      ADC_InitStruct->ADC_TempSensorConversion  = ADC_TEMP_SENSOR_CONVERSION_Disable;
000064  6101              STR      r1,[r0,#0x10]
;;;144      ADC_InitStruct->ADC_IntVRefConversion     = ADC_VREF_CONVERSION_Disable;
000066  6141              STR      r1,[r0,#0x14]
;;;145      ADC_InitStruct->ADC_IntVRefTrimming     	= 0;
000068  6181              STR      r1,[r0,#0x18]
;;;146    
;;;147    #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
;;;148      ADC_InitStruct->ADC_IntVRefAmplifier    	= ADC_INT_VREF_AMPLIFIER_Disable;
;;;149    #endif
;;;150    }
00006a  4770              BX       lr
;;;151    
                          ENDP

                  ADC_SetTrim PROC
;;;157      */
;;;158    void ADC_SetTrim(uint32_t Trim)
00006c  4acc              LDR      r2,|L1.928|
;;;159    {
;;;160      uint32_t tmpreg;
;;;161    
;;;162      /* Check the parameters */
;;;163      assert_param(IS_ADC_VREF_TRIMMING_VALUE(Trim));
;;;164    
;;;165    #if defined(USE_MDR1986VE9x) /* For Cortex M3*/
;;;166      tmpreg = MDR_ADC->ADC1_CFG & ~ADC1_CFG_TR_Msk;
00006e  6812              LDR      r2,[r2,#0]
000070  f02271f0          BIC      r1,r2,#0x1e00000
;;;167      MDR_ADC->ADC1_CFG = tmpreg + (Trim << ADC1_CFG_TR_Pos);
000074  eb015240          ADD      r2,r1,r0,LSL #21
000078  4bc9              LDR      r3,|L1.928|
00007a  601a              STR      r2,[r3,#0]
;;;168    
;;;169    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;170      tmpreg = MDR_ADC->ADC1_TRIM;
;;;171      tmpreg &= ~ADC1_TRIM_TS_TRIM_Msk;
;;;172      tmpreg |= Trim << ADC1_TRIM_TS_TRIM_Pos;
;;;173      MDR_ADC->ADC1_TRIM = tmpreg;
;;;174    #endif
;;;175    }
00007c  4770              BX       lr
;;;176    
                          ENDP

                  ADC1_Init PROC
;;;185      */
;;;186    void ADC1_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
00007e  b510              PUSH     {r4,lr}
;;;187    {
;;;188      uint32_t tmpreg_CFG1;
;;;189      uint32_t tmpreg_CFG2;
;;;190    
;;;191      /* Check the parameters */
;;;192      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;193      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;194      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;195      assert_param(IS_ADC1_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;196      assert_param(IS_ADC1_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;197      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;198      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;199      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;200      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;201      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;202      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;203      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;204    
;;;205      tmpreg_CFG1 = MDR_ADC->ADC1_CFG;
000080  4bc7              LDR      r3,|L1.928|
000082  681a              LDR      r2,[r3,#0]
;;;206    
;;;207      tmpreg_CFG1 &= ~(ADC1_CFG_REG_CLKS
000084  4bc9              LDR      r3,|L1.940|
000086  401a              ANDS     r2,r2,r3
;;;208                     | ADC1_CFG_REG_SAMPLE
;;;209                     | ADC1_CFG_REG_CHCH
;;;210                     | ADC1_CFG_REG_CHS_Msk
;;;211                     | ADC1_CFG_REG_RNGC
;;;212                     | ADC1_CFG_M_REF
;;;213                     | ADC1_CFG_REG_DIVCLK_Msk
;;;214                     | ADC1_CFG_DELAY_GO_Msk);
;;;215    
;;;216      tmpreg_CFG1 += ADCx_InitStruct->ADC_ClockSource
000088  e9d03400          LDRD     r3,r4,[r0,#0]
00008c  4423              ADD      r3,r3,r4
00008e  6884              LDR      r4,[r0,#8]
000090  4423              ADD      r3,r3,r4
000092  68c4              LDR      r4,[r0,#0xc]
000094  eb031304          ADD      r3,r3,r4,LSL #4
000098  6944              LDR      r4,[r0,#0x14]
00009a  4423              ADD      r3,r3,r4
00009c  69c4              LDR      r4,[r0,#0x1c]
00009e  4423              ADD      r3,r3,r4
0000a0  6a44              LDR      r4,[r0,#0x24]
0000a2  4423              ADD      r3,r3,r4
0000a4  f8904028          LDRB     r4,[r0,#0x28]
0000a8  eb036344          ADD      r3,r3,r4,LSL #25
0000ac  441a              ADD      r2,r2,r3
;;;217                   + ADCx_InitStruct->ADC_SamplingMode
;;;218                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;219                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC1_CFG_REG_CHS_Pos)
;;;220                   + ADCx_InitStruct->ADC_LevelControl
;;;221                   + ADCx_InitStruct->ADC_VRefSource
;;;222                   + ADCx_InitStruct->ADC_Prescaler
;;;223                   + (ADCx_InitStruct->ADC_DelayGo << ADC1_CFG_DELAY_GO_Pos);
;;;224    
;;;225      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
0000ae  4bbc              LDR      r3,|L1.928|
0000b0  6859              LDR      r1,[r3,#4]
;;;226      tmpreg_CFG2 &= ~ADC2_CFG_ADC1_OP;
0000b2  f4213100          BIC      r1,r1,#0x20000
;;;227      tmpreg_CFG2 += ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC1_OP_Pos;
0000b6  8c03              LDRH     r3,[r0,#0x20]
0000b8  eb014143          ADD      r1,r1,r3,LSL #17
;;;228    
;;;229      MDR_ADC->ADC1_CFG = tmpreg_CFG1;
0000bc  4bb8              LDR      r3,|L1.928|
0000be  601a              STR      r2,[r3,#0]
;;;230      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
0000c0  6059              STR      r1,[r3,#4]
;;;231    
;;;232      MDR_ADC->ADC1_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
0000c2  8b03              LDRH     r3,[r0,#0x18]
0000c4  4cb6              LDR      r4,|L1.928|
0000c6  6123              STR      r3,[r4,#0x10]
;;;233      MDR_ADC->ADC1_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
0000c8  8b43              LDRH     r3,[r0,#0x1a]
0000ca  60a3              STR      r3,[r4,#8]
;;;234      MDR_ADC->ADC1_CHSEL   = ADCx_InitStruct->ADC_Channels;
0000cc  6903              LDR      r3,[r0,#0x10]
0000ce  62a3              STR      r3,[r4,#0x28]
;;;235    }
0000d0  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  ADC2_Init PROC
;;;247      */
;;;248    void ADC2_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
0000d2  4ab3              LDR      r2,|L1.928|
;;;249    {
;;;250      uint32_t tmpreg_CFG2;
;;;251    
;;;252      /* Check the parameters */
;;;253      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;254      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;255      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;256      assert_param(IS_ADC2_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;257      assert_param(IS_ADC2_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;258      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;259      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;260      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;261      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;262      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;263      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;264      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;265    
;;;266      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
0000d4  6851              LDR      r1,[r2,#4]
;;;267    
;;;268      tmpreg_CFG2 &= ~(ADC2_CFG_REG_CLKS
0000d6  4ab6              LDR      r2,|L1.944|
0000d8  4011              ANDS     r1,r1,r2
;;;269                     | ADC2_CFG_REG_SAMPLE
;;;270                     | ADC2_CFG_REG_CHCH
;;;271                     | ADC2_CFG_REG_CHS_Msk
;;;272                     | ADC2_CFG_REG_RNGC
;;;273                     | ADC2_CFG_M_REF
;;;274                     | ADC2_CFG_ADC2_OP
;;;275                     | ADC2_CFG_REG_DIVCLK_Msk
;;;276                     | ADC2_CFG_DELAY_GO_Msk);
;;;277    
;;;278      tmpreg_CFG2 += ADCx_InitStruct->ADC_ClockSource
0000da  e9d02300          LDRD     r2,r3,[r0,#0]
0000de  441a              ADD      r2,r2,r3
0000e0  6883              LDR      r3,[r0,#8]
0000e2  441a              ADD      r2,r2,r3
0000e4  68c3              LDR      r3,[r0,#0xc]
0000e6  eb021203          ADD      r2,r2,r3,LSL #4
0000ea  6943              LDR      r3,[r0,#0x14]
0000ec  441a              ADD      r2,r2,r3
0000ee  69c3              LDR      r3,[r0,#0x1c]
0000f0  441a              ADD      r2,r2,r3
0000f2  8c03              LDRH     r3,[r0,#0x20]
0000f4  eb024283          ADD      r2,r2,r3,LSL #18
0000f8  6a43              LDR      r3,[r0,#0x24]
0000fa  441a              ADD      r2,r2,r3
0000fc  f8903028          LDRB     r3,[r0,#0x28]
000100  eb026243          ADD      r2,r2,r3,LSL #25
000104  4411              ADD      r1,r1,r2
;;;279                   + ADCx_InitStruct->ADC_SamplingMode
;;;280                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;281                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC2_CFG_REG_CHS_Pos)
;;;282                   + ADCx_InitStruct->ADC_LevelControl
;;;283                   + ADCx_InitStruct->ADC_VRefSource
;;;284                   + (ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC2_OP_Pos)
;;;285                   + ADCx_InitStruct->ADC_Prescaler
;;;286                   + (ADCx_InitStruct->ADC_DelayGo << ADC2_CFG_DELAY_GO_Pos);
;;;287    
;;;288      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
000106  4aa6              LDR      r2,|L1.928|
000108  6051              STR      r1,[r2,#4]
;;;289      MDR_ADC->ADC2_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
00010a  8b02              LDRH     r2,[r0,#0x18]
00010c  4ba4              LDR      r3,|L1.928|
00010e  615a              STR      r2,[r3,#0x14]
;;;290      MDR_ADC->ADC2_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
000110  8b42              LDRH     r2,[r0,#0x1a]
000112  60da              STR      r2,[r3,#0xc]
;;;291      MDR_ADC->ADC2_CHSEL   = ADCx_InitStruct->ADC_Channels;
000114  6902              LDR      r2,[r0,#0x10]
000116  62da              STR      r2,[r3,#0x2c]
;;;292    }
000118  4770              BX       lr
;;;293    
                          ENDP

                  ADCx_StructInit PROC
;;;301      */
;;;302    void ADCx_StructInit(ADCx_InitTypeDef* ADCx_InitStruct)
00011a  2100              MOVS     r1,#0
;;;303    {
;;;304      ADCx_InitStruct->ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU;
00011c  6001              STR      r1,[r0,#0]
;;;305      ADCx_InitStruct->ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
00011e  6041              STR      r1,[r0,#4]
;;;306      ADCx_InitStruct->ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000120  6081              STR      r1,[r0,#8]
;;;307      ADCx_InitStruct->ADC_ChannelNumber    = ADC_CH_ADC0;
000122  60c1              STR      r1,[r0,#0xc]
;;;308      ADCx_InitStruct->ADC_Channels         = 0;
000124  6101              STR      r1,[r0,#0x10]
;;;309      ADCx_InitStruct->ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
000126  6141              STR      r1,[r0,#0x14]
;;;310      ADCx_InitStruct->ADC_LowLevel         = 0;
000128  8301              STRH     r1,[r0,#0x18]
;;;311      ADCx_InitStruct->ADC_HighLevel        = 0;
00012a  8341              STRH     r1,[r0,#0x1a]
;;;312      ADCx_InitStruct->ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL;
00012c  61c1              STR      r1,[r0,#0x1c]
;;;313      ADCx_InitStruct->ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT;
00012e  6201              STR      r1,[r0,#0x20]
;;;314      ADCx_InitStruct->ADC_Prescaler        = ADC_CLK_div_None;
000130  6241              STR      r1,[r0,#0x24]
;;;315      ADCx_InitStruct->ADC_DelayGo          = 0;
000132  6281              STR      r1,[r0,#0x28]
;;;316    }
000134  4770              BX       lr
;;;317    
                          ENDP

                  ADC1_Cmd PROC
;;;323      */
;;;324    void ADC1_Cmd(FunctionalState NewState)
000136  4601              MOV      r1,r0
;;;325    {
;;;326      uint32_t tmpreg_CFG;
;;;327    
;;;328      /* Check the parameters */
;;;329      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;330    
;;;331      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000138  4a99              LDR      r2,|L1.928|
00013a  6810              LDR      r0,[r2,#0]
;;;332    
;;;333      /* Form new value */
;;;334      if (NewState != DISABLE)
00013c  b111              CBZ      r1,|L1.324|
;;;335      {
;;;336        /* Enable ADC1 by setting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;337        tmpreg_CFG |= ADC1_CFG_REG_ADON;
00013e  f0400001          ORR      r0,r0,#1
000142  e001              B        |L1.328|
                  |L1.324|
;;;338      }
;;;339      else
;;;340      {
;;;341        /* Disable ADC1 by resetting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;342        tmpreg_CFG &= ~ADC1_CFG_REG_ADON;
000144  f0200001          BIC      r0,r0,#1
                  |L1.328|
;;;343      }
;;;344    
;;;345      /* Configure ADC1_CFG register with new value */
;;;346      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000148  4a95              LDR      r2,|L1.928|
00014a  6010              STR      r0,[r2,#0]
;;;347    }
00014c  4770              BX       lr
;;;348    
                          ENDP

                  ADC2_Cmd PROC
;;;357      */
;;;358    void ADC2_Cmd(FunctionalState NewState)
00014e  4601              MOV      r1,r0
;;;359    {
;;;360      uint32_t tmpreg_CFG;
;;;361    
;;;362      /* Check the parameters */
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;364    
;;;365      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000150  4a93              LDR      r2,|L1.928|
000152  6850              LDR      r0,[r2,#4]
;;;366    
;;;367      /* Form new value */
;;;368      if (NewState != DISABLE)
000154  b111              CBZ      r1,|L1.348|
;;;369      {
;;;370        /* Enable ADC2 by setting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;371        tmpreg_CFG |= ADC2_CFG_REG_ADON;
000156  f0400001          ORR      r0,r0,#1
00015a  e001              B        |L1.352|
                  |L1.348|
;;;372      }
;;;373      else
;;;374      {
;;;375        /* Disable ADC2 by resetting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;376        tmpreg_CFG &= ~ADC2_CFG_REG_ADON;
00015c  f0200001          BIC      r0,r0,#1
                  |L1.352|
;;;377      }
;;;378    
;;;379      /* Configure ADC2_CFG register with new value */
;;;380      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000160  4a8f              LDR      r2,|L1.928|
000162  6050              STR      r0,[r2,#4]
;;;381    }
000164  4770              BX       lr
;;;382    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetChannel PROC
;;;388      */
;;;389    void ADC1_SetChannel(uint32_t Channel)
000166  4601              MOV      r1,r0
;;;390    {
;;;391      uint32_t tmpreg_CFG;
;;;392    
;;;393      /* Check the parameters */
;;;394      assert_param(IS_ADC1_CH_NUM(Channel));
;;;395    
;;;396      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000168  4a8d              LDR      r2,|L1.928|
00016a  6810              LDR      r0,[r2,#0]
;;;397      tmpreg_CFG &= ~ADC1_CFG_REG_CHS_Msk;
00016c  f42070f8          BIC      r0,r0,#0x1f0
;;;398      tmpreg_CFG += Channel << ADC1_CFG_REG_CHS_Pos;
000170  eb001001          ADD      r0,r0,r1,LSL #4
;;;399      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000174  6010              STR      r0,[r2,#0]
;;;400    }
000176  4770              BX       lr
;;;401    
                          ENDP

                  ADC2_SetChannel PROC
;;;409      */
;;;410    void ADC2_SetChannel(uint32_t Channel)
000178  4601              MOV      r1,r0
;;;411    {
;;;412      uint32_t tmpreg_CFG;
;;;413    
;;;414      /* Check the parameters */
;;;415      assert_param(IS_ADC2_CH_NUM(Channel));
;;;416    
;;;417      tmpreg_CFG = MDR_ADC->ADC2_CFG;
00017a  4a89              LDR      r2,|L1.928|
00017c  6850              LDR      r0,[r2,#4]
;;;418      tmpreg_CFG &= ~ADC2_CFG_REG_CHS_Msk;
00017e  f42070f8          BIC      r0,r0,#0x1f0
;;;419      tmpreg_CFG += Channel << ADC2_CFG_REG_CHS_Pos;
000182  eb001001          ADD      r0,r0,r1,LSL #4
;;;420      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000186  6050              STR      r0,[r2,#4]
;;;421    }
000188  4770              BX       lr
;;;422    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetChannels PROC
;;;428      */
;;;429    void ADC1_SetChannels(uint32_t ChannelMask)
00018a  4985              LDR      r1,|L1.928|
;;;430    {
;;;431      /* Check the parameters */
;;;432      assert_param(IS_ADC1_CH_MASK(ChannelMask));
;;;433    
;;;434      MDR_ADC->ADC1_CHSEL = ChannelMask;
00018c  6288              STR      r0,[r1,#0x28]
;;;435    }
00018e  4770              BX       lr
;;;436    
                          ENDP

                  ADC2_SetChannels PROC
;;;442      */
;;;443    void ADC2_SetChannels(uint32_t ChannelMask)
000190  4983              LDR      r1,|L1.928|
;;;444    {
;;;445      /* Check the parameters */
;;;446      assert_param(IS_ADC2_CH_MASK(ChannelMask));
;;;447    
;;;448      MDR_ADC->ADC2_CHSEL = ChannelMask;
000192  62c8              STR      r0,[r1,#0x2c]
;;;449    }
000194  4770              BX       lr
;;;450    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_OperationModeConfig PROC
;;;457      */
;;;458    void ADC1_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
000196  4602              MOV      r2,r0
;;;459    {
;;;460      uint32_t tmpreg_CFG;
;;;461    
;;;462      /* Check the parameters */
;;;463      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;464      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;465    
;;;466      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000198  4b81              LDR      r3,|L1.928|
00019a  6818              LDR      r0,[r3,#0]
;;;467      tmpreg_CFG &= ~(ADC1_CFG_REG_SAMPLE | ADC1_CFG_REG_CHCH);
00019c  f4207002          BIC      r0,r0,#0x208
;;;468      tmpreg_CFG += SamplingMode + SwitchingMode;
0001a0  1853              ADDS     r3,r2,r1
0001a2  4418              ADD      r0,r0,r3
;;;469      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001a4  4b7e              LDR      r3,|L1.928|
0001a6  6018              STR      r0,[r3,#0]
;;;470    }
0001a8  4770              BX       lr
;;;471    
                          ENDP

                  ADC2_OperationModeConfig PROC
;;;480      */
;;;481    void ADC2_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
0001aa  4602              MOV      r2,r0
;;;482    {
;;;483      uint32_t tmpreg_CFG;
;;;484    
;;;485      /* Check the parameters */
;;;486      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;487      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;488    
;;;489      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001ac  4b7c              LDR      r3,|L1.928|
0001ae  6858              LDR      r0,[r3,#4]
;;;490      tmpreg_CFG &= ~(ADC2_CFG_REG_SAMPLE | ADC2_CFG_REG_CHCH);
0001b0  f4207002          BIC      r0,r0,#0x208
;;;491      tmpreg_CFG += SamplingMode + SwitchingMode;
0001b4  1853              ADDS     r3,r2,r1
0001b6  4418              ADD      r0,r0,r3
;;;492      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001b8  4b79              LDR      r3,|L1.928|
0001ba  6058              STR      r0,[r3,#4]
;;;493    }
0001bc  4770              BX       lr
;;;494    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SamplingModeConfig PROC
;;;500      */
;;;501    void ADC1_SamplingModeConfig(uint32_t SamplingMode)
0001be  4601              MOV      r1,r0
;;;502    {
;;;503      uint32_t tmpreg_CFG;
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;507    
;;;508      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001c0  4a77              LDR      r2,|L1.928|
0001c2  6810              LDR      r0,[r2,#0]
;;;509      tmpreg_CFG &= ~ADC1_CFG_REG_SAMPLE;
0001c4  f0200008          BIC      r0,r0,#8
;;;510      tmpreg_CFG += SamplingMode;
0001c8  4408              ADD      r0,r0,r1
;;;511      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001ca  6010              STR      r0,[r2,#0]
;;;512    }
0001cc  4770              BX       lr
;;;513    
                          ENDP

                  ADC2_SamplingModeConfig PROC
;;;521      */
;;;522    void ADC2_SamplingModeConfig(uint32_t SamplingMode)
0001ce  4601              MOV      r1,r0
;;;523    {
;;;524      uint32_t tmpreg_CFG;
;;;525    
;;;526      /* Check the parameters */
;;;527      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;528    
;;;529      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001d0  4a73              LDR      r2,|L1.928|
0001d2  6850              LDR      r0,[r2,#4]
;;;530      tmpreg_CFG &= ~ADC2_CFG_REG_SAMPLE;
0001d4  f0200008          BIC      r0,r0,#8
;;;531      tmpreg_CFG += SamplingMode;
0001d8  4408              ADD      r0,r0,r1
;;;532      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001da  6050              STR      r0,[r2,#4]
;;;533    }
0001dc  4770              BX       lr
;;;534    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_ChannelSwithingConfig PROC
;;;540      */
;;;541    void ADC1_ChannelSwithingConfig(uint32_t SwitchingMode)
0001de  4601              MOV      r1,r0
;;;542    {
;;;543      uint32_t tmpreg_CFG;
;;;544    
;;;545      /* Check the parameters */
;;;546      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;547    
;;;548      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001e0  4a6f              LDR      r2,|L1.928|
0001e2  6810              LDR      r0,[r2,#0]
;;;549      tmpreg_CFG &= ~ADC1_CFG_REG_CHCH;
0001e4  f4207000          BIC      r0,r0,#0x200
;;;550      tmpreg_CFG += SwitchingMode;
0001e8  4408              ADD      r0,r0,r1
;;;551      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001ea  6010              STR      r0,[r2,#0]
;;;552    }
0001ec  4770              BX       lr
;;;553    
                          ENDP

                  ADC2_ChannelSwithingConfig PROC
;;;561      */
;;;562    void ADC2_ChannelSwithingConfig(uint32_t SwitchingMode)
0001ee  4601              MOV      r1,r0
;;;563    {
;;;564      uint32_t tmpreg_CFG;
;;;565    
;;;566      /* Check the parameters */
;;;567      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;568    
;;;569      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001f0  4a6b              LDR      r2,|L1.928|
0001f2  6850              LDR      r0,[r2,#4]
;;;570      tmpreg_CFG &= ~ADC2_CFG_REG_CHCH;
0001f4  f4207000          BIC      r0,r0,#0x200
;;;571      tmpreg_CFG += SwitchingMode;
0001f8  4408              ADD      r0,r0,r1
;;;572      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001fa  6050              STR      r0,[r2,#4]
;;;573    }
0001fc  4770              BX       lr
;;;574    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_LevelsConfig PROC
;;;582      */
;;;583    void ADC1_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
0001fe  b510              PUSH     {r4,lr}
;;;584    {
000200  4603              MOV      r3,r0
;;;585      uint32_t tmpreg_CFG;
;;;586    
;;;587      /* Check the parameters */
;;;588      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;589      assert_param(IS_ADC_VALUE(LowLevel));
;;;590      assert_param(IS_ADC_VALUE(HighLevel));
;;;591    
;;;592      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000202  4c67              LDR      r4,|L1.928|
000204  6820              LDR      r0,[r4,#0]
;;;593      tmpreg_CFG &= ~ADC1_CFG_REG_RNGC;
000206  f4206080          BIC      r0,r0,#0x400
;;;594      tmpreg_CFG += NewState;
00020a  4410              ADD      r0,r0,r2
;;;595      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00020c  6020              STR      r0,[r4,#0]
;;;596    
;;;597      MDR_ADC->ADC1_L_LEVEL = LowLevel;
00020e  6123              STR      r3,[r4,#0x10]
;;;598      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000210  60a1              STR      r1,[r4,#8]
;;;599    }
000212  bd10              POP      {r4,pc}
;;;600    
                          ENDP

                  ADC2_LevelsConfig PROC
;;;610      */
;;;611    void ADC2_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
000214  b510              PUSH     {r4,lr}
;;;612    {
000216  4603              MOV      r3,r0
;;;613      uint32_t tmpreg_CFG;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;617      assert_param(IS_ADC_VALUE(LowLevel));
;;;618      assert_param(IS_ADC_VALUE(HighLevel));
;;;619    
;;;620      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000218  4c61              LDR      r4,|L1.928|
00021a  6860              LDR      r0,[r4,#4]
;;;621      tmpreg_CFG &= ~ADC2_CFG_REG_RNGC;
00021c  f4206080          BIC      r0,r0,#0x400
;;;622      tmpreg_CFG += NewState;
000220  4410              ADD      r0,r0,r2
;;;623      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000222  6060              STR      r0,[r4,#4]
;;;624    
;;;625      MDR_ADC->ADC2_L_LEVEL = LowLevel;
000224  6163              STR      r3,[r4,#0x14]
;;;626      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000226  60e1              STR      r1,[r4,#0xc]
;;;627    }
000228  bd10              POP      {r4,pc}
;;;628    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetLowLevel PROC
;;;634      */
;;;635    void ADC1_SetLowLevel(uint32_t LowLevel)
00022a  495d              LDR      r1,|L1.928|
;;;636    {
;;;637      /* Check the parameters */
;;;638      assert_param(IS_ADC_VALUE(LowLevel));
;;;639    
;;;640      MDR_ADC->ADC1_L_LEVEL = LowLevel;
00022c  6108              STR      r0,[r1,#0x10]
;;;641    }
00022e  4770              BX       lr
;;;642    
                          ENDP

                  ADC2_SetLowLevel PROC
;;;648      */
;;;649    void ADC2_SetLowLevel(uint32_t LowLevel)
000230  495b              LDR      r1,|L1.928|
;;;650    {
;;;651      /* Check the parameters */
;;;652      assert_param(IS_ADC_VALUE(LowLevel));
;;;653    
;;;654      MDR_ADC->ADC2_L_LEVEL = LowLevel;
000232  6148              STR      r0,[r1,#0x14]
;;;655    }
000234  4770              BX       lr
;;;656    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_SetHighLevel PROC
;;;662      */
;;;663    void ADC1_SetHighLevel(uint32_t HighLevel)
000236  495a              LDR      r1,|L1.928|
;;;664    {
;;;665      /* Check the parameters */
;;;666      assert_param(IS_ADC_VALUE(HighLevel));
;;;667    
;;;668      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000238  6088              STR      r0,[r1,#8]
;;;669    }
00023a  4770              BX       lr
;;;670    
                          ENDP

                  ADC2_SetHighLevel PROC
;;;678      */
;;;679    void ADC2_SetHighLevel(uint32_t HighLevel)
00023c  4958              LDR      r1,|L1.928|
;;;680    {
;;;681      /* Check the parameters */
;;;682      assert_param(IS_ADC_VALUE(HighLevel));
;;;683    
;;;684      MDR_ADC->ADC2_H_LEVEL = HighLevel;
00023e  60c8              STR      r0,[r1,#0xc]
;;;685    }
000240  4770              BX       lr
;;;686    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_Start PROC
;;;692      */
;;;693    void ADC1_Start(void)
000242  4857              LDR      r0,|L1.928|
;;;694    {
;;;695      MDR_ADC->ADC1_CFG |= ADC1_CFG_REG_GO;
000244  6800              LDR      r0,[r0,#0]
000246  f0400002          ORR      r0,r0,#2
00024a  4955              LDR      r1,|L1.928|
00024c  6008              STR      r0,[r1,#0]
;;;696    }
00024e  4770              BX       lr
;;;697    
                          ENDP

                  ADC2_Start PROC
;;;705      */
;;;706    void ADC2_Start(void)
000250  4853              LDR      r0,|L1.928|
;;;707    {
;;;708      MDR_ADC->ADC2_CFG |= ADC2_CFG_REG_GO;
000252  6840              LDR      r0,[r0,#4]
000254  f0400002          ORR      r0,r0,#2
000258  4951              LDR      r1,|L1.928|
00025a  6048              STR      r0,[r1,#4]
;;;709    }
00025c  4770              BX       lr
;;;710    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_GetResult PROC
;;;716      */
;;;717    uint32_t ADC1_GetResult(void)
00025e  4850              LDR      r0,|L1.928|
;;;718    {
;;;719      return MDR_ADC->ADC1_RESULT;
000260  6980              LDR      r0,[r0,#0x18]
;;;720    }
000262  4770              BX       lr
;;;721    
                          ENDP

                  ADC2_GetResult PROC
;;;729      */
;;;730    uint32_t ADC2_GetResult(void)
000264  484e              LDR      r0,|L1.928|
;;;731    {
;;;732      return MDR_ADC->ADC2_RESULT;
000266  69c0              LDR      r0,[r0,#0x1c]
;;;733    }
000268  4770              BX       lr
;;;734    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC_GetStatus PROC
;;;740      */
;;;741    uint32_t ADC_GetStatus ( void )
00026a  484d              LDR      r0,|L1.928|
;;;742    {
;;;743    #if defined  (USE_MDR1986VE9x) 									/* For Cortex M3 */
;;;744      return MDR_ADC->ADC1_STATUS + (MDR_ADC->ADC2_STATUS << 16);
00026c  6a00              LDR      r0,[r0,#0x20]
00026e  494c              LDR      r1,|L1.928|
000270  6a49              LDR      r1,[r1,#0x24]
000272  eb004001          ADD      r0,r0,r1,LSL #16
;;;745    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) 	/* For Cortex M1 */
;;;746      return MDR_ADC->ADC1_STATUS;
;;;747    #endif
;;;748    }
000276  4770              BX       lr
;;;749    
                          ENDP

                  ADC1_GetStatus PROC
;;;754      */
;;;755    uint32_t ADC1_GetStatus(void)
000278  4849              LDR      r0,|L1.928|
;;;756    {
;;;757      return MDR_ADC->ADC1_STATUS;
00027a  6a00              LDR      r0,[r0,#0x20]
;;;758    }
00027c  4770              BX       lr
;;;759    
                          ENDP

                  ADC2_GetStatus PROC
;;;767      */
;;;768    uint32_t ADC2_GetStatus(void)
00027e  4848              LDR      r0,|L1.928|
;;;769    {
;;;770      return MDR_ADC->ADC2_STATUS;
000280  6a40              LDR      r0,[r0,#0x24]
;;;771    }
000282  4770              BX       lr
;;;772    #endif // #ifdef USE_MDR1986VE9x /* For Cortex M3 */
                          ENDP

                  ADC_GetFlagStatus PROC
;;;785      */
;;;786    FlagStatus ADC_GetFlagStatus(uint32_t Flag)
000284  b500              PUSH     {lr}
;;;787    {
000286  4603              MOV      r3,r0
;;;788      FlagStatus bitstatus;
;;;789    
;;;790      /* Check the parameters */
;;;791      assert_param(IS_ADC_STATUS_FLAG(Flag));
;;;792    
;;;793      if ((ADC_GetStatus() & Flag) == 0)
000288  f7fffffe          BL       ADC_GetStatus
00028c  4218              TST      r0,r3
00028e  d101              BNE      |L1.660|
;;;794      {
;;;795        bitstatus = RESET;
000290  2200              MOVS     r2,#0
000292  e000              B        |L1.662|
                  |L1.660|
;;;796      }
;;;797      else
;;;798      {
;;;799        bitstatus = SET;
000294  2201              MOVS     r2,#1
                  |L1.662|
;;;800      }
;;;801    
;;;802      return bitstatus;
000296  4610              MOV      r0,r2
;;;803    }
000298  bd00              POP      {pc}
;;;804    
                          ENDP

                  ADC1_GetFlagStatus PROC
;;;813      */
;;;814    FlagStatus ADC1_GetFlagStatus(uint32_t Flag)
00029a  4601              MOV      r1,r0
;;;815    {
;;;816      FlagStatus bitstatus;
;;;817    
;;;818      /* Check the parameters */
;;;819      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;820    
;;;821      if ((MDR_ADC->ADC1_STATUS & Flag) == 0)
00029c  4a40              LDR      r2,|L1.928|
00029e  6a12              LDR      r2,[r2,#0x20]
0002a0  420a              TST      r2,r1
0002a2  d101              BNE      |L1.680|
;;;822      {
;;;823        bitstatus = RESET;
0002a4  2000              MOVS     r0,#0
0002a6  e000              B        |L1.682|
                  |L1.680|
;;;824      }
;;;825      else
;;;826      {
;;;827        bitstatus = SET;
0002a8  2001              MOVS     r0,#1
                  |L1.682|
;;;828      }
;;;829    
;;;830      return bitstatus;
;;;831    }
0002aa  4770              BX       lr
;;;832    
                          ENDP

                  ADC2_GetFlagStatus PROC
;;;844      */
;;;845    FlagStatus ADC2_GetFlagStatus(uint32_t Flag)
0002ac  4601              MOV      r1,r0
;;;846    {
;;;847      FlagStatus bitstatus;
;;;848    
;;;849      /* Check the parameters */
;;;850      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;851    
;;;852      if ((MDR_ADC->ADC2_STATUS & Flag) == 0)
0002ae  4a3c              LDR      r2,|L1.928|
0002b0  6a52              LDR      r2,[r2,#0x24]
0002b2  420a              TST      r2,r1
0002b4  d101              BNE      |L1.698|
;;;853      {
;;;854        bitstatus = RESET;
0002b6  2000              MOVS     r0,#0
0002b8  e000              B        |L1.700|
                  |L1.698|
;;;855      }
;;;856      else
;;;857      {
;;;858        bitstatus = SET;
0002ba  2001              MOVS     r0,#1
                  |L1.700|
;;;859      }
;;;860    
;;;861      return bitstatus;
;;;862    }
0002bc  4770              BX       lr
;;;863    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_ClearOverwriteFlag PROC
;;;869      */
;;;870    void ADC1_ClearOverwriteFlag(void)
0002be  4838              LDR      r0,|L1.928|
;;;871    {
;;;872      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OVERWRITE;
0002c0  6a00              LDR      r0,[r0,#0x20]
0002c2  f0200001          BIC      r0,r0,#1
0002c6  4936              LDR      r1,|L1.928|
0002c8  6208              STR      r0,[r1,#0x20]
;;;873    }
0002ca  4770              BX       lr
;;;874    
                          ENDP

                  ADC2_ClearOverwriteFlag PROC
;;;882      */
;;;883    void ADC2_ClearOverwriteFlag(void)
0002cc  4834              LDR      r0,|L1.928|
;;;884    {
;;;885      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OVERWRITE;
0002ce  6a40              LDR      r0,[r0,#0x24]
0002d0  f0200001          BIC      r0,r0,#1
0002d4  4932              LDR      r1,|L1.928|
0002d6  6248              STR      r0,[r1,#0x24]
;;;886    }
0002d8  4770              BX       lr
;;;887    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC1_ClearOutOfRangeFlag PROC
;;;893      */
;;;894    void ADC1_ClearOutOfRangeFlag(void)
0002da  4831              LDR      r0,|L1.928|
;;;895    {
;;;896      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
0002dc  6a00              LDR      r0,[r0,#0x20]
0002de  f0200002          BIC      r0,r0,#2
0002e2  492f              LDR      r1,|L1.928|
0002e4  6208              STR      r0,[r1,#0x20]
;;;897    }
0002e6  4770              BX       lr
;;;898    
                          ENDP

                  ADC2_ClearOutOfRangeFlag PROC
;;;906      */
;;;907    void ADC2_ClearOutOfRangeFlag(void)
0002e8  482d              LDR      r0,|L1.928|
;;;908    {
;;;909      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
0002ea  6a40              LDR      r0,[r0,#0x24]
0002ec  f0200002          BIC      r0,r0,#2
0002f0  492b              LDR      r1,|L1.928|
0002f2  6248              STR      r0,[r1,#0x24]
;;;910    }
0002f4  4770              BX       lr
;;;911    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC_ITConfig PROC
;;;924      */
;;;925    void ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002f6  b530              PUSH     {r4,r5,lr}
;;;926    {
0002f8  4604              MOV      r4,r0
0002fa  460a              MOV      r2,r1
;;;927      uint32_t tmpreg_ADC1_IE;
;;;928      uint32_t tmpreg_ADC_IT;
;;;929    #if defined  (USE_MDR1986VE9x)
;;;930      uint32_t tmpreg_ADC2_IE;
;;;931    #endif
;;;932    
;;;933      /* Check the parameters */
;;;934      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;935      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;936    
;;;937      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
0002fc  4d28              LDR      r5,|L1.928|
0002fe  6a2b              LDR      r3,[r5,#0x20]
;;;938      tmpreg_ADC_IT = ADC_IT << 2;
000300  00a0              LSLS     r0,r4,#2
;;;939    
;;;940      /* Form new value */
;;;941      if (NewState != DISABLE)
000302  b112              CBZ      r2,|L1.778|
;;;942      {
;;;943        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;944        tmpreg_ADC1_IE |= tmpreg_ADC_IT & 0xFFFF;
000304  b285              UXTH     r5,r0
000306  432b              ORRS     r3,r3,r5
000308  e001              B        |L1.782|
                  |L1.778|
;;;945      }
;;;946      else
;;;947      {
;;;948        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;949        tmpreg_ADC1_IE &= ~(tmpreg_ADC_IT & 0xFFFF);
00030a  b285              UXTH     r5,r0
00030c  43ab              BICS     r3,r3,r5
                  |L1.782|
;;;950      }
;;;951    
;;;952      /* Configure ADCx_STATUS registers with new value */
;;;953      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
00030e  4d24              LDR      r5,|L1.928|
000310  622b              STR      r3,[r5,#0x20]
;;;954    
;;;955    #if defined  (USE_MDR1986VE9x)
;;;956    
;;;957      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
000312  6a69              LDR      r1,[r5,#0x24]
;;;958    
;;;959      /* Form new value */
;;;960      if (NewState != DISABLE)
000314  b112              CBZ      r2,|L1.796|
;;;961      {
;;;962        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;963        tmpreg_ADC2_IE |= tmpreg_ADC_IT >> 16;
000316  ea414110          ORR      r1,r1,r0,LSR #16
00031a  e001              B        |L1.800|
                  |L1.796|
;;;964      }
;;;965      else
;;;966      {
;;;967        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;968        tmpreg_ADC2_IE &= ~(tmpreg_ADC_IT >> 16);
00031c  ea214110          BIC      r1,r1,r0,LSR #16
                  |L1.800|
;;;969      }
;;;970      /* Configure ADCx_STATUS registers with new value */
;;;971      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
000320  4d1f              LDR      r5,|L1.928|
000322  6269              STR      r1,[r5,#0x24]
;;;972    #endif /* #if defined  (USE_MDR1986VE9x) */
;;;973    }
000324  bd30              POP      {r4,r5,pc}
;;;974    
                          ENDP

                  ADC1_ITConfig PROC
;;;984      */
;;;985    void ADC1_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000326  460a              MOV      r2,r1
;;;986    {
;;;987      uint32_t tmpreg_ADC1_IE;
;;;988    
;;;989      /* Check the parameters */
;;;990      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;991      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;992    
;;;993      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
000328  4b1d              LDR      r3,|L1.928|
00032a  6a19              LDR      r1,[r3,#0x20]
;;;994    
;;;995      /* Form new value */
;;;996      if (NewState != DISABLE)
00032c  b112              CBZ      r2,|L1.820|
;;;997      {
;;;998        /* Enable the ADC Interrupt requests by setting bits in the ADC1_STATUS register */
;;;999        tmpreg_ADC1_IE |= (ADC_IT << 2);
00032e  ea410180          ORR      r1,r1,r0,LSL #2
000332  e001              B        |L1.824|
                  |L1.820|
;;;1000     }
;;;1001     else
;;;1002     {
;;;1003       /* Disable the ADC Interrupt requests by clearing bits in the ADC1_STATUS register */
;;;1004       tmpreg_ADC1_IE &= ~(ADC_IT << 2);
000334  ea210180          BIC      r1,r1,r0,LSL #2
                  |L1.824|
;;;1005     }
;;;1006   
;;;1007     /* Configure ADC1_STATUS registers with new value */
;;;1008     MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
000338  4b19              LDR      r3,|L1.928|
00033a  6219              STR      r1,[r3,#0x20]
;;;1009   }
00033c  4770              BX       lr
;;;1010   
                          ENDP

                  ADC2_ITConfig PROC
;;;1023     */
;;;1024   void ADC2_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
00033e  460a              MOV      r2,r1
;;;1025   {
;;;1026     uint32_t tmpreg_ADC2_IE;
;;;1027   
;;;1028     /* Check the parameters */
;;;1029     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1030     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1031   
;;;1032     tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
000340  4b17              LDR      r3,|L1.928|
000342  6a59              LDR      r1,[r3,#0x24]
;;;1033   
;;;1034     /* Form new value */
;;;1035     if (NewState != DISABLE)
000344  b112              CBZ      r2,|L1.844|
;;;1036     {
;;;1037       /* Enable the ADC Interrupt requests by setting bits in the ADC2_STATUS register */
;;;1038       tmpreg_ADC2_IE |= (ADC_IT << 2);
000346  ea410180          ORR      r1,r1,r0,LSL #2
00034a  e001              B        |L1.848|
                  |L1.844|
;;;1039     }
;;;1040     else
;;;1041     {
;;;1042       /* Disable the ADC Interrupt requests by clearing bits in the ADC2_STATUS register */
;;;1043       tmpreg_ADC2_IE &= ~(ADC_IT << 2);
00034c  ea210180          BIC      r1,r1,r0,LSL #2
                  |L1.848|
;;;1044     }
;;;1045   
;;;1046     /* Configure ADC2_STATUS registers with new value */
;;;1047     MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
000350  4b13              LDR      r3,|L1.928|
000352  6259              STR      r1,[r3,#0x24]
;;;1048   }
000354  4770              BX       lr
;;;1049   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  ADC_GetITStatus PROC
;;;1060     */
;;;1061   ITStatus ADC_GetITStatus(uint32_t ADC_IT)
000356  b510              PUSH     {r4,lr}
;;;1062   {
000358  4604              MOV      r4,r0
;;;1063     ITStatus bitstatus;
;;;1064     uint32_t tmpreg;
;;;1065   
;;;1066     /* Check the parameters */
;;;1067     assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;1068   
;;;1069     tmpreg = ADC_GetStatus();
00035a  f7fffffe          BL       ADC_GetStatus
00035e  4603              MOV      r3,r0
;;;1070     tmpreg &= (tmpreg >> 2) & ADC_IT;
000360  ea040093          AND      r0,r4,r3,LSR #2
000364  4003              ANDS     r3,r3,r0
;;;1071   
;;;1072     if (tmpreg == 0)
000366  b90b              CBNZ     r3,|L1.876|
;;;1073     {
;;;1074       bitstatus = RESET;
000368  2200              MOVS     r2,#0
00036a  e000              B        |L1.878|
                  |L1.876|
;;;1075     }
;;;1076     else
;;;1077     {
;;;1078       bitstatus = SET;
00036c  2201              MOVS     r2,#1
                  |L1.878|
;;;1079     }
;;;1080   
;;;1081     return bitstatus;
00036e  4610              MOV      r0,r2
;;;1082   }
000370  bd10              POP      {r4,pc}
;;;1083   
                          ENDP

                  ADC1_GetITStatus PROC
;;;1091     */
;;;1092   ITStatus ADC1_GetITStatus(uint32_t ADC_IT)
000372  4602              MOV      r2,r0
;;;1093   {
;;;1094     ITStatus bitstatus;
;;;1095     uint32_t tmpreg;
;;;1096   
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1099   
;;;1100     tmpreg = MDR_ADC->ADC1_STATUS;
000374  4b0a              LDR      r3,|L1.928|
000376  6a19              LDR      r1,[r3,#0x20]
;;;1101     tmpreg &= (tmpreg >> 2) & ADC_IT;
000378  ea020391          AND      r3,r2,r1,LSR #2
00037c  4019              ANDS     r1,r1,r3
;;;1102   
;;;1103     if (tmpreg == 0)
00037e  b909              CBNZ     r1,|L1.900|
;;;1104     {
;;;1105       bitstatus = RESET;
000380  2000              MOVS     r0,#0
000382  e000              B        |L1.902|
                  |L1.900|
;;;1106     }
;;;1107     else
;;;1108     {
;;;1109       bitstatus = SET;
000384  2001              MOVS     r0,#1
                  |L1.902|
;;;1110     }
;;;1111   
;;;1112     return bitstatus;
;;;1113   }
000386  4770              BX       lr
;;;1114   
                          ENDP

                  ADC2_GetITStatus PROC
;;;1125     */
;;;1126   ITStatus ADC2_GetITStatus(uint32_t ADC_IT)
000388  4602              MOV      r2,r0
;;;1127   {
;;;1128     ITStatus bitstatus;
;;;1129     uint32_t tmpreg;
;;;1130   
;;;1131     /* Check the parameters */
;;;1132     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1133   
;;;1134     tmpreg = MDR_ADC->ADC2_STATUS;
00038a  4b05              LDR      r3,|L1.928|
00038c  6a59              LDR      r1,[r3,#0x24]
;;;1135     tmpreg &= (tmpreg >> 2) & ADC_IT;
00038e  ea020391          AND      r3,r2,r1,LSR #2
000392  4019              ANDS     r1,r1,r3
;;;1136   
;;;1137     if (tmpreg == 0)
000394  b909              CBNZ     r1,|L1.922|
;;;1138     {
;;;1139       bitstatus = RESET;
000396  2000              MOVS     r0,#0
000398  e000              B        |L1.924|
                  |L1.922|
;;;1140     }
;;;1141     else
;;;1142     {
;;;1143       bitstatus = SET;
00039a  2001              MOVS     r0,#1
                  |L1.924|
;;;1144     }
;;;1145   
;;;1146     return bitstatus;
;;;1147   }
00039c  4770              BX       lr
;;;1148   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

00039e  0000              DCW      0x0000
                  |L1.928|
                          DCD      0x40088000
                  |L1.932|
                          DCD      0xf01e0000
                  |L1.936|
                          DCD      0x01e10000
                  |L1.940|
                          DCD      0xf1ff0003
                  |L1.944|
                          DCD      0xf1fb0003

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_adc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH|
#line 144
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
