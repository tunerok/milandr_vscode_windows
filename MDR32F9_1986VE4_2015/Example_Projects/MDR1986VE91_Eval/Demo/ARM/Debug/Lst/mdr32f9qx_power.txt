; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_power.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_power.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_power.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_power.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  POWER_DeInit PROC
;;;103      */
;;;104    void POWER_DeInit(void)
000000  2000              MOVS     r0,#0
;;;105    {
;;;106      MDR_POWER -> PVDCS = (uint32_t) 0x00000000;
000002  494a              LDR      r1,|L1.300|
000004  6008              STR      r0,[r1,#0]
;;;107    }
000006  4770              BX       lr
;;;108    
                          ENDP

                  POWER_DUccMode PROC
;;;122      */
;;;123    void POWER_DUccMode(uint32_t DUccMode)
000008  4a49              LDR      r2,|L1.304|
;;;124    {
;;;125      uint32_t tmpreg;
;;;126      /* Check the parameters */
;;;127      assert_param(IS_POWER_DUCC_MODE(DUccMode));
;;;128      /* Clear POWER_REG0E[5:0] bits */
;;;129      tmpreg  = MDR_BKP -> REG_0E & (uint32_t) (~DUcc_Mask);
00000a  6b92              LDR      r2,[r2,#0x38]
00000c  f022013f          BIC      r1,r2,#0x3f
;;;130      /* Set POWER_REG0E[5:0] bits according to DUcc mode */
;;;131      tmpreg |= DUcc_Mask & DUccMode;
000010  f000023f          AND      r2,r0,#0x3f
000014  4311              ORRS     r1,r1,r2
;;;132      MDR_BKP -> REG_0E = tmpreg;
000016  4a46              LDR      r2,|L1.304|
000018  6391              STR      r1,[r2,#0x38]
;;;133    }
00001a  4770              BX       lr
;;;134    
                          ENDP

                  POWER_DUccTrim PROC
;;;148      */
;;;149    void POWER_DUccTrim(uint32_t DUccTrim)
00001c  4a44              LDR      r2,|L1.304|
;;;150    {
;;;151      uint32_t tmpreg;
;;;152      /* Check the parameters */
;;;153      assert_param(IS_POWER_DUCC_TRIM(DUccTrim));
;;;154      /* Clear POWER_REG0E[5:0] bits */
;;;155      tmpreg  = MDR_BKP -> REG_0E & (uint32_t) (~DUccTrim_Mask);
00001e  6b92              LDR      r2,[r2,#0x38]
000020  f42261e0          BIC      r1,r2,#0x700
;;;156      /* Set POWER_REG0E[5:0] bits according to DUcc mode */
;;;157      tmpreg |= DUccTrim_Mask & DUccTrim;
000024  f40062e0          AND      r2,r0,#0x700
000028  4311              ORRS     r1,r1,r2
;;;158      MDR_BKP -> REG_0E = tmpreg;
00002a  4a41              LDR      r2,|L1.304|
00002c  6391              STR      r1,[r2,#0x38]
;;;159    }
00002e  4770              BX       lr
;;;160    
                          ENDP

                  POWER_DUccStandby PROC
;;;165      */
;;;166    void POWER_DUccStandby ( void )
000030  2001              MOVS     r0,#1
;;;167    {
;;;168    #if defined (USE_MDR1986VE9x)
;;;169    *(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) 0x01;
000032  4940              LDR      r1,|L1.308|
000034  6008              STR      r0,[r1,#0]
;;;170    #elif defined (USE_MDR1986VE3)
;;;171    	MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
;;;172    #endif
;;;173    
;;;174    }
000036  4770              BX       lr
;;;175    
                          ENDP

                  POWER_PVDlevelConfig PROC
;;;190      */
;;;191    void POWER_PVDlevelConfig(uint32_t POWER_PVDlevel)
000038  4601              MOV      r1,r0
;;;192    {
;;;193      uint32_t tmpreg;
;;;194      /* Check the parameters */
;;;195      assert_param(IS_POWER_PVD_LEVEL(POWER_PVDlevel));
;;;196      tmpreg = MDR_POWER->PVDCS;
00003a  4a3c              LDR      r2,|L1.300|
00003c  6810              LDR      r0,[r2,#0]
;;;197      /* Clear PLS[5:3] bits */
;;;198      tmpreg &= (uint32_t) ~POWER_PVDCS_PLS_Msk;
00003e  f0200038          BIC      r0,r0,#0x38
;;;199      /* Set PLS[5:3] bits according to POWER_PVDlevel value */
;;;200      tmpreg |= (POWER_PVDlevel & POWER_PVDCS_PLS_Msk);
000042  f0010238          AND      r2,r1,#0x38
000046  4310              ORRS     r0,r0,r2
;;;201      /* Store the new value */
;;;202      MDR_POWER->PVDCS = tmpreg;
000048  4a38              LDR      r2,|L1.300|
00004a  6010              STR      r0,[r2,#0]
;;;203    }
00004c  4770              BX       lr
;;;204    
                          ENDP

                  POWER_PVBDlevelConfig PROC
;;;215      */
;;;216    void POWER_PVBDlevelConfig(uint32_t POWER_PVBDlevel)
00004e  4601              MOV      r1,r0
;;;217    {
;;;218      uint32_t tmpreg;
;;;219      /* Check the parameters */
;;;220      assert_param(IS_POWER_PVBD_LEVEL(POWER_PVBDlevel));
;;;221      tmpreg = MDR_POWER->PVDCS;
000050  4a36              LDR      r2,|L1.300|
000052  6810              LDR      r0,[r2,#0]
;;;222      /* Clear PBLS[2:1] bits */
;;;223      tmpreg &= (uint32_t) ~POWER_PVDCS_PBLS_Msk;
000054  f0200006          BIC      r0,r0,#6
;;;224      /* Set PBLS[2:1] bits according to POWER_PVBDlevel value */
;;;225      tmpreg |= (POWER_PVBDlevel & POWER_PVDCS_PBLS_Msk);
000058  f0010206          AND      r2,r1,#6
00005c  4310              ORRS     r0,r0,r2
;;;226      /* Store the new value */
;;;227      MDR_POWER->PVDCS = tmpreg;
00005e  4a33              LDR      r2,|L1.300|
000060  6010              STR      r0,[r2,#0]
;;;228    }
000062  4770              BX       lr
;;;229    
                          ENDP

                  POWER_SetFlagPOR PROC
;;;234      */
;;;235    void POWER_SetFlagPOR ( void )
000064  2001              MOVS     r0,#1
;;;236    {
;;;237    #if defined (USE_MDR1986VE9x)
;;;238    	*(__IO uint32_t *) BKP_FPOR_BB = (uint32_t) 0x01;
000066  4933              LDR      r1,|L1.308|
000068  39cc              SUBS     r1,r1,#0xcc
00006a  6008              STR      r0,[r1,#0]
;;;239    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;240    	MDR_BKP->REG_0E |= BKP_REG_0E_FPOR;
;;;241    #endif
;;;242    }
00006c  4770              BX       lr
;;;243    
                          ENDP

                  POWER_FlagPORstatus PROC
;;;248      */
;;;249    ErrorStatus POWER_FlagPORstatus(void)
00006e  2000              MOVS     r0,#0
;;;250    {
;;;251      ErrorStatus state = ERROR;
;;;252    #if defined (USE_MDR1986VE9x)
;;;253      if (*(__IO uint32_t *) BKP_FPOR_BB == 0)
000070  4930              LDR      r1,|L1.308|
000072  39cc              SUBS     r1,r1,#0xcc
000074  6809              LDR      r1,[r1,#0]
000076  b901              CBNZ     r1,|L1.122|
;;;254      {
;;;255        state = SUCCESS;
000078  2001              MOVS     r0,#1
                  |L1.122|
;;;256      }
;;;257    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;258      if (( MDR_BKP->REG_0E & BKP_REG_0E_FPOR ) == BKP_REG_0E_FPOR) {
;;;259    	  state = SUCCESS;
;;;260      }
;;;261    #endif
;;;262      return state;
;;;263    }
00007a  4770              BX       lr
;;;264    
                          ENDP

                  POWER_PVDenable PROC
;;;270      */
;;;271    void POWER_PVDenable ( FunctionalState NewState )
00007c  492e              LDR      r1,|L1.312|
;;;272    {
;;;273    	/* Check the parameters */
;;;274    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;275    #if defined (USE_MDR1986VE9x)
;;;276    	*(__IO uint32_t *) POWER_PVDEN_BB = (uint32_t) NewState;
00007e  6008              STR      r0,[r1,#0]
;;;277    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;278    	if(NewState != DISABLE){
;;;279    		MDR_POWER->PVDCS |= POWER_PVDCS_PVDEN;
;;;280    	}
;;;281    	else {
;;;282    		MDR_POWER->PVDCS &= ~POWER_PVDCS_PVDEN;
;;;283    	}
;;;284    #endif
;;;285    }
000080  4770              BX       lr
;;;286    
                          ENDP

                  POWER_GetFlagStatus PROC
;;;295      */
;;;296    FlagStatus POWER_GetFlagStatus(uint32_t POWER_FLAG)
000082  4601              MOV      r1,r0
;;;297    {
;;;298      FlagStatus status;
;;;299      /* Check the parameters */
;;;300      assert_param(IS_POWER_FLAG(POWER_FLAG));
;;;301    
;;;302      if ((MDR_POWER->PVDCS & POWER_FLAG) != (uint32_t)RESET)
000084  4a29              LDR      r2,|L1.300|
000086  6812              LDR      r2,[r2,#0]
000088  420a              TST      r2,r1
00008a  d001              BEQ      |L1.144|
;;;303      {
;;;304        status = SET;
00008c  2001              MOVS     r0,#1
00008e  e000              B        |L1.146|
                  |L1.144|
;;;305      }
;;;306      else
;;;307      {
;;;308        status = RESET;
000090  2000              MOVS     r0,#0
                  |L1.146|
;;;309      }
;;;310      /* Return the flag status */
;;;311      return status;
;;;312    }
000092  4770              BX       lr
;;;313    
                          ENDP

                  POWER_ClearFlag PROC
;;;321      */
;;;322    void POWER_ClearFlag(uint32_t POWER_FLAG)
000094  4925              LDR      r1,|L1.300|
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_POWER_FLAG(POWER_FLAG));
;;;326    
;;;327      MDR_POWER->PVDCS &= (uint32_t) ~POWER_FLAG;
000096  6809              LDR      r1,[r1,#0]
000098  4381              BICS     r1,r1,r0
00009a  4a24              LDR      r2,|L1.300|
00009c  6011              STR      r1,[r2,#0]
;;;328    }
00009e  4770              BX       lr
;;;329    
                          ENDP

                  POWER_PVD_ITconfig PROC
;;;339      */
;;;340    void POWER_PVD_ITconfig(uint32_t POWER_IT, FunctionalState NewState)
0000a0  b129              CBZ      r1,|L1.174|
;;;341    {
;;;342      /* Check the parameters */
;;;343      assert_param(IS_POWER_PVD_IT(POWER_IT));
;;;344      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;345    
;;;346      if (NewState != DISABLE)
;;;347      {
;;;348        MDR_POWER->PVDCS |= POWER_IT;
0000a2  4a22              LDR      r2,|L1.300|
0000a4  6812              LDR      r2,[r2,#0]
0000a6  4302              ORRS     r2,r2,r0
0000a8  4b20              LDR      r3,|L1.300|
0000aa  601a              STR      r2,[r3,#0]
0000ac  e004              B        |L1.184|
                  |L1.174|
;;;349      }
;;;350      else
;;;351      {
;;;352        MDR_POWER->PVDCS &= (uint32_t)~POWER_IT;
0000ae  4a1f              LDR      r2,|L1.300|
0000b0  6812              LDR      r2,[r2,#0]
0000b2  4382              BICS     r2,r2,r0
0000b4  4b1d              LDR      r3,|L1.300|
0000b6  601a              STR      r2,[r3,#0]
                  |L1.184|
;;;353      }
;;;354    }
0000b8  4770              BX       lr
;;;355    
                          ENDP

                  POWER_PVD_INVconfig PROC
;;;366      */
;;;367    void POWER_PVD_INVconfig(uint32_t POWER_INV, FunctionalState NewState)
0000ba  b129              CBZ      r1,|L1.200|
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_POWER_PVD_INV(POWER_INV));
;;;371      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;372    
;;;373      if (NewState != DISABLE)
;;;374      {
;;;375        MDR_POWER->PVDCS |= POWER_INV;
0000bc  4a1b              LDR      r2,|L1.300|
0000be  6812              LDR      r2,[r2,#0]
0000c0  4302              ORRS     r2,r2,r0
0000c2  4b1a              LDR      r3,|L1.300|
0000c4  601a              STR      r2,[r3,#0]
0000c6  e004              B        |L1.210|
                  |L1.200|
;;;376      }
;;;377      else
;;;378      {
;;;379        MDR_POWER->PVDCS &= (uint32_t)~POWER_INV;
0000c8  4a18              LDR      r2,|L1.300|
0000ca  6812              LDR      r2,[r2,#0]
0000cc  4382              BICS     r2,r2,r0
0000ce  4b17              LDR      r3,|L1.300|
0000d0  601a              STR      r2,[r3,#0]
                  |L1.210|
;;;380      }
;;;381    }
0000d2  4770              BX       lr
;;;382    #if defined (USE_MDR1986VE9x)
                          ENDP

                  POWER_EnterSTOPMode PROC
;;;394      */
;;;395    void POWER_EnterSTOPMode(FunctionalState POWER_Regulator_state, uint8_t POWER_STOPentry)
0000d4  b908              CBNZ     r0,|L1.218|
;;;396    {
;;;397      /* Check the parameters */
;;;398      assert_param(IS_FUNCTIONAL_STATE(POWER_Regulator_state));
;;;399      assert_param(IS_POWER_STOP_ENTRY(POWER_STOPentry));
;;;400    
;;;401      /* Set UDcc stanby status */
;;;402    
;;;403       *(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) (!POWER_Regulator_state);
0000d6  2201              MOVS     r2,#1
0000d8  e000              B        |L1.220|
                  |L1.218|
0000da  2200              MOVS     r2,#0
                  |L1.220|
0000dc  4b15              LDR      r3,|L1.308|
0000de  601a              STR      r2,[r3,#0]
;;;404       /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;405       *(__IO uint32_t *) SCB -> SCR |= SCB_SCR_SLEEPDEEP_Msk;
0000e0  4b16              LDR      r3,|L1.316|
0000e2  681a              LDR      r2,[r3,#0]
0000e4  6813              LDR      r3,[r2,#0]
0000e6  f0430304          ORR      r3,r3,#4
0000ea  6013              STR      r3,[r2,#0]
;;;406    
;;;407       if(POWER_Regulator_state == ENABLE){
0000ec  2801              CMP      r0,#1
0000ee  d106              BNE      |L1.254|
;;;408    	   MDR_BKP->REG_0F &= ~BKP_REG_0F_STANDBY;
0000f0  4a0f              LDR      r2,|L1.304|
0000f2  6bd2              LDR      r2,[r2,#0x3c]
0000f4  f0224280          BIC      r2,r2,#0x40000000
0000f8  4b0d              LDR      r3,|L1.304|
0000fa  63da              STR      r2,[r3,#0x3c]
0000fc  e005              B        |L1.266|
                  |L1.254|
;;;409       }
;;;410       else{
;;;411    	   MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
0000fe  4a0c              LDR      r2,|L1.304|
000100  6bd2              LDR      r2,[r2,#0x3c]
000102  f0424280          ORR      r2,r2,#0x40000000
000106  4b0a              LDR      r3,|L1.304|
000108  63da              STR      r2,[r3,#0x3c]
                  |L1.266|
;;;412       }
;;;413      /* Select STOP mode entry --------------------------------------------------*/
;;;414      if(POWER_STOPentry == POWER_STOPentry_WFI)
00010a  2901              CMP      r1,#1
00010c  d101              BNE      |L1.274|
;;;415      {
;;;416        /* Request Wait For Interrupt */
;;;417        __WFI();
00010e  bf30              WFI      
000110  e000              B        |L1.276|
                  |L1.274|
;;;418      }
;;;419      else
;;;420      {
;;;421        /* Request Wait For Event */
;;;422        __WFE();
000112  bf20              WFE      
                  |L1.276|
;;;423      }
;;;424    }
000114  4770              BX       lr
;;;425    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
                          ENDP

                  POWER_EnterSTANDBYMode PROC
;;;446      */
;;;447    void POWER_EnterSTANDBYMode ( void )
000116  2001              MOVS     r0,#1
;;;448    {
;;;449    	/* Select STANDBY mode */
;;;450    #if defined (USE_MDR1986VE9x)
;;;451    	*(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) 0x01;
000118  4906              LDR      r1,|L1.308|
00011a  6008              STR      r0,[r1,#0]
;;;452    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;453    	*(__IO uint32_t *) SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00011c  4907              LDR      r1,|L1.316|
00011e  6808              LDR      r0,[r1,#0]
000120  6801              LDR      r1,[r0,#0]
000122  f0410104          ORR      r1,r1,#4
000126  6001              STR      r1,[r0,#0]
;;;454    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;455    	MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
;;;456    #endif
;;;457    	/* Request Wait For Interrupt */
;;;458    	__WFI();
000128  bf30              WFI      
;;;459    }
00012a  4770              BX       lr
;;;460    
                          ENDP

                  |L1.300|
                          DCD      0x40058000
                  |L1.304|
                          DCD      0x400d8000
                  |L1.308|
                          DCD      0x43b007f8
                  |L1.312|
                          DCD      0x42b00000
                  |L1.316|
                          DCD      0xe000ed10

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_power.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____REVSH|
#line 144
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
