; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_timer.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_timer.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_timer.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIMER_DeInit PROC
;;;45       */
;;;46     void TIMER_DeInit ( MDR_TIMER_TypeDef* TIMERx ) {
000000  2100              MOVS     r1,#0
;;;47     	/* Check the parameters */
;;;48     	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;49     
;;;50     	TIMERx->CNTRL = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;51     	TIMERx->CNT = 0;
000004  6001              STR      r1,[r0,#0]
;;;52     	TIMERx->PSG = 0;
000006  6041              STR      r1,[r0,#4]
;;;53     	TIMERx->ARR = 0;
000008  6081              STR      r1,[r0,#8]
;;;54     
;;;55     	TIMERx->CH1_CNTRL = 0;
00000a  6201              STR      r1,[r0,#0x20]
;;;56     	TIMERx->CH2_CNTRL = 0;
00000c  6241              STR      r1,[r0,#0x24]
;;;57     	TIMERx->CH3_CNTRL = 0;
00000e  6281              STR      r1,[r0,#0x28]
;;;58     	TIMERx->CH4_CNTRL = 0;
000010  62c1              STR      r1,[r0,#0x2c]
;;;59     	TIMERx->CH1_CNTRL1 = 0;
000012  6301              STR      r1,[r0,#0x30]
;;;60     	TIMERx->CH2_CNTRL1 = 0;
000014  6341              STR      r1,[r0,#0x34]
;;;61     	TIMERx->CH3_CNTRL1 = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;62     	TIMERx->CH4_CNTRL1 = 0;
000018  63c1              STR      r1,[r0,#0x3c]
;;;63     	TIMERx->CH1_CNTRL2 = 0;
00001a  6601              STR      r1,[r0,#0x60]
;;;64     	TIMERx->CH2_CNTRL2 = 0;
00001c  6641              STR      r1,[r0,#0x64]
;;;65     	TIMERx->CH3_CNTRL2 = 0;
00001e  6681              STR      r1,[r0,#0x68]
;;;66     	TIMERx->CH4_CNTRL2 = 0;
000020  66c1              STR      r1,[r0,#0x6c]
;;;67     
;;;68     	TIMERx->CCR1 = 0;
000022  6101              STR      r1,[r0,#0x10]
;;;69     	TIMERx->CCR2 = 0;
000024  6141              STR      r1,[r0,#0x14]
;;;70     	TIMERx->CCR3 = 0;
000026  6181              STR      r1,[r0,#0x18]
;;;71     	TIMERx->CCR4 = 0;
000028  61c1              STR      r1,[r0,#0x1c]
;;;72     	TIMERx->CCR11 = 0;
00002a  6701              STR      r1,[r0,#0x70]
;;;73     	TIMERx->CCR21 = 0;
00002c  6741              STR      r1,[r0,#0x74]
;;;74     	TIMERx->CCR31 = 0;
00002e  6781              STR      r1,[r0,#0x78]
;;;75     	TIMERx->CCR41 = 0;
000030  67c1              STR      r1,[r0,#0x7c]
;;;76     	TIMERx->CH1_DTG = 0;
000032  6401              STR      r1,[r0,#0x40]
;;;77     	TIMERx->CH2_DTG = 0;
000034  6441              STR      r1,[r0,#0x44]
;;;78     	TIMERx->CH3_DTG = 0;
000036  6481              STR      r1,[r0,#0x48]
;;;79     	TIMERx->CH4_DTG = 0;
000038  64c1              STR      r1,[r0,#0x4c]
;;;80     	TIMERx->BRKETR_CNTRL = 0;
00003a  6501              STR      r1,[r0,#0x50]
;;;81     	TIMERx->STATUS = 0;
00003c  6541              STR      r1,[r0,#0x54]
;;;82     	TIMERx->IE = 0;
00003e  6581              STR      r1,[r0,#0x58]
;;;83     	TIMERx->DMA_RE = 0;
000040  65c1              STR      r1,[r0,#0x5c]
;;;84     #if defined(USE_MDR1986VE3) || defined (USE_MDR1986VE1T) /* For Cortex M1 */
;;;85     	TIMERx->DMA_REChx[0] = TIMERx->DMA_REChx[1] =
;;;86     			TIMERx->DMA_REChx[2] = TIMERx->DMA_REChx[3] = 0;
;;;87     #endif
;;;88     }
000042  4770              BX       lr
;;;89     
                          ENDP

                  TIMER_CntInit PROC
;;;98       */
;;;99     void TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000044  b530              PUSH     {r4,r5,lr}
;;;100    {
;;;101      uint32_t tmpreg_CNTRL;
;;;102      uint32_t tmpreg_BRKETR_CNTRL;
;;;103    
;;;104      /* Check the parameters */
;;;105      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;106      assert_param(IS_TIMER_COUNTER_MODE(TIMER_CntInitStruct->TIMER_CounterMode));
;;;107      assert_param(IS_TIMER_COUNTER_DIR(TIMER_CntInitStruct->TIMER_CounterDirection));
;;;108      assert_param(IS_TIMER_EVENT_SOURCE(TIMER_CntInitStruct->TIMER_EventSource));
;;;109      assert_param(IS_TIMER_FILTER_SAMPLING(TIMER_CntInitStruct->TIMER_FilterSampling));
;;;110      assert_param(IS_TIMER_ARR_UPDATE_MODE(TIMER_CntInitStruct->TIMER_ARR_UpdateMode));
;;;111      assert_param(IS_TIMER_FILTER_CONF(TIMER_CntInitStruct->TIMER_ETR_FilterConf));
;;;112      assert_param(IS_TIMER_ETR_PRESCALER(TIMER_CntInitStruct->TIMER_ETR_Prescaler));
;;;113      assert_param(IS_TIMER_ETR_POLARITY(TIMER_CntInitStruct->TIMER_ETR_Polarity));
;;;114      assert_param(IS_TIMER_BRK_POLARITY(TIMER_CntInitStruct->TIMER_BRK_Polarity));
;;;115    
;;;116      TIMERx->CNT = TIMER_CntInitStruct->TIMER_IniCounter;
000046  880c              LDRH     r4,[r1,#0]
000048  6004              STR      r4,[r0,#0]
;;;117      TIMERx->PSG = TIMER_CntInitStruct->TIMER_Prescaler;
00004a  884c              LDRH     r4,[r1,#2]
00004c  6044              STR      r4,[r0,#4]
;;;118      TIMERx->ARR = TIMER_CntInitStruct->TIMER_Period;
00004e  888c              LDRH     r4,[r1,#4]
000050  6084              STR      r4,[r0,#8]
;;;119    
;;;120      /* Form new value for the TIMERx_CNTRL register */
;;;121      tmpreg_CNTRL = TIMER_CntInitStruct->TIMER_CounterMode
000052  88cc              LDRH     r4,[r1,#6]
000054  890d              LDRH     r5,[r1,#8]
000056  442c              ADD      r4,r4,r5
000058  894d              LDRH     r5,[r1,#0xa]
00005a  442c              ADD      r4,r4,r5
00005c  898d              LDRH     r5,[r1,#0xc]
00005e  442c              ADD      r4,r4,r5
000060  89cd              LDRH     r5,[r1,#0xe]
000062  1963              ADDS     r3,r4,r5
;;;122                   + TIMER_CntInitStruct->TIMER_CounterDirection
;;;123                   + TIMER_CntInitStruct->TIMER_EventSource
;;;124                   + TIMER_CntInitStruct->TIMER_FilterSampling
;;;125                   + TIMER_CntInitStruct->TIMER_ARR_UpdateMode;
;;;126    
;;;127      /* Configure TIMERx_CNTRL register with new value */
;;;128      TIMERx->CNTRL = tmpreg_CNTRL;
000064  60c3              STR      r3,[r0,#0xc]
;;;129    
;;;130      /* Form new value for the TIMERx_BRKETR_CNTRL register */
;;;131      tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos)
000066  8a4c              LDRH     r4,[r1,#0x12]
000068  8a0d              LDRH     r5,[r1,#0x10]
00006a  eb041405          ADD      r4,r4,r5,LSL #4
00006e  8a8d              LDRH     r5,[r1,#0x14]
000070  442c              ADD      r4,r4,r5
000072  8acd              LDRH     r5,[r1,#0x16]
000074  1962              ADDS     r2,r4,r5
;;;132                          + TIMER_CntInitStruct->TIMER_ETR_Prescaler
;;;133                          + TIMER_CntInitStruct->TIMER_ETR_Polarity
;;;134                          + TIMER_CntInitStruct->TIMER_BRK_Polarity;
;;;135    
;;;136      /* Configure TIMERx_BRKETR_CNTRL register with new value */
;;;137      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000076  6502              STR      r2,[r0,#0x50]
;;;138    }
000078  bd30              POP      {r4,r5,pc}
;;;139    
                          ENDP

                  TIMER_CntStructInit PROC
;;;145      */
;;;146    void TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct)
00007a  2100              MOVS     r1,#0
;;;147    {
;;;148      TIMER_CntInitStruct->TIMER_IniCounter = 0;
00007c  8001              STRH     r1,[r0,#0]
;;;149      TIMER_CntInitStruct->TIMER_Prescaler  = 0;
00007e  8041              STRH     r1,[r0,#2]
;;;150      TIMER_CntInitStruct->TIMER_Period     = 0;
000080  8081              STRH     r1,[r0,#4]
;;;151      TIMER_CntInitStruct->TIMER_CounterMode      = TIMER_CntMode_ClkFixedDir;
000082  80c1              STRH     r1,[r0,#6]
;;;152      TIMER_CntInitStruct->TIMER_CounterDirection = TIMER_CntDir_Up;
000084  8101              STRH     r1,[r0,#8]
;;;153      TIMER_CntInitStruct->TIMER_EventSource      = TIMER_EvSrc_None;
000086  8141              STRH     r1,[r0,#0xa]
;;;154      TIMER_CntInitStruct->TIMER_FilterSampling   = TIMER_FDTS_TIMER_CLK_div_1;
000088  8181              STRH     r1,[r0,#0xc]
;;;155      TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = TIMER_ARR_Update_Immediately;
00008a  81c1              STRH     r1,[r0,#0xe]
;;;156      TIMER_CntInitStruct->TIMER_ETR_FilterConf   = TIMER_Filter_1FF_at_TIMER_CLK;
00008c  8201              STRH     r1,[r0,#0x10]
;;;157      TIMER_CntInitStruct->TIMER_ETR_Prescaler    = TIMER_ETR_Prescaler_None;
00008e  8241              STRH     r1,[r0,#0x12]
;;;158      TIMER_CntInitStruct->TIMER_ETR_Polarity     = TIMER_ETRPolarity_NonInverted;
000090  8281              STRH     r1,[r0,#0x14]
;;;159      TIMER_CntInitStruct->TIMER_BRK_Polarity     = TIMER_BRKPolarity_NonInverted;
000092  82c1              STRH     r1,[r0,#0x16]
;;;160    }
000094  4770              BX       lr
;;;161    
                          ENDP

                  TIMER_Cmd PROC
;;;168      */
;;;169    void TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)
000096  460a              MOV      r2,r1
;;;170    {
;;;171      uint32_t tmpreg_CNTRL;
;;;172    
;;;173      /* Check the parameters */
;;;174      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;175      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;176    
;;;177      tmpreg_CNTRL = TIMERx->CNTRL;
000098  68c1              LDR      r1,[r0,#0xc]
;;;178    
;;;179      /* Form new value */
;;;180      if (NewState != DISABLE)
00009a  b112              CBZ      r2,|L1.162|
;;;181      {
;;;182        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;183        tmpreg_CNTRL |= TIMER_CNTRL_CNT_EN;
00009c  f0410101          ORR      r1,r1,#1
0000a0  e001              B        |L1.166|
                  |L1.162|
;;;184      }
;;;185      else
;;;186      {
;;;187        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;188        tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_EN;
0000a2  f0210101          BIC      r1,r1,#1
                  |L1.166|
;;;189      }
;;;190    
;;;191      /* Configure CNTRL register with new value */
;;;192      TIMERx->CNTRL = tmpreg_CNTRL;
0000a6  60c1              STR      r1,[r0,#0xc]
;;;193    }
0000a8  4770              BX       lr
;;;194    
                          ENDP

                  TIMER_SetCounter PROC
;;;203    #elif defined (USE_MDR1986VE9x)
;;;204    void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter)
0000aa  6001              STR      r1,[r0,#0]
;;;205    #endif
;;;206    {
;;;207      /* Check the parameters */
;;;208      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;209    
;;;210      TIMERx->CNT = Counter;
;;;211    }
0000ac  4770              BX       lr
;;;212    
                          ENDP

                  TIMER_SetCntPrescaler PROC
;;;218      */
;;;219    void TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler)
0000ae  6041              STR      r1,[r0,#4]
;;;220    {
;;;221      /* Check the parameters */
;;;222      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;223    
;;;224      TIMERx->PSG = Prescaler;
;;;225    }
0000b0  4770              BX       lr
;;;226    
                          ENDP

                  TIMER_SetCntAutoreload PROC
;;;235    #elif defined (USE_MDR1986VE9x)
;;;236    void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload)
0000b2  6081              STR      r1,[r0,#8]
;;;237    #endif
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;241    
;;;242      TIMERx->ARR = Autoreload;
;;;243    }
0000b4  4770              BX       lr
;;;244    
                          ENDP

                  TIMER_CntAutoreloadConfig PROC
;;;257    #elif defined (USE_MDR1986VE9x)
;;;258    void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode)
0000b6  b510              PUSH     {r4,lr}
;;;259    #endif
;;;260    {
0000b8  460b              MOV      r3,r1
;;;261      uint32_t tmpreg_CNTRL;
;;;262    
;;;263      /* Check the parameters */
;;;264      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;265      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;266    
;;;267      tmpreg_CNTRL = TIMERx->CNTRL;
0000ba  68c1              LDR      r1,[r0,#0xc]
;;;268      tmpreg_CNTRL &= ~TIMER_CNTRL_ARRB_EN;
0000bc  f0210102          BIC      r1,r1,#2
;;;269      tmpreg_CNTRL += UpdateMode;
0000c0  4411              ADD      r1,r1,r2
;;;270      TIMERx->CNTRL = tmpreg_CNTRL;
0000c2  60c1              STR      r1,[r0,#0xc]
;;;271    
;;;272      TIMERx->ARR = Autoreload;
0000c4  6083              STR      r3,[r0,#8]
;;;273    }
0000c6  bd10              POP      {r4,pc}
;;;274    
                          ENDP

                  TIMER_GetCounter PROC
;;;282    #elif defined (USE_MDR1986VE9x)
;;;283    uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
0000c8  4601              MOV      r1,r0
;;;284    #endif
;;;285    {
;;;286      /* Check the parameters */
;;;287      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;288    
;;;289      return TIMERx->CNT;
0000ca  6808              LDR      r0,[r1,#0]
0000cc  b280              UXTH     r0,r0
;;;290    }
0000ce  4770              BX       lr
;;;291    
                          ENDP

                  TIMER_CntEventSourceConfig PROC
;;;307      */
;;;308    void TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource)
0000d0  460a              MOV      r2,r1
;;;309    {
;;;310      uint32_t tmpreg_CNTRL;
;;;311    
;;;312      /* Check the parameters */
;;;313      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;314      assert_param(IS_TIMER_EVENT_SOURCE(EventSource));
;;;315    
;;;316      tmpreg_CNTRL = TIMERx->CNTRL;
0000d2  68c1              LDR      r1,[r0,#0xc]
;;;317      tmpreg_CNTRL &= ~TIMER_CNTRL_EVENT_SEL_Msk;
0000d4  f4216170          BIC      r1,r1,#0xf00
;;;318      tmpreg_CNTRL += EventSource;
0000d8  4411              ADD      r1,r1,r2
;;;319      TIMERx->CNTRL = tmpreg_CNTRL;
0000da  60c1              STR      r1,[r0,#0xc]
;;;320    }
0000dc  4770              BX       lr
;;;321    
                          ENDP

                  TIMER_FilterSamplingConfig PROC
;;;332      */
;;;333    void TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
0000de  460a              MOV      r2,r1
;;;334    {
;;;335      uint32_t tmpreg_CNTRL;
;;;336    
;;;337      /* Check the parameters */
;;;338      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;339      assert_param(IS_TIMER_FILTER_SAMPLING(Prescaler));
;;;340    
;;;341      tmpreg_CNTRL = TIMERx->CNTRL;
0000e0  68c1              LDR      r1,[r0,#0xc]
;;;342      tmpreg_CNTRL &= ~TIMER_CNTRL_FDTS_Msk;
0000e2  f0210130          BIC      r1,r1,#0x30
;;;343      tmpreg_CNTRL += Prescaler;
0000e6  4411              ADD      r1,r1,r2
;;;344      TIMERx->CNTRL = tmpreg_CNTRL;
0000e8  60c1              STR      r1,[r0,#0xc]
;;;345    }
0000ea  4770              BX       lr
;;;346    
                          ENDP

                  TIMER_CounterModeConfig PROC
;;;357      */
;;;358    void TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode)
0000ec  460a              MOV      r2,r1
;;;359    {
;;;360      uint32_t tmpreg_CNTRL;
;;;361    
;;;362      /* Check the parameters */
;;;363      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;364      assert_param(IS_TIMER_COUNTER_MODE(Mode));
;;;365    
;;;366      tmpreg_CNTRL = TIMERx->CNTRL;
0000ee  68c1              LDR      r1,[r0,#0xc]
;;;367      tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_MODE_Msk;
0000f0  f02101c0          BIC      r1,r1,#0xc0
;;;368      tmpreg_CNTRL += Mode;
0000f4  4411              ADD      r1,r1,r2
;;;369      TIMERx->CNTRL = tmpreg_CNTRL;
0000f6  60c1              STR      r1,[r0,#0xc]
;;;370    }
0000f8  4770              BX       lr
;;;371    
                          ENDP

                  TIMER_SetCounterDirection PROC
;;;380      */
;;;381    void TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction)
0000fa  460a              MOV      r2,r1
;;;382    {
;;;383      uint32_t tmpreg_CNTRL;
;;;384    
;;;385      /* Check the parameters */
;;;386      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;387      assert_param(IS_TIMER_COUNTER_DIR(Direction));
;;;388    
;;;389      tmpreg_CNTRL = TIMERx->CNTRL;
0000fc  68c1              LDR      r1,[r0,#0xc]
;;;390      tmpreg_CNTRL &= ~TIMER_CNTRL_DIR;
0000fe  f0210108          BIC      r1,r1,#8
;;;391      tmpreg_CNTRL += Direction;
000102  4411              ADD      r1,r1,r2
;;;392      TIMERx->CNTRL = tmpreg_CNTRL;
000104  60c1              STR      r1,[r0,#0xc]
;;;393    }
000106  4770              BX       lr
;;;394    
                          ENDP

                  TIMER_ETRInputConfig PROC
;;;427      */
;;;428    void TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter)
000108  b530              PUSH     {r4,r5,lr}
;;;429    {
00010a  460c              MOV      r4,r1
;;;430      uint32_t tmpreg_BRKETR_CNTRL;
;;;431    
;;;432      /* Check the parameters */
;;;433      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;434      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;435      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;436      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;437    
;;;438      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
00010c  6d01              LDR      r1,[r0,#0x50]
;;;439      tmpreg_BRKETR_CNTRL &= ~(TIMER_BRKETR_CNTRL_ETR_PSC_Msk + TIMER_BRKETR_CNTRL_ETR_INV + TIMER_BRKETR_CNTRL_ETR_FILTER_Msk);
00010e  f02101fe          BIC      r1,r1,#0xfe
;;;440      tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos);
000112  18a5              ADDS     r5,r4,r2
000114  eb051503          ADD      r5,r5,r3,LSL #4
000118  4429              ADD      r1,r1,r5
;;;441      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00011a  6501              STR      r1,[r0,#0x50]
;;;442    }
00011c  bd30              POP      {r4,r5,pc}
;;;443    
                          ENDP

                  TIMER_ETRFilterConfig PROC
;;;466      */
;;;467    void TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter)
00011e  460a              MOV      r2,r1
;;;468    {
;;;469      uint32_t tmpreg_BRKETR_CNTRL;
;;;470    
;;;471      /* Check the parameters */
;;;472      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;473      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;474    
;;;475      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000120  6d01              LDR      r1,[r0,#0x50]
;;;476      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_FILTER_Msk;
000122  f02101f0          BIC      r1,r1,#0xf0
;;;477      tmpreg_BRKETR_CNTRL += Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos;
000126  eb011102          ADD      r1,r1,r2,LSL #4
;;;478      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00012a  6501              STR      r1,[r0,#0x50]
;;;479    }
00012c  4770              BX       lr
;;;480    
                          ENDP

                  TIMER_ETRPrescalerConfig PROC
;;;491      */
;;;492    void TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
00012e  460a              MOV      r2,r1
;;;493    {
;;;494      uint32_t tmpreg_BRKETR_CNTRL;
;;;495    
;;;496      /* Check the parameters */
;;;497      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;498      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;499    
;;;500      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000130  6d01              LDR      r1,[r0,#0x50]
;;;501      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_PSC_Msk;
000132  f021010c          BIC      r1,r1,#0xc
;;;502      tmpreg_BRKETR_CNTRL += Prescaler;
000136  4411              ADD      r1,r1,r2
;;;503      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000138  6501              STR      r1,[r0,#0x50]
;;;504    }
00013a  4770              BX       lr
;;;505    
                          ENDP

                  TIMER_ETRPolarityConfig PROC
;;;514      */
;;;515    void TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
00013c  460a              MOV      r2,r1
;;;516    {
;;;517      uint32_t tmpreg_BRKETR_CNTRL;
;;;518    
;;;519      /* Check the parameters */
;;;520      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;521      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;522    
;;;523      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
00013e  6d01              LDR      r1,[r0,#0x50]
;;;524      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_INV;
000140  f0210102          BIC      r1,r1,#2
;;;525      tmpreg_BRKETR_CNTRL += Polarity;
000144  4411              ADD      r1,r1,r2
;;;526      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000146  6501              STR      r1,[r0,#0x50]
;;;527    }
000148  4770              BX       lr
;;;528    
                          ENDP

                  TIMER_BRKPolarityConfig PROC
;;;537      */
;;;538    void TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
00014a  460a              MOV      r2,r1
;;;539    {
;;;540      uint32_t tmpreg_BRKETR_CNTRL;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;544      assert_param(IS_TIMER_BRK_POLARITY(Polarity));
;;;545    
;;;546      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
00014c  6d01              LDR      r1,[r0,#0x50]
;;;547      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_BRK_INV;
00014e  f0210101          BIC      r1,r1,#1
;;;548      tmpreg_BRKETR_CNTRL += Polarity;
000152  4411              ADD      r1,r1,r2
;;;549      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000154  6501              STR      r1,[r0,#0x50]
;;;550    }
000156  4770              BX       lr
;;;551    
                          ENDP

                  TIMER_GetCounterDirection PROC
;;;556      */
;;;557    uint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx)
000158  4601              MOV      r1,r0
;;;558    {
;;;559      uint32_t bitstatus;
;;;560    
;;;561      /* Check the parameters */
;;;562      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;563    
;;;564      if ((TIMERx->CNTRL & TIMER_CNTRL_DIR) == 0)
00015a  68ca              LDR      r2,[r1,#0xc]
00015c  f0120f08          TST      r2,#8
000160  d101              BNE      |L1.358|
;;;565      {
;;;566        bitstatus = TIMER_CntDir_Up;
000162  2000              MOVS     r0,#0
000164  e000              B        |L1.360|
                  |L1.358|
;;;567      }
;;;568      else
;;;569      {
;;;570        bitstatus = TIMER_CntDir_Dn;
000166  2008              MOVS     r0,#8
                  |L1.360|
;;;571      }
;;;572    
;;;573      return bitstatus;
;;;574    }
000168  4770              BX       lr
;;;575    
                          ENDP

                  TIMER_GetCntWriteComplete PROC
;;;580      */
;;;581    FlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx)
00016a  4601              MOV      r1,r0
;;;582    {
;;;583      FlagStatus bitstatus;
;;;584    
;;;585      /* Check the parameters */
;;;586      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;587    
;;;588      if ((TIMERx->CNTRL & TIMER_CNTRL_WR_CMPL) == 0)
00016c  68ca              LDR      r2,[r1,#0xc]
00016e  f0120f04          TST      r2,#4
000172  d101              BNE      |L1.376|
;;;589      {
;;;590        bitstatus = RESET;
000174  2000              MOVS     r0,#0
000176  e000              B        |L1.378|
                  |L1.376|
;;;591      }
;;;592      else
;;;593      {
;;;594        bitstatus = SET;
000178  2001              MOVS     r0,#1
                  |L1.378|
;;;595      }
;;;596    
;;;597      return bitstatus;
;;;598    }
00017a  4770              BX       lr
;;;599    
                          ENDP

                  TIMER_ChnInit PROC
;;;608      */
;;;609    void TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
00017c  b570              PUSH     {r4-r6,lr}
;;;610    {
;;;611      uint32_t tmpreg_CH_Number;
;;;612      uint32_t tmpreg_CH_CNTRL;
;;;613      uint32_t tmpreg_CH_CNTRL2;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;617      assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnInitStruct->TIMER_CH_Number));
;;;618      assert_param(IS_TIMER_CHANNEL_MODE(TIMER_ChnInitStruct->TIMER_CH_Mode));
;;;619      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_ETR_Ena));
;;;620      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_ETR_Reset));
;;;621      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_BRK_Reset));
;;;622      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(TIMER_ChnInitStruct->TIMER_CH_REF_Format));
;;;623      assert_param(IS_TIMER_CHANNEL_PRESCALER(TIMER_ChnInitStruct->TIMER_CH_Prescaler));
;;;624      assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_EventSource));
;;;625      assert_param(IS_TIMER_FILTER_CONF(TIMER_ChnInitStruct->TIMER_CH_FilterConf));
;;;626      assert_param(IS_TIMER_CHANNEL_CCR_UPDATE_MODE(TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode));
;;;627      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena));
;;;628      assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource));
;;;629    
;;;630      tmpreg_CH_CNTRL = TIMER_ChnInitStruct->TIMER_CH_Mode
00017e  884d              LDRH     r5,[r1,#2]
000180  88ce              LDRH     r6,[r1,#6]
000182  4435              ADD      r5,r5,r6
000184  890e              LDRH     r6,[r1,#8]
000186  4435              ADD      r5,r5,r6
000188  894e              LDRH     r6,[r1,#0xa]
00018a  4435              ADD      r5,r5,r6
00018c  898e              LDRH     r6,[r1,#0xc]
00018e  eb051586          ADD      r5,r5,r6,LSL #6
000192  89ce              LDRH     r6,[r1,#0xe]
000194  4435              ADD      r5,r5,r6
000196  8a0e              LDRH     r6,[r1,#0x10]
000198  19ac              ADDS     r4,r5,r6
;;;631                      + TIMER_ChnInitStruct->TIMER_CH_ETR_Reset
;;;632                      + TIMER_ChnInitStruct->TIMER_CH_BRK_Reset
;;;633                      + TIMER_ChnInitStruct->TIMER_CH_REF_Format
;;;634                      + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << TIMER_CH_CNTRL_CHPSC_Pos)
;;;635                      + TIMER_ChnInitStruct->TIMER_CH_EventSource
;;;636                      + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << TIMER_CH_CNTRL_CHFLTR_Pos);
;;;637    
;;;638      if (TIMER_ChnInitStruct->TIMER_CH_ETR_Ena != DISABLE)
00019a  888d              LDRH     r5,[r1,#4]
00019c  b10d              CBZ      r5,|L1.418|
;;;639      {
;;;640        tmpreg_CH_CNTRL += TIMER_CH_CNTRL_ETREN;
00019e  f5045400          ADD      r4,r4,#0x2000
                  |L1.418|
;;;641      }
;;;642    
;;;643      tmpreg_CH_Number = TIMER_ChnInitStruct->TIMER_CH_Number;
0001a2  880a              LDRH     r2,[r1,#0]
;;;644    
;;;645      *(&TIMERx->CH1_CNTRL + tmpreg_CH_Number) = tmpreg_CH_CNTRL;
0001a4  f1000520          ADD      r5,r0,#0x20
0001a8  f8454022          STR      r4,[r5,r2,LSL #2]
;;;646    
;;;647      tmpreg_CH_CNTRL2 = TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode
0001ac  8a4d              LDRH     r5,[r1,#0x12]
0001ae  8ace              LDRH     r6,[r1,#0x16]
0001b0  19ab              ADDS     r3,r5,r6
;;;648                       + TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource;
;;;649    
;;;650      if (TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena != DISABLE)
0001b2  8a8d              LDRH     r5,[r1,#0x14]
0001b4  b105              CBZ      r5,|L1.440|
;;;651      {
;;;652        tmpreg_CH_CNTRL2 += TIMER_CH_CNTRL2_CCR1_EN;
0001b6  1d1b              ADDS     r3,r3,#4
                  |L1.440|
;;;653      }
;;;654    
;;;655      *(&TIMERx->CH1_CNTRL2 + tmpreg_CH_Number) = tmpreg_CH_CNTRL2;
0001b8  f1000560          ADD      r5,r0,#0x60
0001bc  f8453022          STR      r3,[r5,r2,LSL #2]
;;;656    }
0001c0  bd70              POP      {r4-r6,pc}
;;;657    
                          ENDP

                  TIMER_ChnStructInit PROC
;;;663      */
;;;664    void TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
0001c2  2100              MOVS     r1,#0
;;;665    {
;;;666      TIMER_ChnInitStruct->TIMER_CH_Number           = TIMER_CHANNEL1;
0001c4  8001              STRH     r1,[r0,#0]
;;;667      TIMER_ChnInitStruct->TIMER_CH_Mode             = TIMER_CH_MODE_PWM;
0001c6  8041              STRH     r1,[r0,#2]
;;;668      TIMER_ChnInitStruct->TIMER_CH_ETR_Ena          = DISABLE;
0001c8  8081              STRH     r1,[r0,#4]
;;;669      TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = TIMER_CH_ETR_RESET_Disable;
0001ca  80c1              STRH     r1,[r0,#6]
;;;670      TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = TIMER_CH_BRK_RESET_Disable;
0001cc  8101              STRH     r1,[r0,#8]
;;;671      TIMER_ChnInitStruct->TIMER_CH_REF_Format       = TIMER_CH_REF_Format0;
0001ce  8141              STRH     r1,[r0,#0xa]
;;;672      TIMER_ChnInitStruct->TIMER_CH_Prescaler        = TIMER_CH_Prescaler_None;
0001d0  8181              STRH     r1,[r0,#0xc]
;;;673      TIMER_ChnInitStruct->TIMER_CH_EventSource      = TIMER_CH_EvSrc_PE;
0001d2  81c1              STRH     r1,[r0,#0xe]
;;;674      TIMER_ChnInitStruct->TIMER_CH_FilterConf       = TIMER_Filter_1FF_at_TIMER_CLK;
0001d4  8201              STRH     r1,[r0,#0x10]
;;;675      TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = TIMER_CH_CCR_Update_Immediately;
0001d6  8241              STRH     r1,[r0,#0x12]
;;;676      TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena         = DISABLE;
0001d8  8281              STRH     r1,[r0,#0x14]
;;;677      TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE;
0001da  82c1              STRH     r1,[r0,#0x16]
;;;678    }
0001dc  4770              BX       lr
;;;679    
                          ENDP

                  TIMER_SetChnCompare PROC
;;;694    #elif defined (USE_MDR1986VE9x)
;;;695    void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001de  b510              PUSH     {r4,lr}
;;;696    #endif
;;;697    {
;;;698      __IO uint32_t *tmpreg_CCRx;
;;;699    
;;;700      /* Check the parameters */
;;;701      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;702      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;703    
;;;704      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
0001e0  f1000410          ADD      r4,r0,#0x10
0001e4  eb040381          ADD      r3,r4,r1,LSL #2
;;;705      *tmpreg_CCRx = Compare;
0001e8  601a              STR      r2,[r3,#0]
;;;706    }
0001ea  bd10              POP      {r4,pc}
;;;707    
                          ENDP

                  TIMER_SetChnCompare1 PROC
;;;722    #elif defined (USE_MDR1986VE9x)
;;;723    void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001ec  b510              PUSH     {r4,lr}
;;;724    #endif
;;;725    {
;;;726      __IO uint32_t *tmpreg_CCR1x;
;;;727    
;;;728      /* Check the parameters */
;;;729      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;730      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;731    
;;;732      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
0001ee  f1000470          ADD      r4,r0,#0x70
0001f2  eb040381          ADD      r3,r4,r1,LSL #2
;;;733      *tmpreg_CCR1x = Compare;
0001f6  601a              STR      r2,[r3,#0]
;;;734    }
0001f8  bd10              POP      {r4,pc}
;;;735    
                          ENDP

                  TIMER_ChnCompareConfig PROC
;;;754    #elif defined (USE_MDR1986VE9x)
;;;755    void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
0001fa  b5f0              PUSH     {r4-r7,lr}
;;;756    #endif
;;;757    {
0001fc  4614              MOV      r4,r2
;;;758      __IO uint32_t *tmpreg_CNTRL2x;
;;;759      __IO uint32_t *tmpreg_CCRx;
;;;760      uint32_t tmpreg_CNTRL2;
;;;761    
;;;762      /* Check the parameters */
;;;763      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;764      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;765      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;766    
;;;767      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
0001fe  f1000760          ADD      r7,r0,#0x60
000202  eb070581          ADD      r5,r7,r1,LSL #2
;;;768    
;;;769      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
000206  682a              LDR      r2,[r5,#0]
;;;770      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
000208  f0220208          BIC      r2,r2,#8
;;;771      tmpreg_CNTRL2 += UpdateMode;
00020c  441a              ADD      r2,r2,r3
;;;772      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
00020e  602a              STR      r2,[r5,#0]
;;;773    
;;;774      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000210  3f50              SUBS     r7,r7,#0x50
000212  eb070681          ADD      r6,r7,r1,LSL #2
;;;775    
;;;776      *tmpreg_CCRx = Compare;
000216  6034              STR      r4,[r6,#0]
;;;777    }
000218  bdf0              POP      {r4-r7,pc}
;;;778    
                          ENDP

                  TIMER_ChnCompare1Config PROC
;;;797    #elif defined (USE_MDR1986VE9x)
;;;798    void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
00021a  b5f0              PUSH     {r4-r7,lr}
;;;799    #endif
;;;800    {
00021c  4614              MOV      r4,r2
;;;801      __IO uint32_t *tmpreg_CNTRL2x;
;;;802      __IO uint32_t *tmpreg_CCR1x;
;;;803      uint32_t tmpreg_CNTRL2;
;;;804    
;;;805      /* Check the parameters */
;;;806      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;807      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;808      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;809    
;;;810      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
00021e  f1000760          ADD      r7,r0,#0x60
000222  eb070581          ADD      r5,r7,r1,LSL #2
;;;811    
;;;812      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
000226  682a              LDR      r2,[r5,#0]
;;;813      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
000228  f0220208          BIC      r2,r2,#8
;;;814      tmpreg_CNTRL2 += UpdateMode;
00022c  441a              ADD      r2,r2,r3
;;;815      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
00022e  602a              STR      r2,[r5,#0]
;;;816    
;;;817      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000230  3710              ADDS     r7,r7,#0x10
000232  eb070681          ADD      r6,r7,r1,LSL #2
;;;818    
;;;819      *tmpreg_CCR1x = Compare;
000236  6034              STR      r4,[r6,#0]
;;;820    }
000238  bdf0              POP      {r4-r7,pc}
;;;821    
                          ENDP

                  TIMER_GetChnCapture PROC
;;;835    #elif defined (USE_MDR1986VE9x)
;;;836    uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
00023a  b510              PUSH     {r4,lr}
;;;837    #endif
;;;838    {
00023c  4602              MOV      r2,r0
;;;839      __IO uint32_t *tmpreg_CCRx;
;;;840      uint32_t tmpreg;
;;;841    
;;;842      /* Check the parameters */
;;;843      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;844      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;845    
;;;846      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
00023e  f1020010          ADD      r0,r2,#0x10
000242  eb000381          ADD      r3,r0,r1,LSL #2
;;;847      tmpreg = *tmpreg_CCRx;
000246  681c              LDR      r4,[r3,#0]
;;;848    
;;;849      return tmpreg;
000248  b2a0              UXTH     r0,r4
;;;850    }
00024a  bd10              POP      {r4,pc}
;;;851    
                          ENDP

                  TIMER_GetChnCapture1 PROC
;;;865    #elif defined (USE_MDR1986VE9x)
;;;866    uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
00024c  b510              PUSH     {r4,lr}
;;;867    #endif
;;;868    {
00024e  4602              MOV      r2,r0
;;;869      __IO uint32_t *tmpreg_CCR1x;
;;;870      uint32_t tmpreg;
;;;871    
;;;872      /* Check the parameters */
;;;873      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;874      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;875    
;;;876      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000250  f1020070          ADD      r0,r2,#0x70
000254  eb000381          ADD      r3,r0,r1,LSL #2
;;;877      tmpreg = *tmpreg_CCR1x;
000258  681c              LDR      r4,[r3,#0]
;;;878    
;;;879      return tmpreg;
00025a  b2a0              UXTH     r0,r4
;;;880    }
00025c  bd10              POP      {r4,pc}
;;;881    
                          ENDP

                  TIMER_ChnETR_Cmd PROC
;;;894      */
;;;895    void TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
00025e  b530              PUSH     {r4,r5,lr}
;;;896    {
000260  4603              MOV      r3,r0
;;;897      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;898      uint32_t tmpreg_CH_CNTRL;
;;;899    
;;;900      /* Check the parameters */
;;;901      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;902      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;903      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;904    
;;;905      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000262  f1030520          ADD      r5,r3,#0x20
000266  eb050481          ADD      r4,r5,r1,LSL #2
;;;906    
;;;907      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00026a  6820              LDR      r0,[r4,#0]
;;;908    
;;;909      /* Form new value */
;;;910      if (NewState != DISABLE)
00026c  b112              CBZ      r2,|L1.628|
;;;911      {
;;;912        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;913        tmpreg_CH_CNTRL |= TIMER_CH_CNTRL_OCCE;
00026e  f4407080          ORR      r0,r0,#0x100
000272  e001              B        |L1.632|
                  |L1.628|
;;;914      }
;;;915      else
;;;916      {
;;;917        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;918        tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCE;
000274  f4207080          BIC      r0,r0,#0x100
                  |L1.632|
;;;919      }
;;;920    
;;;921      /* Configure CNTRL register with new value */
;;;922      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000278  6020              STR      r0,[r4,#0]
;;;923    }
00027a  bd30              POP      {r4,r5,pc}
;;;924    
                          ENDP

                  TIMER_ChnETRResetConfig PROC
;;;939      */
;;;940    void TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
00027c  b530              PUSH     {r4,r5,lr}
;;;941    {
00027e  4603              MOV      r3,r0
;;;942      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;943      uint32_t tmpreg_CH_CNTRL;
;;;944    
;;;945      /* Check the parameters */
;;;946      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;947      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;948      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(NewState));
;;;949    
;;;950      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000280  f1030520          ADD      r5,r3,#0x20
000284  eb050481          ADD      r4,r5,r1,LSL #2
;;;951    
;;;952      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000288  6820              LDR      r0,[r4,#0]
;;;953      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_ETREN;
00028a  f4205000          BIC      r0,r0,#0x2000
;;;954      tmpreg_CH_CNTRL += NewState;
00028e  4410              ADD      r0,r0,r2
;;;955      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000290  6020              STR      r0,[r4,#0]
;;;956    }
000292  bd30              POP      {r4,r5,pc}
;;;957    
                          ENDP

                  TIMER_ChnBRKResetConfig PROC
;;;972      */
;;;973    void TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000294  b530              PUSH     {r4,r5,lr}
;;;974    {
000296  4603              MOV      r3,r0
;;;975      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;976      uint32_t tmpreg_CH_CNTRL;
;;;977    
;;;978      /* Check the parameters */
;;;979      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;980      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;981      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(NewState));
;;;982    
;;;983      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000298  f1030520          ADD      r5,r3,#0x20
00029c  eb050481          ADD      r4,r5,r1,LSL #2
;;;984    
;;;985      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002a0  6820              LDR      r0,[r4,#0]
;;;986      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_BRKEN;
0002a2  f4205080          BIC      r0,r0,#0x1000
;;;987      tmpreg_CH_CNTRL += NewState;
0002a6  4410              ADD      r0,r0,r2
;;;988      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002a8  6020              STR      r0,[r4,#0]
;;;989    }
0002aa  bd30              POP      {r4,r5,pc}
;;;990    
                          ENDP

                  TIMER_ChnREFFormatConfig PROC
;;;1003     */
;;;1004   void TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format)
0002ac  b530              PUSH     {r4,r5,lr}
;;;1005   {
0002ae  4603              MOV      r3,r0
;;;1006     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1007     uint32_t tmpreg_CH_CNTRL;
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1011     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1012     assert_param(IS_TIMER_CHANNEL_REF_FORMAT(Format));
;;;1013   
;;;1014     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002b0  f1030520          ADD      r5,r3,#0x20
0002b4  eb050481          ADD      r4,r5,r1,LSL #2
;;;1015   
;;;1016     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002b8  6820              LDR      r0,[r4,#0]
;;;1017     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCM_Msk;
0002ba  f4206060          BIC      r0,r0,#0xe00
;;;1018     tmpreg_CH_CNTRL += Format;
0002be  4410              ADD      r0,r0,r2
;;;1019     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002c0  6020              STR      r0,[r4,#0]
;;;1020   }
0002c2  bd30              POP      {r4,r5,pc}
;;;1021   
                          ENDP

                  TIMER_ChnCapturePrescalerConfig PROC
;;;1038     */
;;;1039   void TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler)
0002c4  b530              PUSH     {r4,r5,lr}
;;;1040   {
0002c6  4603              MOV      r3,r0
;;;1041     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1042     uint32_t tmpreg_CH_CNTRL;
;;;1043   
;;;1044     /* Check the parameters */
;;;1045     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1046     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1047     assert_param(IS_TIMER_CHANNEL_PRESCALER(Prescaler));
;;;1048   
;;;1049     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002c8  f1030520          ADD      r5,r3,#0x20
0002cc  eb050481          ADD      r4,r5,r1,LSL #2
;;;1050   
;;;1051     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002d0  6820              LDR      r0,[r4,#0]
;;;1052     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHPSC_Msk;
0002d2  f02000c0          BIC      r0,r0,#0xc0
;;;1053     tmpreg_CH_CNTRL += Prescaler << TIMER_CH_CNTRL_CHPSC_Pos;
0002d6  eb001082          ADD      r0,r0,r2,LSL #6
;;;1054     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002da  6020              STR      r0,[r4,#0]
;;;1055   }
0002dc  bd30              POP      {r4,r5,pc}
;;;1056   
                          ENDP

                  TIMER_ChnEventSourceConfig PROC
;;;1073     */
;;;1074   void TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
0002de  b530              PUSH     {r4,r5,lr}
;;;1075   {
0002e0  4603              MOV      r3,r0
;;;1076     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1077     uint32_t tmpreg_CH_CNTRL;
;;;1078   
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1081     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1082     assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(EventSource));
;;;1083   
;;;1084     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002e2  f1030520          ADD      r5,r3,#0x20
0002e6  eb050481          ADD      r4,r5,r1,LSL #2
;;;1085   
;;;1086     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002ea  6820              LDR      r0,[r4,#0]
;;;1087     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHSEL_Msk;
0002ec  f0200030          BIC      r0,r0,#0x30
;;;1088     tmpreg_CH_CNTRL += EventSource;
0002f0  4410              ADD      r0,r0,r2
;;;1089     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002f2  6020              STR      r0,[r4,#0]
;;;1090   }
0002f4  bd30              POP      {r4,r5,pc}
;;;1091   
                          ENDP

                  TIMER_ChnFilterConfig PROC
;;;1120     */
;;;1121   void TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter)
0002f6  b530              PUSH     {r4,r5,lr}
;;;1122   {
0002f8  4603              MOV      r3,r0
;;;1123     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1124     uint32_t tmpreg_CH_CNTRL;
;;;1125   
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1128     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1129     assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;1130   
;;;1131     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002fa  f1030520          ADD      r5,r3,#0x20
0002fe  eb050481          ADD      r4,r5,r1,LSL #2
;;;1132   
;;;1133     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000302  6820              LDR      r0,[r4,#0]
;;;1134     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHFLTR_Msk;
000304  f020000f          BIC      r0,r0,#0xf
;;;1135     tmpreg_CH_CNTRL += Filter << TIMER_CH_CNTRL_CHFLTR_Pos;
000308  4410              ADD      r0,r0,r2
;;;1136     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00030a  6020              STR      r0,[r4,#0]
;;;1137   }
00030c  bd30              POP      {r4,r5,pc}
;;;1138   
                          ENDP

                  TIMER_GetChnWriteComplete PROC
;;;1149     */
;;;1150   FlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
00030e  b510              PUSH     {r4,lr}
;;;1151   {
000310  4602              MOV      r2,r0
;;;1152     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1153     FlagStatus bitstatus;
;;;1154   
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1157     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1158   
;;;1159     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000312  f1020420          ADD      r4,r2,#0x20
000316  eb040381          ADD      r3,r4,r1,LSL #2
;;;1160   
;;;1161     if ((*tmpreg_CH_CNTRLx & TIMER_CH_CNTRL_WR_CMPL) == 0)
00031a  681c              LDR      r4,[r3,#0]
00031c  f4144f80          TST      r4,#0x4000
000320  d101              BNE      |L1.806|
;;;1162     {
;;;1163       bitstatus = RESET;
000322  2000              MOVS     r0,#0
000324  e000              B        |L1.808|
                  |L1.806|
;;;1164     }
;;;1165     else
;;;1166     {
;;;1167       bitstatus = SET;
000326  2001              MOVS     r0,#1
                  |L1.808|
;;;1168     }
;;;1169   
;;;1170     return bitstatus;
;;;1171   }
000328  bd10              POP      {r4,pc}
;;;1172   
                          ENDP

                  TIMER_ChnCCR1_EventSourceConfig PROC
;;;1189     */
;;;1190   void TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
00032a  b530              PUSH     {r4,r5,lr}
;;;1191   {
00032c  4603              MOV      r3,r0
;;;1192     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1193     uint32_t tmpreg_CH_CNTRL2;
;;;1194   
;;;1195     /* Check the parameters */
;;;1196     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1197     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1198     assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(EventSource));
;;;1199   
;;;1200     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
00032e  f1030560          ADD      r5,r3,#0x60
000332  eb050481          ADD      r4,r5,r1,LSL #2
;;;1201   
;;;1202     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
000336  6820              LDR      r0,[r4,#0]
;;;1203     tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CHSEL1_Msk;
000338  f0200003          BIC      r0,r0,#3
;;;1204     tmpreg_CH_CNTRL2 += EventSource;
00033c  4410              ADD      r0,r0,r2
;;;1205     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
00033e  6020              STR      r0,[r4,#0]
;;;1206   }
000340  bd30              POP      {r4,r5,pc}
;;;1207   
                          ENDP

                  TIMER_ChnCCR1_Cmd PROC
;;;1220     */
;;;1221   void TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000342  b530              PUSH     {r4,r5,lr}
;;;1222   {
000344  4603              MOV      r3,r0
;;;1223     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1224     uint32_t tmpreg_CH_CNTRL2;
;;;1225   
;;;1226     /* Check the parameters */
;;;1227     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1228     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1229     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1230   
;;;1231     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000346  f1030560          ADD      r5,r3,#0x60
00034a  eb050481          ADD      r4,r5,r1,LSL #2
;;;1232   
;;;1233     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
00034e  6820              LDR      r0,[r4,#0]
;;;1234   
;;;1235     /* Form new value */
;;;1236     if (NewState != DISABLE)
000350  b112              CBZ      r2,|L1.856|
;;;1237     {
;;;1238       /* Enable TIMERx by setting the CCR1_EN bit in the CNTRL2 register */
;;;1239       tmpreg_CH_CNTRL2 |= TIMER_CH_CNTRL2_CCR1_EN;
000352  f0400004          ORR      r0,r0,#4
000356  e001              B        |L1.860|
                  |L1.856|
;;;1240     }
;;;1241     else
;;;1242     {
;;;1243       /* Disable TIMERx by resetting the CCR1_EN bit in the CNTRL2 register */
;;;1244       tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CCR1_EN;
000358  f0200004          BIC      r0,r0,#4
                  |L1.860|
;;;1245     }
;;;1246   
;;;1247     /* Configure CNTRL register with new value */
;;;1248     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
00035c  6020              STR      r0,[r4,#0]
;;;1249   }
00035e  bd30              POP      {r4,r5,pc}
;;;1250   
                          ENDP

                  TIMER_ChnOutInit PROC
;;;1259     */
;;;1260   void TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
000360  b570              PUSH     {r4-r6,lr}
;;;1261   {
;;;1262     uint32_t tmpreg_CH_Number;
;;;1263     uint32_t tmpreg_CH_CNTRL1;
;;;1264     uint32_t tmpreg_CH_DTG;
;;;1265   
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1268     assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnOutInitStruct->TIMER_CH_Number));
;;;1269     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity));
;;;1270     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source));
;;;1271     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode));
;;;1272     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity));
;;;1273     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source));
;;;1274     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode));
;;;1275     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler));
;;;1276     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler));
;;;1277     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource));
;;;1278   
;;;1279     tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << TIMER_CH_CNTRL1_INV_Pos)
000362  884d              LDRH     r5,[r1,#2]
000364  012d              LSLS     r5,r5,#4
000366  888e              LDRH     r6,[r1,#4]
000368  eb050586          ADD      r5,r5,r6,LSL #2
00036c  88ce              LDRH     r6,[r1,#6]
00036e  4435              ADD      r5,r5,r6
000370  890e              LDRH     r6,[r1,#8]
000372  eb053506          ADD      r5,r5,r6,LSL #12
000376  894e              LDRH     r6,[r1,#0xa]
000378  eb052586          ADD      r5,r5,r6,LSL #10
00037c  898e              LDRH     r6,[r1,#0xc]
00037e  eb052306          ADD      r3,r5,r6,LSL #8
;;;1280                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << TIMER_CH_CNTRL1_SELO_Pos)
;;;1281                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << TIMER_CH_CNTRL1_SELOE_Pos)
;;;1282                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << TIMER_CH_CNTRL1_NINV_Pos)
;;;1283                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1284                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1285   
;;;1286     tmpreg_CH_Number = TIMER_ChnOutInitStruct->TIMER_CH_Number;
000382  880a              LDRH     r2,[r1,#0]
;;;1287   
;;;1288     *(&TIMERx->CH1_CNTRL1 + tmpreg_CH_Number) = tmpreg_CH_CNTRL1;
000384  f1000530          ADD      r5,r0,#0x30
000388  f8453022          STR      r3,[r5,r2,LSL #2]
;;;1289   
;;;1290     tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << TIMER_CH_DTG_Pos)
00038c  8a0d              LDRH     r5,[r1,#0x10]
00038e  89ce              LDRH     r6,[r1,#0xe]
000390  eb052506          ADD      r5,r5,r6,LSL #8
000394  8a4e              LDRH     r6,[r1,#0x12]
000396  19ac              ADDS     r4,r5,r6
;;;1291                   + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1292                   + TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource;
;;;1293   
;;;1294     *(&TIMERx->CH1_DTG + tmpreg_CH_Number) = tmpreg_CH_DTG;
000398  f1000540          ADD      r5,r0,#0x40
00039c  f8454022          STR      r4,[r5,r2,LSL #2]
;;;1295   }
0003a0  bd70              POP      {r4-r6,pc}
;;;1296   
                          ENDP

                  TIMER_ChnOutStructInit PROC
;;;1302     */
;;;1303   void TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
0003a2  2100              MOVS     r1,#0
;;;1304   {
;;;1305     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0003a4  8041              STRH     r1,[r0,#2]
;;;1306     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = TIMER_CH_OutSrc_Only_0;
0003a6  8081              STRH     r1,[r0,#4]
;;;1307     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = TIMER_CH_OutMode_Input;
0003a8  80c1              STRH     r1,[r0,#6]
;;;1308     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0003aa  8101              STRH     r1,[r0,#8]
;;;1309     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = TIMER_CH_OutSrc_Only_0;
0003ac  8141              STRH     r1,[r0,#0xa]
;;;1310     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = TIMER_CH_OutMode_Input;
0003ae  8181              STRH     r1,[r0,#0xc]
;;;1311     TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler = 0;
0003b0  81c1              STRH     r1,[r0,#0xe]
;;;1312     TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  = 0;
0003b2  8201              STRH     r1,[r0,#0x10]
;;;1313     TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = TIMER_CH_DTG_ClkSrc_TIMER_CLK;
0003b4  8241              STRH     r1,[r0,#0x12]
;;;1314   }
0003b6  4770              BX       lr
;;;1315   
                          ENDP

                  TIMER_ChnOutConfig PROC
;;;1342     */
;;;1343   void TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
0003b8  b5f0              PUSH     {r4-r7,lr}
;;;1344   {
0003ba  4604              MOV      r4,r0
0003bc  9e05              LDR      r6,[sp,#0x14]
;;;1345     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1346     uint32_t tmpreg_CH_CNTRL1;
;;;1347   
;;;1348     /* Check the parameters */
;;;1349     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1350     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1351     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1352     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1353     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1354   
;;;1355     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
0003be  f1040730          ADD      r7,r4,#0x30
0003c2  eb070581          ADD      r5,r7,r1,LSL #2
;;;1356   
;;;1357     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
0003c6  6828              LDR      r0,[r5,#0]
;;;1358     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_INV + TIMER_CH_CNTRL1_SELO_Msk + TIMER_CH_CNTRL1_SELOE_Msk);
0003c8  f020001f          BIC      r0,r0,#0x1f
;;;1359     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_INV_Pos)
0003cc  0137              LSLS     r7,r6,#4
0003ce  eb070782          ADD      r7,r7,r2,LSL #2
0003d2  441f              ADD      r7,r7,r3
0003d4  4438              ADD      r0,r0,r7
;;;1360                       + (OutSource << TIMER_CH_CNTRL1_SELO_Pos)
;;;1361                       + (Mode      << TIMER_CH_CNTRL1_SELOE_Pos);
;;;1362     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
0003d6  6028              STR      r0,[r5,#0]
;;;1363   }
0003d8  bdf0              POP      {r4-r7,pc}
;;;1364   
                          ENDP

                  TIMER_ChnOutSourceConfig PROC
;;;1381     */
;;;1382   void TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
0003da  b530              PUSH     {r4,r5,lr}
;;;1383   {
0003dc  4603              MOV      r3,r0
;;;1384     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1385     uint32_t tmpreg_CH_CNTRL1;
;;;1386   
;;;1387     /* Check the parameters */
;;;1388     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1389     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1390     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1391   
;;;1392     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
0003de  f1030530          ADD      r5,r3,#0x30
0003e2  eb050481          ADD      r4,r5,r1,LSL #2
;;;1393   
;;;1394     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
0003e6  6820              LDR      r0,[r4,#0]
;;;1395     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELO_Msk;
0003e8  f020000c          BIC      r0,r0,#0xc
;;;1396     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_SELO_Pos;
0003ec  eb000082          ADD      r0,r0,r2,LSL #2
;;;1397     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
0003f0  6020              STR      r0,[r4,#0]
;;;1398   }
0003f2  bd30              POP      {r4,r5,pc}
;;;1399   
                          ENDP

                  TIMER_ChnOutModeConfig PROC
;;;1416     */
;;;1417   void TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
0003f4  b530              PUSH     {r4,r5,lr}
;;;1418   {
0003f6  4603              MOV      r3,r0
;;;1419     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1420     uint32_t tmpreg_CH_CNTRL1;
;;;1421   
;;;1422     /* Check the parameters */
;;;1423     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1424     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1425     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1426   
;;;1427     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
0003f8  f1030530          ADD      r5,r3,#0x30
0003fc  eb050481          ADD      r4,r5,r1,LSL #2
;;;1428   
;;;1429     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000400  6820              LDR      r0,[r4,#0]
;;;1430     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELOE_Msk;
000402  f0200003          BIC      r0,r0,#3
;;;1431     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_SELOE_Pos;
000406  4410              ADD      r0,r0,r2
;;;1432     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000408  6020              STR      r0,[r4,#0]
;;;1433   }
00040a  bd30              POP      {r4,r5,pc}
;;;1434   
                          ENDP

                  TIMER_ChnOutPolarityConfig PROC
;;;1449     */
;;;1450   void TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
00040c  b530              PUSH     {r4,r5,lr}
;;;1451   {
00040e  4603              MOV      r3,r0
;;;1452     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1453     uint32_t tmpreg_CH_CNTRL1;
;;;1454   
;;;1455     /* Check the parameters */
;;;1456     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1457     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1458     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1459   
;;;1460     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000410  f1030530          ADD      r5,r3,#0x30
000414  eb050481          ADD      r4,r5,r1,LSL #2
;;;1461   
;;;1462     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000418  6820              LDR      r0,[r4,#0]
;;;1463     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_INV;
00041a  f0200010          BIC      r0,r0,#0x10
;;;1464     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_INV_Pos;
00041e  eb001002          ADD      r0,r0,r2,LSL #4
;;;1465     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000422  6020              STR      r0,[r4,#0]
;;;1466   }
000424  bd30              POP      {r4,r5,pc}
;;;1467   
                          ENDP

                  TIMER_ChnNOutConfig PROC
;;;1494     */
;;;1495   void TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000426  b5f0              PUSH     {r4-r7,lr}
;;;1496   {
000428  4604              MOV      r4,r0
00042a  9e05              LDR      r6,[sp,#0x14]
;;;1497     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1498     uint32_t tmpreg_CH_CNTRL1;
;;;1499   
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1502     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1503     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1504     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1505     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1506   
;;;1507     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
00042c  f1040730          ADD      r7,r4,#0x30
000430  eb070581          ADD      r5,r7,r1,LSL #2
;;;1508   
;;;1509     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000434  6828              LDR      r0,[r5,#0]
;;;1510     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_NINV + TIMER_CH_CNTRL1_NSELO_Msk + TIMER_CH_CNTRL1_NSELOE_Msk);
000436  f42050f8          BIC      r0,r0,#0x1f00
;;;1511     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_NINV_Pos)
00043a  0337              LSLS     r7,r6,#12
00043c  eb072782          ADD      r7,r7,r2,LSL #10
000440  eb072703          ADD      r7,r7,r3,LSL #8
000444  4438              ADD      r0,r0,r7
;;;1512                       + (OutSource << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1513                       + (Mode      << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1514     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000446  6028              STR      r0,[r5,#0]
;;;1515   }
000448  bdf0              POP      {r4-r7,pc}
;;;1516   
                          ENDP

                  TIMER_ChnNOutSourceConfig PROC
;;;1533     */
;;;1534   void TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
00044a  b530              PUSH     {r4,r5,lr}
;;;1535   {
00044c  4603              MOV      r3,r0
;;;1536     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1537     uint32_t tmpreg_CH_CNTRL1;
;;;1538   
;;;1539     /* Check the parameters */
;;;1540     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1541     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1542     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1543   
;;;1544     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
00044e  f1030530          ADD      r5,r3,#0x30
000452  eb050481          ADD      r4,r5,r1,LSL #2
;;;1545   
;;;1546     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000456  6820              LDR      r0,[r4,#0]
;;;1547     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELO_Msk;
000458  f4206040          BIC      r0,r0,#0xc00
;;;1548     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_NSELO_Pos;
00045c  eb002082          ADD      r0,r0,r2,LSL #10
;;;1549     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000460  6020              STR      r0,[r4,#0]
;;;1550   }
000462  bd30              POP      {r4,r5,pc}
;;;1551   
                          ENDP

                  TIMER_ChnNOutModeConfig PROC
;;;1568     */
;;;1569   void TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000464  b530              PUSH     {r4,r5,lr}
;;;1570   {
000466  4603              MOV      r3,r0
;;;1571     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1572     uint32_t tmpreg_CH_CNTRL1;
;;;1573   
;;;1574     /* Check the parameters */
;;;1575     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1576     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1577     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1578   
;;;1579     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000468  f1030530          ADD      r5,r3,#0x30
00046c  eb050481          ADD      r4,r5,r1,LSL #2
;;;1580   
;;;1581     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000470  6820              LDR      r0,[r4,#0]
;;;1582     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELOE_Msk;
000472  f4207040          BIC      r0,r0,#0x300
;;;1583     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_NSELOE_Pos;
000476  eb002002          ADD      r0,r0,r2,LSL #8
;;;1584     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00047a  6020              STR      r0,[r4,#0]
;;;1585   }
00047c  bd30              POP      {r4,r5,pc}
;;;1586   
                          ENDP

                  TIMER_ChnNOutPolarityConfig PROC
;;;1601     */
;;;1602   void TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
00047e  b530              PUSH     {r4,r5,lr}
;;;1603   {
000480  4603              MOV      r3,r0
;;;1604     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1605     uint32_t tmpreg_CH_CNTRL1;
;;;1606   
;;;1607     /* Check the parameters */
;;;1608     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1609     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1610     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1611   
;;;1612     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000482  f1030530          ADD      r5,r3,#0x30
000486  eb050481          ADD      r4,r5,r1,LSL #2
;;;1613   
;;;1614     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00048a  6820              LDR      r0,[r4,#0]
;;;1615     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NINV;
00048c  f4205080          BIC      r0,r0,#0x1000
;;;1616     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_NINV_Pos;
000490  eb003002          ADD      r0,r0,r2,LSL #12
;;;1617     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000494  6020              STR      r0,[r4,#0]
;;;1618   }
000496  bd30              POP      {r4,r5,pc}
;;;1619   
                          ENDP

                  TIMER_ChnOutDTGConfig PROC
;;;1638     */
;;;1639   void TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
000498  b570              PUSH     {r4-r6,lr}
;;;1640                            uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource)
;;;1641   {
00049a  9c04              LDR      r4,[sp,#0x10]
;;;1642     uint32_t tmpreg_CH_DTG;
;;;1643   
;;;1644     /* Check the parameters */
;;;1645     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1646     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1647     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(MainPrescaler));
;;;1648     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(AuxPrescaler));
;;;1649     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(ClockSource));
;;;1650   
;;;1651     tmpreg_CH_DTG = (MainPrescaler << TIMER_CH_DTG_Pos)
00049c  eb032602          ADD      r6,r3,r2,LSL #8
0004a0  1935              ADDS     r5,r6,r4
;;;1652                   + (AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1653                   + ClockSource;
;;;1654   
;;;1655     *(&TIMERx->CH1_DTG + Channel) = tmpreg_CH_DTG;
0004a2  f1000640          ADD      r6,r0,#0x40
0004a6  f8465021          STR      r5,[r6,r1,LSL #2]
;;;1656   }
0004aa  bd70              POP      {r4-r6,pc}
;;;1657   
                          ENDP

                  TIMER_GetStatus PROC
;;;1662     */
;;;1663   uint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx)
0004ac  4601              MOV      r1,r0
;;;1664   {
;;;1665     /* Check the parameters */
;;;1666     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1667   
;;;1668     return (TIMERx->STATUS);
0004ae  6d48              LDR      r0,[r1,#0x54]
;;;1669   }
0004b0  4770              BX       lr
;;;1670   
                          ENDP

                  TIMER_GetFlagStatus PROC
;;;1694     */
;;;1695   FlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag)
0004b2  4602              MOV      r2,r0
;;;1696   {
;;;1697     FlagStatus bitstatus;
;;;1698   
;;;1699     /* Check the parameters */
;;;1700     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1701     assert_param(IS_TIMER_STATUS_FLAG(Flag));
;;;1702   
;;;1703     if ((TIMERx->STATUS & Flag) == 0)
0004b4  6d53              LDR      r3,[r2,#0x54]
0004b6  420b              TST      r3,r1
0004b8  d101              BNE      |L1.1214|
;;;1704     {
;;;1705       bitstatus = RESET;
0004ba  2000              MOVS     r0,#0
0004bc  e000              B        |L1.1216|
                  |L1.1214|
;;;1706     }
;;;1707     else
;;;1708     {
;;;1709       bitstatus = SET;
0004be  2001              MOVS     r0,#1
                  |L1.1216|
;;;1710     }
;;;1711   
;;;1712     return bitstatus;
;;;1713   }
0004c0  4770              BX       lr
;;;1714   
                          ENDP

                  TIMER_ClearFlag PROC
;;;1738     */
;;;1739   void TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags)
0004c2  6d42              LDR      r2,[r0,#0x54]
;;;1740   {
;;;1741     /* Check the parameters */
;;;1742     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1743     assert_param(IS_TIMER_STATUS(Flags));
;;;1744   
;;;1745     TIMERx->STATUS &= ~Flags;
0004c4  438a              BICS     r2,r2,r1
0004c6  6542              STR      r2,[r0,#0x54]
;;;1746   }
0004c8  4770              BX       lr
;;;1747   
                          ENDP

                  TIMER_DMACmd PROC
;;;1785   #if defined (USE_MDR1986VE9x)
;;;1786   void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState)
0004ca  b510              PUSH     {r4,lr}
;;;1787   #endif
;;;1788   {
0004cc  4613              MOV      r3,r2
;;;1789     uint32_t tmpreg_DMA_RE;
;;;1790   
;;;1791     /* Check the parameters */
;;;1792     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1793     assert_param(IS_TIMER_STATUS(TIMER_DMASource));
;;;1794     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1795   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1796     if(TIMER_DMAChannel == TIMER_DMA_Channel0){
;;;1797   #endif
;;;1798   	  tmpreg_DMA_RE = TIMERx->DMA_RE;
0004ce  6dc2              LDR      r2,[r0,#0x5c]
;;;1799   
;;;1800   	  /* Form new value */
;;;1801   	  if (NewState != DISABLE)
0004d0  b10b              CBZ      r3,|L1.1238|
;;;1802   	  {
;;;1803   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1804   		tmpreg_DMA_RE |= TIMER_DMASource;
0004d2  430a              ORRS     r2,r2,r1
0004d4  e000              B        |L1.1240|
                  |L1.1238|
;;;1805   	  }
;;;1806   	  else
;;;1807   	  {
;;;1808   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1809   		tmpreg_DMA_RE &= ~TIMER_DMASource;
0004d6  438a              BICS     r2,r2,r1
                  |L1.1240|
;;;1810   	  }
;;;1811   
;;;1812   	  /* Configure CNTRL register with new value */
;;;1813   	  TIMERx->DMA_RE = tmpreg_DMA_RE;
0004d8  65c2              STR      r2,[r0,#0x5c]
;;;1814   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1815     }
;;;1816     else{
;;;1817   	  tmpreg_DMA_RE = TIMERx->DMA_REChx[TIMER_DMAChannel];
;;;1818   
;;;1819   	  /* Form new value */
;;;1820   	  if (NewState != DISABLE)
;;;1821   	  {
;;;1822   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1823   		tmpreg_DMA_RE |= TIMER_DMASource;
;;;1824   	  }
;;;1825   	  else
;;;1826   	  {
;;;1827   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1828   		tmpreg_DMA_RE &= ~TIMER_DMASource;
;;;1829   	  }
;;;1830   
;;;1831   	  /* Configure CNTRL register with new value */
;;;1832   	  TIMERx->DMA_REChx[TIMER_DMAChannel] = tmpreg_DMA_RE;
;;;1833   
;;;1834     }
;;;1835   #endif
;;;1836   }
0004da  bd10              POP      {r4,pc}
;;;1837   
                          ENDP

                  TIMER_ITConfig PROC
;;;1863     */
;;;1864   void TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState)
0004dc  b510              PUSH     {r4,lr}
;;;1865   {
0004de  4613              MOV      r3,r2
;;;1866     uint32_t tmpreg_IE;
;;;1867   
;;;1868     /* Check the parameters */
;;;1869     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1870     assert_param(IS_TIMER_STATUS(TIMER_IT));
;;;1871     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1872   
;;;1873     tmpreg_IE = TIMERx->IE;
0004e0  6d82              LDR      r2,[r0,#0x58]
;;;1874   
;;;1875     /* Form new value */
;;;1876     if (NewState != DISABLE)
0004e2  b10b              CBZ      r3,|L1.1256|
;;;1877     {
;;;1878       /* Enable the TIMERx Interrupt requests by setting bits in the IE register */
;;;1879       tmpreg_IE |= TIMER_IT;
0004e4  430a              ORRS     r2,r2,r1
0004e6  e000              B        |L1.1258|
                  |L1.1256|
;;;1880     }
;;;1881     else
;;;1882     {
;;;1883       /* Disable the TIMERx Interrupt requests by clearing bits in the IE register */
;;;1884       tmpreg_IE &= ~TIMER_IT;
0004e8  438a              BICS     r2,r2,r1
                  |L1.1258|
;;;1885     }
;;;1886   
;;;1887     /* Configure CNTRL register with new value */
;;;1888     TIMERx->IE = tmpreg_IE;
0004ea  6582              STR      r2,[r0,#0x58]
;;;1889   }
0004ec  bd10              POP      {r4,pc}
;;;1890   
                          ENDP

                  TIMER_GetITStatus PROC
;;;1914     */
;;;1915   ITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT)
0004ee  b530              PUSH     {r4,r5,lr}
;;;1916   {
0004f0  4602              MOV      r2,r0
;;;1917     ITStatus bitstatus;
;;;1918     uint32_t tmpreg;
;;;1919   
;;;1920     /* Check the parameters */
;;;1921     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1922     assert_param(IS_TIMER_STATUS_FLAG(TIMER_IT));
;;;1923   
;;;1924     tmpreg = TIMERx->STATUS & TIMERx->IE & TIMER_IT;
0004f2  6d54              LDR      r4,[r2,#0x54]
0004f4  6d95              LDR      r5,[r2,#0x58]
0004f6  402c              ANDS     r4,r4,r5
0004f8  ea040301          AND      r3,r4,r1
;;;1925   
;;;1926     if (tmpreg == 0)
0004fc  b90b              CBNZ     r3,|L1.1282|
;;;1927     {
;;;1928       bitstatus = RESET;
0004fe  2000              MOVS     r0,#0
000500  e000              B        |L1.1284|
                  |L1.1282|
;;;1929     }
;;;1930     else
;;;1931     {
;;;1932       bitstatus = SET;
000502  2001              MOVS     r0,#1
                  |L1.1284|
;;;1933     }
;;;1934   
;;;1935     return bitstatus;
;;;1936   }
000504  bd30              POP      {r4,r5,pc}
;;;1937   
                          ENDP

                  TIMER_BRGInit PROC
;;;1953     */
;;;1954   void TIMER_BRGInit ( MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG ) {
000506  4602              MOV      r2,r0
;;;1955   	uint32_t tmpreg;
;;;1956   
;;;1957   	/* Check the parameters */
;;;1958   	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1959   	assert_param(IS_TIMER_CLOCK_BRG(TIMER_BRG));
;;;1960   
;;;1961   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1962   	if(TIMERx == MDR_TIMER4)
;;;1963   		tmpreg = MDR_RST_CLK->UART_CLOCK;
;;;1964   	else
;;;1965   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1966   		tmpreg = MDR_RST_CLK->TIM_CLOCK;
000508  4b10              LDR      r3,|L1.1356|
00050a  6a58              LDR      r0,[r3,#0x24]
;;;1967   
;;;1968   	if (TIMERx == MDR_TIMER1) {
00050c  4b10              LDR      r3,|L1.1360|
00050e  429a              CMP      r2,r3
000510  d105              BNE      |L1.1310|
;;;1969   		tmpreg &= ~RST_CLK_TIM_CLOCK_TIM1_BRG_Msk;
000512  f02000ff          BIC      r0,r0,#0xff
;;;1970   		tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM1_BRG_Pos;
000516  4308              ORRS     r0,r0,r1
;;;1971   		tmpreg |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN;
000518  f0407080          ORR      r0,r0,#0x1000000
00051c  e012              B        |L1.1348|
                  |L1.1310|
;;;1972   	}
;;;1973   	else
;;;1974   		if (TIMERx == MDR_TIMER2) {
00051e  4b0d              LDR      r3,|L1.1364|
000520  429a              CMP      r2,r3
000522  d106              BNE      |L1.1330|
;;;1975   			tmpreg &= ~RST_CLK_TIM_CLOCK_TIM2_BRG_Msk;
000524  f420407f          BIC      r0,r0,#0xff00
;;;1976   			tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM2_BRG_Pos;
000528  ea402001          ORR      r0,r0,r1,LSL #8
;;;1977   			tmpreg |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN;
00052c  f0407000          ORR      r0,r0,#0x2000000
000530  e008              B        |L1.1348|
                  |L1.1330|
;;;1978   		}
;;;1979   		else
;;;1980   			if (TIMERx == MDR_TIMER3) {
000532  4b09              LDR      r3,|L1.1368|
000534  429a              CMP      r2,r3
000536  d105              BNE      |L1.1348|
;;;1981   				tmpreg &= ~RST_CLK_TIM_CLOCK_TIM3_BRG_Msk;
000538  f420007f          BIC      r0,r0,#0xff0000
;;;1982   				tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM3_BRG_Pos;
00053c  ea404001          ORR      r0,r0,r1,LSL #16
;;;1983   				tmpreg |= RST_CLK_TIM_CLOCK_TIM3_CLK_EN;
000540  f0406080          ORR      r0,r0,#0x4000000
                  |L1.1348|
;;;1984   			}
;;;1985   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1986   			else
;;;1987   				if(TIMERx == MDR_TIMER4) {
;;;1988   					tmpreg &= ~RST_CLK_UART_CLOCK_TIM4_BRG_Msk;
;;;1989   					tmpreg |= TIMER_BRG << RST_CLK_UART_CLOCK_TIM4_BRG_Pos;
;;;1990   					tmpreg |= RST_CLK_UART_CLOCK_TIM4_CLK_EN;
;;;1991   				} // if(TIMERx == MDR_TIMER4) {
;;;1992   #endif // #if ( (defined (USE_MDR1986VE3) ) || (defined (MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1993   
;;;1994   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1995   	if(TIMERx == MDR_TIMER4)
;;;1996   		MDR_RST_CLK->UART_CLOCK = tmpreg;
;;;1997   	else
;;;1998   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1999   		MDR_RST_CLK->TIM_CLOCK = tmpreg;
000544  4b01              LDR      r3,|L1.1356|
000546  6258              STR      r0,[r3,#0x24]
;;;2000   
;;;2001   }
000548  4770              BX       lr
;;;2002   
                          ENDP

00054a  0000              DCW      0x0000
                  |L1.1356|
                          DCD      0x40020000
                  |L1.1360|
                          DCD      0x40070000
                  |L1.1364|
                          DCD      0x40078000
                  |L1.1368|
                          DCD      0x40080000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_timer.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___17_MDR32F9Qx_timer_c_566b03da____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH|
#line 144
|__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
