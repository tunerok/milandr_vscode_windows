; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_usb_device.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_usb_device.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_usb_device.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_device.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USB_EP_Init PROC
;;;164    
;;;165    USB_Result USB_EP_Init(USB_EP_TypeDef EPx, uint32_t USB_EP_Ctrl, USB_EP_Error_Handler onError)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;166    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;167      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
00000a  eb050045          ADD      r0,r5,r5,LSL #1
00000e  eb0000c5          ADD      r0,r0,r5,LSL #3
000012  49f7              LDR      r1,|L1.1008|
000014  eb010480          ADD      r4,r1,r0,LSL #2
;;;168    
;;;169      /* EndPoint context preparation */
;;;170      ep->Buffer.IO_Buffer.pBuffer    = 0;
000018  2000              MOVS     r0,#0
00001a  6060              STR      r0,[r4,#4]
;;;171      ep->Buffer.IO_Buffer.length     = 0;
00001c  2100              MOVS     r1,#0
00001e  60a1              STR      r1,[r4,#8]
;;;172      ep->Buffer.IO_Buffer.bytesToAck = 0;
000020  6121              STR      r1,[r4,#0x10]
;;;173      ep->Buffer.IO_Buffer.offset     = 0;
000022  60e1              STR      r1,[r4,#0xc]
;;;174      ep->Buffer.pSetupPacket         = 0;
000024  6161              STR      r1,[r4,#0x14]
;;;175      ep->InHandler                   = 0;
000026  61e0              STR      r0,[r4,#0x1c]
;;;176      ep->OutHandler                  = 0;
000028  6220              STR      r0,[r4,#0x20]
;;;177      ep->SetupHandler                = 0;
00002a  6260              STR      r0,[r4,#0x24]
;;;178      ep->ErrorHandler                = onError;
00002c  62a6              STR      r6,[r4,#0x28]
;;;179      ep->EP_Halt                     = USB_STALL_PROTO;
00002e  7060              STRB     r0,[r4,#1]
;;;180      ep->EP_State                    = USB_EP_NAK;
000030  7020              STRB     r0,[r4,#0]
;;;181      ep->EP_WasScdone                = RESET;
000032  7620              STRB     r0,[r4,#0x18]
;;;182    
;;;183      USB_SetSEPxCTRL(EPx, USB_EP_Ctrl);
000034  4639              MOV      r1,r7
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       USB_SetSEPxCTRL
;;;184    
;;;185      return USB_SUCCESS;
00003c  2000              MOVS     r0,#0
;;;186    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;187    
                          ENDP

                  USB_EP_Reset PROC
;;;197    
;;;198    USB_Result USB_EP_Reset(USB_EP_TypeDef EPx)
000042  b570              PUSH     {r4-r6,lr}
;;;199    {
000044  4605              MOV      r5,r0
;;;200      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
000046  eb050045          ADD      r0,r5,r5,LSL #1
00004a  eb0000c5          ADD      r0,r0,r5,LSL #3
00004e  49e8              LDR      r1,|L1.1008|
000050  eb010480          ADD      r4,r1,r0,LSL #2
;;;201    
;;;202      ep->EP_State = USB_EP_NAK;
000054  2000              MOVS     r0,#0
000056  7020              STRB     r0,[r4,#0]
;;;203      ep->EP_WasScdone = RESET;
000058  7620              STRB     r0,[r4,#0x18]
;;;204    
;;;205      USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPISOEN_Reset  |                           /* Reset Isohronic */
00005a  49e6              LDR      r1,|L1.1012|
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       USB_SetSEPxCTRL
;;;206                           USB_SEPx_CTRL_EPRDY_NotReady |                           /* Reset READY */
;;;207                           USB_SEPx_CTRL_EPEN_Enable);                              /* Set ENABLE */
;;;208    
;;;209      return USB_SUCCESS;
000062  2000              MOVS     r0,#0
;;;210    }
000064  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP

                  USB_EP_SetReady PROC
;;;734    
;;;735    static void USB_EP_SetReady(USB_EP_TypeDef EPx, uint32_t val)
000066  b570              PUSH     {r4-r6,lr}
;;;736    {
000068  4604              MOV      r4,r0
00006a  460d              MOV      r5,r1
;;;737      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
00006c  eb040044          ADD      r0,r4,r4,LSL #1
000070  eb0000c4          ADD      r0,r0,r4,LSL #3
000074  49de              LDR      r1,|L1.1008|
000076  eb010680          ADD      r6,r1,r0,LSL #2
;;;738    
;;;739      /* Clear pending bits */
;;;740      USB_SetSIS(USB_SIS_Msk);
00007a  201f              MOVS     r0,#0x1f
00007c  f7fffffe          BL       USB_SetSIS
;;;741    
;;;742      ep->EP_WasScdone = RESET;
000080  2000              MOVS     r0,#0
000082  7630              STRB     r0,[r6,#0x18]
;;;743    
;;;744      /* Set CTRL bits */
;;;745      USB_SetSEPxCTRL(EPx, val);
000084  4629              MOV      r1,r5
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       USB_SetSEPxCTRL
;;;746    }
00008c  bd70              POP      {r4-r6,pc}
;;;747    
                          ENDP

                  USB_EP_Idle PROC
;;;224    
;;;225    USB_Result USB_EP_Idle(USB_EP_TypeDef EPx)
00008e  b570              PUSH     {r4-r6,lr}
;;;226    {
000090  4606              MOV      r6,r0
;;;227      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
000092  eb060046          ADD      r0,r6,r6,LSL #1
000096  eb0000c6          ADD      r0,r0,r6,LSL #3
00009a  49d5              LDR      r1,|L1.1008|
00009c  eb010480          ADD      r4,r1,r0,LSL #2
;;;228      uint32_t val = USB_SEPx_CTRL_EPSSTALL_NotReply;                               /* Reset STALL reply */
0000a0  f44f2500          MOV      r5,#0x80000
;;;229    
;;;230      if (ep->EP_WaitOut || ep->EP_WaitSetup)
0000a4  7e60              LDRB     r0,[r4,#0x19]
0000a6  b908              CBNZ     r0,|L1.172|
0000a8  7ea0              LDRB     r0,[r4,#0x1a]
0000aa  b120              CBZ      r0,|L1.182|
                  |L1.172|
;;;231      {
;;;232        ep->EP_State = USB_EP_IDLE;
0000ac  2001              MOVS     r0,#1
0000ae  7020              STRB     r0,[r4,#0]
;;;233        val |= USB_SEPx_CTRL_EPRDY_Ready;                                           /* Set READY */
0000b0  f0450502          ORR      r5,r5,#2
0000b4  e001              B        |L1.186|
                  |L1.182|
;;;234      }
;;;235      else
;;;236      {
;;;237        ep->EP_State = USB_EP_NAK;
0000b6  2000              MOVS     r0,#0
0000b8  7020              STRB     r0,[r4,#0]
                  |L1.186|
;;;238      }
;;;239      ep->EP_Halt = USB_STALL_PROTO;
0000ba  2000              MOVS     r0,#0
0000bc  7060              STRB     r0,[r4,#1]
;;;240    
;;;241      USB_EP_SetReady(EPx, val);
0000be  4629              MOV      r1,r5
0000c0  4630              MOV      r0,r6
0000c2  f7fffffe          BL       USB_EP_SetReady
;;;242    
;;;243      return USB_SUCCESS;
0000c6  2000              MOVS     r0,#0
;;;244    }
0000c8  bd70              POP      {r4-r6,pc}
;;;245    
                          ENDP

                  USB_EP_Stall PROC
;;;262    
;;;263    USB_Result USB_EP_Stall(USB_EP_TypeDef EPx, USB_StallType bHalt)
0000ca  e92d41f0          PUSH     {r4-r8,lr}
;;;264    {
0000ce  4605              MOV      r5,r0
0000d0  460c              MOV      r4,r1
;;;265      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
0000d2  eb050045          ADD      r0,r5,r5,LSL #1
0000d6  eb0000c5          ADD      r0,r0,r5,LSL #3
0000da  49c5              LDR      r1,|L1.1008|
0000dc  eb010680          ADD      r6,r1,r0,LSL #2
;;;266      uint32_t val = 0;
0000e0  2700              MOVS     r7,#0
;;;267    
;;;268      if (bHalt == USB_STALL_HALT && EPx == USB_EP0)
0000e2  2c01              CMP      r4,#1
0000e4  d103              BNE      |L1.238|
0000e6  b915              CBNZ     r5,|L1.238|
;;;269      {
;;;270        /* No functional stall for Default Control Pipe */
;;;271        return USB_ERROR;
0000e8  2001              MOVS     r0,#1
                  |L1.234|
;;;272      }
;;;273    
;;;274      if (bHalt == USB_STALL_HALT || ep->EP_WaitSetup)
;;;275      {
;;;276        ep->EP_Halt  = bHalt;
;;;277        ep->EP_State = USB_EP_STALL;
;;;278        val = USB_SEPx_CTRL_EPSSTALL_Reply |                                          /* Set STALL reply */
;;;279              USB_SEPx_CTRL_EPRDY_Ready;                                              /* Set READY */
;;;280      }
;;;281    
;;;282      USB_EP_SetReady(EPx, val);
;;;283    
;;;284      return USB_SUCCESS;
;;;285    }
0000ea  e8bd81f0          POP      {r4-r8,pc}
                  |L1.238|
0000ee  2c01              CMP      r4,#1                 ;274
0000f0  d001              BEQ      |L1.246|
0000f2  7eb0              LDRB     r0,[r6,#0x1a]         ;274
0000f4  b118              CBZ      r0,|L1.254|
                  |L1.246|
0000f6  7074              STRB     r4,[r6,#1]            ;276
0000f8  2005              MOVS     r0,#5                 ;277
0000fa  7030              STRB     r0,[r6,#0]            ;277
0000fc  270a              MOVS     r7,#0xa               ;278
                  |L1.254|
0000fe  4639              MOV      r1,r7                 ;282
000100  4628              MOV      r0,r5                 ;282
000102  f7fffffe          BL       USB_EP_SetReady
000106  2000              MOVS     r0,#0                 ;284
000108  e7ef              B        |L1.234|
;;;286    
                          ENDP

                  USB_EP_sendInDataPortion PROC
;;;682    
;;;683    static void USB_EP_sendInDataPortion(USB_EP_TypeDef EPx, USB_EPData_Bit_TypeDef DataBitChange)
00010a  e92d41f0          PUSH     {r4-r8,lr}
;;;684    {
00010e  4606              MOV      r6,r0
000110  460f              MOV      r7,r1
;;;685      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
000112  eb060046          ADD      r0,r6,r6,LSL #1
000116  eb0000c6          ADD      r0,r0,r6,LSL #3
00011a  49b5              LDR      r1,|L1.1008|
00011c  eb010480          ADD      r4,r1,r0,LSL #2
;;;686      uint32_t i, total;
;;;687    
;;;688      assert_param(ep->EP_State == USB_EP_IN);
;;;689    
;;;690      /* Clean TX FIFO buffer */
;;;691      TX_FIFO_FORCE_EMPTY(EPx);
000120  2101              MOVS     r1,#1
000122  4630              MOV      r0,r6
000124  f7fffffe          BL       USB_SetSEPxTXFDC
;;;692    
;;;693      /* Adjust DATA bit */
;;;694      switch (DataBitChange)
000128  b127              CBZ      r7,|L1.308|
00012a  2f01              CMP      r7,#1
00012c  d003              BEQ      |L1.310|
00012e  2f02              CMP      r7,#2
000130  d10a              BNE      |L1.328|
000132  e004              B        |L1.318|
                  |L1.308|
;;;695      {
;;;696        case USB_DATA_BIT_KEEP:
;;;697          break;
000134  e008              B        |L1.328|
                  |L1.310|
;;;698        case USB_DATA_BIT_TOGGLE:
;;;699          USB_SEPxToggleEPDATASEQ(EPx);
000136  4630              MOV      r0,r6
000138  f7fffffe          BL       USB_SEPxToggleEPDATASEQ
;;;700          break;
00013c  e004              B        |L1.328|
                  |L1.318|
;;;701        case USB_DATA_BIT_DATA1:
;;;702          USB_SetSEPxCTRL(EPx, USB_SEPx_CTRL_EPDATASEQ_Data1);
00013e  2104              MOVS     r1,#4
000140  4630              MOV      r0,r6
000142  f7fffffe          BL       USB_SetSEPxCTRL
;;;703          break;
000146  bf00              NOP      
                  |L1.328|
000148  bf00              NOP                            ;697
;;;704      }
;;;705    
;;;706      /* Copy data portion into TX FIFO buffer */
;;;707      total = (ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck < ep->Buffer.IO_Buffer.length ?
00014a  e9d41003          LDRD     r1,r0,[r4,#0xc]
00014e  4401              ADD      r1,r1,r0
000150  68a0              LDR      r0,[r4,#8]
000152  4281              CMP      r1,r0
000154  d203              BCS      |L1.350|
;;;708                ep->Buffer.IO_Buffer.offset + ep->Buffer.IO_Buffer.bytesToAck : ep->Buffer.IO_Buffer.length);
000156  e9d41003          LDRD     r1,r0,[r4,#0xc]
00015a  4408              ADD      r0,r0,r1
00015c  e000              B        |L1.352|
                  |L1.350|
00015e  68a0              LDR      r0,[r4,#8]
                  |L1.352|
000160  4680              MOV      r8,r0
;;;709      for (i = ep->Buffer.IO_Buffer.offset; i < total; i++)
000162  68e5              LDR      r5,[r4,#0xc]
000164  e005              B        |L1.370|
                  |L1.358|
;;;710      {
;;;711        USB_SetSEPxTXFD(EPx, ep->Buffer.IO_Buffer.pBuffer[i]);
000166  6860              LDR      r0,[r4,#4]
000168  5d41              LDRB     r1,[r0,r5]
00016a  4630              MOV      r0,r6
00016c  f7fffffe          BL       USB_SetSEPxTXFD
000170  1c6d              ADDS     r5,r5,#1              ;709
                  |L1.370|
000172  4545              CMP      r5,r8                 ;709
000174  d3f7              BCC      |L1.358|
;;;712      };
;;;713    
;;;714      /* Set EPRDY bit */
;;;715      USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
000176  2102              MOVS     r1,#2
000178  4630              MOV      r0,r6
00017a  f7fffffe          BL       USB_EP_SetReady
;;;716    }
00017e  e8bd81f0          POP      {r4-r8,pc}
;;;717    
                          ENDP

                  USB_EP_doDataIn PROC
;;;304    
;;;305    USB_Result USB_EP_doDataIn(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onInDone)
000182  e92d47f0          PUSH     {r4-r10,lr}
;;;306    {
000186  4605              MOV      r5,r0
000188  460e              MOV      r6,r1
00018a  4617              MOV      r7,r2
00018c  4698              MOV      r8,r3
;;;307      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
00018e  eb050045          ADD      r0,r5,r5,LSL #1
000192  eb0000c5          ADD      r0,r0,r5,LSL #3
000196  4996              LDR      r1,|L1.1008|
000198  eb010480          ADD      r4,r1,r0,LSL #2
;;;308      /* Setup IN Data stage starts with DATA1 */
;;;309      USB_EPData_Bit_TypeDef StartInStage = (ep->EP_WaitSetup ? USB_DATA_BIT_DATA1 : USB_DATA_BIT_TOGGLE);
00019c  7ea0              LDRB     r0,[r4,#0x1a]
00019e  b108              CBZ      r0,|L1.420|
0001a0  2002              MOVS     r0,#2
0001a2  e000              B        |L1.422|
                  |L1.420|
0001a4  2001              MOVS     r0,#1
                  |L1.422|
0001a6  4681              MOV      r9,r0
;;;310    
;;;311      /* Set EndPoint context */
;;;312      ep->Buffer.IO_Buffer.pBuffer    = Buffer;
0001a8  6066              STR      r6,[r4,#4]
;;;313      ep->Buffer.IO_Buffer.length     = Length;
0001aa  60a7              STR      r7,[r4,#8]
;;;314      ep->Buffer.IO_Buffer.bytesToAck = MAX_PACKET_SIZE;
0001ac  2120              MOVS     r1,#0x20
0001ae  6121              STR      r1,[r4,#0x10]
;;;315      ep->Buffer.IO_Buffer.offset     = 0;
0001b0  2100              MOVS     r1,#0
0001b2  60e1              STR      r1,[r4,#0xc]
;;;316      ep->InHandler                   = onInDone;
0001b4  f8c4801c          STR      r8,[r4,#0x1c]
;;;317      ep->EP_State                    = USB_EP_IN;
0001b8  2002              MOVS     r0,#2
0001ba  7020              STRB     r0,[r4,#0]
;;;318    
;;;319      /* Send first data portion */
;;;320      USB_EP_sendInDataPortion(EPx, StartInStage);
0001bc  4649              MOV      r1,r9
0001be  4628              MOV      r0,r5
0001c0  f7fffffe          BL       USB_EP_sendInDataPortion
;;;321    
;;;322      return USB_SUCCESS;
0001c4  2000              MOVS     r0,#0
;;;323    }
0001c6  e8bd87f0          POP      {r4-r10,pc}
;;;324    
                          ENDP

                  USB_EP_doDataOut PROC
;;;345    
;;;346    USB_Result USB_EP_doDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length, USB_EP_IO_Handler onOutDone)
0001ca  e92d41f0          PUSH     {r4-r8,lr}
;;;347    {
0001ce  4605              MOV      r5,r0
0001d0  460e              MOV      r6,r1
0001d2  4617              MOV      r7,r2
0001d4  4698              MOV      r8,r3
;;;348      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
0001d6  eb050045          ADD      r0,r5,r5,LSL #1
0001da  eb0000c5          ADD      r0,r0,r5,LSL #3
0001de  4984              LDR      r1,|L1.1008|
0001e0  eb010480          ADD      r4,r1,r0,LSL #2
;;;349    
;;;350      /* Set EndPoint context */
;;;351      ep->Buffer.IO_Buffer.pBuffer    = Buffer;
0001e4  6066              STR      r6,[r4,#4]
;;;352      ep->Buffer.IO_Buffer.length     = Length;
0001e6  60a7              STR      r7,[r4,#8]
;;;353      ep->Buffer.IO_Buffer.bytesToAck = 0;
0001e8  2100              MOVS     r1,#0
0001ea  6121              STR      r1,[r4,#0x10]
;;;354      ep->Buffer.IO_Buffer.offset     = 0;
0001ec  60e1              STR      r1,[r4,#0xc]
;;;355      ep->OutHandler                  = onOutDone;
0001ee  f8c48020          STR      r8,[r4,#0x20]
;;;356      ep->EP_WaitOut                  = SET;
0001f2  2001              MOVS     r0,#1
0001f4  7660              STRB     r0,[r4,#0x19]
;;;357    
;;;358      /* Start awaiting for OUT transaction */
;;;359      USB_EP_Idle(EPx);
0001f6  4628              MOV      r0,r5
0001f8  f7fffffe          BL       USB_EP_Idle
;;;360    
;;;361      return USB_SUCCESS;
0001fc  2000              MOVS     r0,#0
;;;362    }
0001fe  e8bd81f0          POP      {r4-r8,pc}
;;;363    
                          ENDP

                  USB_EP_setSetupHandler PROC
;;;380    
;;;381    USB_Result USB_EP_setSetupHandler(USB_EP_TypeDef EPx, USB_SetupPacket_TypeDef* USB_SetupPacket, USB_EP_Setup_Handler onSetupPacket)
000202  e92d41f0          PUSH     {r4-r8,lr}
;;;382    {
000206  4606              MOV      r6,r0
000208  460f              MOV      r7,r1
00020a  4615              MOV      r5,r2
;;;383      USB_EPContext_TypeDef *ep = USB_EPContext + EPx;
00020c  eb060046          ADD      r0,r6,r6,LSL #1
000210  eb0000c6          ADD      r0,r0,r6,LSL #3
000214  4976              LDR      r1,|L1.1008|
000216  eb010480          ADD      r4,r1,r0,LSL #2
;;;384    
;;;385      /* Set EndPoint context */
;;;386      ep->Buffer.pSetupPacket         = USB_SetupPacket;
00021a  6167              STR      r7,[r4,#0x14]
;;;387      ep->Buffer.IO_Buffer.length     = 0;
00021c  2100              MOVS     r1,#0
00021e  60a1              STR      r1,[r4,#8]
;;;388      ep->Buffer.IO_Buffer.bytesToAck = 0;
000220  6121              STR      r1,[r4,#0x10]
;;;389      ep->Buffer.IO_Buffer.offset     = 0;
000222  60e1              STR      r1,[r4,#0xc]
;;;390      ep->SetupHandler                = onSetupPacket;
000224  6265              STR      r5,[r4,#0x24]
;;;391      ep->EP_WaitSetup                = onSetupPacket ? SET : RESET;
000226  b10d              CBZ      r5,|L1.556|
000228  2001              MOVS     r0,#1
00022a  e000              B        |L1.558|
                  |L1.556|
00022c  2000              MOVS     r0,#0
                  |L1.558|
00022e  76a0              STRB     r0,[r4,#0x1a]
;;;392    
;;;393      /* Start awaiting for SETUP transaction */
;;;394      USB_EP_Idle(EPx);
000230  4630              MOV      r0,r6
000232  f7fffffe          BL       USB_EP_Idle
;;;395    
;;;396      return USB_SUCCESS;
000236  2000              MOVS     r0,#0
;;;397    }
000238  e8bd81f0          POP      {r4-r8,pc}
;;;398    
                          ENDP

                  USB_EP_dispatchEvent PROC
;;;413    
;;;414    USB_Result USB_EP_dispatchEvent(USB_EP_TypeDef EPx, uint32_t USB_IT)
00023c  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;415    {
000240  b081              SUB      sp,sp,#4
000242  4683              MOV      r11,r0
;;;416      FlagStatus nextIteration = RESET;
000244  2000              MOVS     r0,#0
000246  9000              STR      r0,[sp,#0]
;;;417      USB_Result result = USB_SUCCESS;
000248  2600              MOVS     r6,#0
;;;418      uint32_t tmpSTS, tmpTS, tmpCTRL;
;;;419      uint32_t i, count;
;;;420      USB_EPContext_TypeDef *ep;
;;;421    
;;;422      tmpSTS = USB_GetSEPxSTS(EPx);
00024a  4658              MOV      r0,r11
00024c  f7fffffe          BL       USB_GetSEPxSTS
000250  4682              MOV      r10,r0
;;;423      tmpTS  = (USB_GetSEPxTS(EPx) & USB_SEPx_TS_SCTTYPE_Msk);
000252  4658              MOV      r0,r11
000254  f7fffffe          BL       USB_GetSEPxTS
000258  f0000803          AND      r8,r0,#3
;;;424      tmpCTRL = USB_GetSEPxCTRL(EPx);
00025c  4658              MOV      r0,r11
00025e  f7fffffe          BL       USB_GetSEPxCTRL
000262  4607              MOV      r7,r0
;;;425    
;;;426      ep = USB_EPContext + EPx;
000264  eb0b004b          ADD      r0,r11,r11,LSL #1
000268  eb0000cb          ADD      r0,r0,r11,LSL #3
00026c  4960              LDR      r1,|L1.1008|
00026e  eb010480          ADD      r4,r1,r0,LSL #2
;;;427    
;;;428      /* Remember SCDONE event in the EndPoint context */
;;;429      if (USB_IT & USB_SIS_SCTDONE)
000272  9802              LDR      r0,[sp,#8]
000274  f0100f01          TST      r0,#1
000278  d001              BEQ      |L1.638|
;;;430      {
;;;431        ep->EP_WasScdone = SET;
00027a  2001              MOVS     r0,#1
00027c  7620              STRB     r0,[r4,#0x18]
                  |L1.638|
;;;432      }
;;;433    
;;;434      do
00027e  bf00              NOP      
                  |L1.640|
;;;435      {
;;;436        switch (ep->EP_State)
000280  7820              LDRB     r0,[r4,#0]
000282  2806              CMP      r0,#6
000284  d227              BCS      |L1.726|
000286  e8dff000          TBB      [pc,r0]
00028a  0306              DCB      0x03,0x06
00028c  2773b7ed          DCB      0x27,0x73,0xb7,0xed
;;;437        {
;;;438          /* USB_EP_NAK */
;;;439          case USB_EP_NAK:
;;;440          {
;;;441            /* Fast return if EndPoint in the NAK state */
;;;442            return USB_SUCCESS;
000290  2000              MOVS     r0,#0
                  |L1.658|
;;;443          }
;;;444    
;;;445          /* USB_EP_IDLE */
;;;446          case USB_EP_IDLE:
;;;447          {
;;;448            if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
;;;449            {
;;;450              /* EPRDY dropped - event for this End Point */
;;;451              if ((tmpTS == USB_SEPx_TS_SCTTYPE_Outdata) && ep->EP_WaitOut)
;;;452              {
;;;453                /* OUT transaction started: switch into the OUT state and continue processing there */
;;;454                ep->EP_State = USB_EP_OUT;
;;;455                ep->EP_WaitOut = RESET;
;;;456                nextIteration = SET;
;;;457              }
;;;458              else if ((tmpTS == USB_SEPx_TS_SCTTYPE_Setup) && ep->EP_WaitSetup)
;;;459              {
;;;460                /* SETUP transaction started: switch into the SETUP state and continue processing there */
;;;461                ep->EP_State = USB_EP_SETUP;
;;;462                nextIteration = SET;
;;;463              }
;;;464              else
;;;465              {
;;;466                /* Unexpected transaction: switch into STALL/NAK state and return error */
;;;467                result = USB_ERROR;
;;;468                USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;469              }
;;;470            }
;;;471            break;
;;;472          }
;;;473    
;;;474          /* USB_EP_IN */
;;;475          case USB_EP_IN:
;;;476          {
;;;477            /* Analyze event type */
;;;478            if ((!(tmpCTRL & USB_SEP_CTRL_EPRDY)) && ep->EP_WasScdone &&
;;;479                (tmpTS == USB_SEPx_TS_SCTTYPE_In) && (tmpSTS & USB_SEP_STS_SCACKRXED))
;;;480            {
;;;481              /* 1. ACK event */
;;;482              ep->Buffer.IO_Buffer.offset += ep->Buffer.IO_Buffer.bytesToAck;
;;;483              if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
;;;484              {
;;;485                /* If offset >= length (transfer is over), indicate it with NAK state
;;;486                 * and call handler (if present) */
;;;487                ep->EP_State = USB_EP_NAK;
;;;488                if (ep->InHandler != 0)
;;;489                {
;;;490                  result = ep->InHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.length);
;;;491                }
;;;492    
;;;493                if (result == USB_SUCCESS)
;;;494                {
;;;495                  /* If no other transaction is ordered by user or no data stage of SETUP
;;;496                   * packet (state isn't changed), go to NAK/IDLE state */
;;;497                  if (ep->EP_State == USB_EP_NAK)
;;;498                  {
;;;499                    USB_EP_Idle(EPx);
;;;500                  }
;;;501                }
;;;502                else
;;;503                {
;;;504                  /* If user's handler indicated error, go to STALL/NAK state */
;;;505                  USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;506                }
;;;507              }
;;;508              else
;;;509              {
;;;510                /* If there is any data to send remaining, send next portion */
;;;511                USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_TOGGLE);
;;;512              }
;;;513            }
;;;514            else if (tmpSTS & (USB_SEP_STS_SCRXOF
;;;515                             | USB_SEP_STS_SCCRCERR
;;;516                             | USB_SEP_STS_SCBSERR
;;;517                             | USB_SEP_STS_SCRXTO))
;;;518            {
;;;519              /* 2. Error events - call error handler (if present). Switch temporarily to NAK
;;;520               * to check if user orders another transaction */
;;;521              ep->EP_State = USB_EP_NAK;
;;;522              if (ep->ErrorHandler != 0)
;;;523              {
;;;524                result = ep->ErrorHandler(EPx, tmpSTS, tmpTS, tmpCTRL);
;;;525              }
;;;526              if (result == USB_SUCCESS)
;;;527              {
;;;528                if (ep->EP_State == USB_EP_NAK)
;;;529                {
;;;530                  /* If there is no user's handler or USB_SUCCESS returned and no other transaction
;;;531                   * is started, retry with current data portion */
;;;532                  ep->EP_State = USB_EP_IN;
;;;533                  USB_EP_sendInDataPortion(EPx, USB_DATA_BIT_KEEP);
;;;534                }
;;;535              }
;;;536              else
;;;537              {
;;;538                /* If user's handler indicated error, go to STALL/NAK state */
;;;539                USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;540              }
;;;541            }
;;;542            break;
;;;543          }
;;;544    
;;;545          /* USB_EP_OUT */
;;;546          case USB_EP_OUT:
;;;547          {
;;;548            /* Check for event */
;;;549            if (!(tmpCTRL & USB_SEP_CTRL_EPRDY) && ep->EP_WasScdone)
;;;550            {
;;;551              nextIteration = RESET;
;;;552    
;;;553              /* Read data packet */
;;;554              count = USB_GetSEPxRXFDC(EPx);
;;;555              for (i = 0; i < count; i++)
;;;556              {
;;;557                ep->Buffer.IO_Buffer.pBuffer[ep->Buffer.IO_Buffer.offset + i] = EPx_RX_FIFO_DATA(EPx);
;;;558              }
;;;559              RX_FIFO_FORCE_EMPTY(EPx);
;;;560              ep->Buffer.IO_Buffer.offset += count;
;;;561    
;;;562              /* If offset >= length (transfer is over), indicate it with NAK state
;;;563               * and call handler (if present) */
;;;564              if (ep->Buffer.IO_Buffer.offset >= ep->Buffer.IO_Buffer.length)
;;;565              {
;;;566                ep->EP_State = USB_EP_NAK;
;;;567                if (ep->OutHandler != 0)
;;;568                {
;;;569                  result = ep->OutHandler(EPx, ep->Buffer.IO_Buffer.pBuffer, ep->Buffer.IO_Buffer.offset);
;;;570                }
;;;571    
;;;572                if (result == USB_SUCCESS)
;;;573                {
;;;574                  /* If no other transaction is ordered by user or no data stage of SETUP
;;;575                   * packet (state isn't changed), go to NAK/IDLE state */
;;;576                  if (ep->EP_State == USB_EP_NAK)
;;;577                  {
;;;578                    USB_EP_Idle(EPx);
;;;579                  }
;;;580                }
;;;581                else
;;;582                {
;;;583                  /* If user's handler indicated error, go to STALL/NAK state */
;;;584                  USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;585                }
;;;586              }
;;;587              else
;;;588              {
;;;589                /* If offset < length, wait for another portion */
;;;590                USB_EP_SetReady(EPx, USB_SEPx_CTRL_EPRDY_Ready);
;;;591              }
;;;592            }
;;;593            break;
;;;594          }
;;;595    
;;;596          /* USB_EP_SETUP */
;;;597          case USB_EP_SETUP:
;;;598          {
;;;599            /* Check for event */
;;;600            if (ep->EP_WasScdone)
;;;601            {
;;;602              assert_param(ep->SetupHandler);
;;;603    
;;;604              /* Read setup packet and check for correct size (8 bytes) */
;;;605              count = USB_GetSEPxRXFDC(EPx);
;;;606              if (count == 8)
;;;607              {
;;;608                for (i = 0; i < count; i++)
;;;609                {
;;;610                  ((uint8_t*)ep->Buffer.pSetupPacket)[i] = EPx_RX_FIFO_DATA(EPx);
;;;611                }
;;;612                RX_FIFO_FORCE_EMPTY(EPx);
;;;613    
;;;614                /* Call the handler */
;;;615                result = ep->SetupHandler(EPx, ep->Buffer.pSetupPacket);
;;;616    
;;;617                if (result == USB_SUCCESS)
;;;618                {
;;;619                  /* If no other transaction is ordered by user or no data stage of SETUP
;;;620                   * packet (state isn't changed), go to NAK/IDLE state */
;;;621                  if (ep->EP_State == USB_EP_SETUP)
;;;622                  {
;;;623                    USB_EP_Idle(EPx);
;;;624                  }
;;;625                }
;;;626                else
;;;627                {
;;;628                  /* If user's handler indicated error, go to STALL/NAK state */
;;;629                  USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;630                }
;;;631              }
;;;632              else /* Incorrect packet size */
;;;633              {
;;;634                RX_FIFO_FORCE_EMPTY(EPx);
;;;635                result = USB_ERROR;
;;;636                /* Switch into STALL state */
;;;637                USB_EP_Stall(EPx, USB_STALL_PROTO);
;;;638              }
;;;639            }
;;;640            nextIteration = RESET;
;;;641            break;
;;;642          }
;;;643    
;;;644          /* USB_EP_STALL */
;;;645          case USB_EP_STALL:
;;;646          {
;;;647            if (!(tmpCTRL & USB_SEP_CTRL_EPRDY))
;;;648            {
;;;649              /* EPRDY dropped - event for this End Point */
;;;650              if (ep->EP_Halt == USB_STALL_HALT)
;;;651              {
;;;652                USB_EP_Stall(EPx, USB_STALL_HALT);
;;;653              }
;;;654              else
;;;655              {
;;;656                USB_EP_Idle(EPx);
;;;657              }
;;;658            }
;;;659            break;
;;;660          }
;;;661        }
;;;662      } while (nextIteration);
;;;663    
;;;664      return result;
;;;665    }
000292  e8bd8ffe          POP      {r1-r11,pc}
000296  f0170f02          TST      r7,#2                 ;448
00029a  d11c              BNE      |L1.726|
00029c  7e20              LDRB     r0,[r4,#0x18]         ;448
00029e  b1d0              CBZ      r0,|L1.726|
0002a0  f1b80f02          CMP      r8,#2                 ;451
0002a4  d108              BNE      |L1.696|
0002a6  7e60              LDRB     r0,[r4,#0x19]         ;451
0002a8  b130              CBZ      r0,|L1.696|
0002aa  2003              MOVS     r0,#3                 ;454
0002ac  7020              STRB     r0,[r4,#0]            ;454
0002ae  2000              MOVS     r0,#0                 ;455
0002b0  7660              STRB     r0,[r4,#0x19]         ;455
0002b2  2001              MOVS     r0,#1                 ;456
0002b4  9000              STR      r0,[sp,#0]            ;456
0002b6  e00e              B        |L1.726|
                  |L1.696|
0002b8  f1b80f00          CMP      r8,#0                 ;458
0002bc  d106              BNE      |L1.716|
0002be  7ea0              LDRB     r0,[r4,#0x1a]         ;458
0002c0  b120              CBZ      r0,|L1.716|
0002c2  2004              MOVS     r0,#4                 ;461
0002c4  7020              STRB     r0,[r4,#0]            ;461
0002c6  2001              MOVS     r0,#1                 ;462
0002c8  9000              STR      r0,[sp,#0]            ;462
0002ca  e004              B        |L1.726|
                  |L1.716|
0002cc  2601              MOVS     r6,#1                 ;467
0002ce  2100              MOVS     r1,#0                 ;468
0002d0  4658              MOV      r0,r11                ;468
0002d2  f7fffffe          BL       USB_EP_Stall
                  |L1.726|
0002d6  e0d4              B        |L1.1154|
0002d8  f0170f02          TST      r7,#2                 ;478
0002dc  d12a              BNE      |L1.820|
0002de  7e20              LDRB     r0,[r4,#0x18]         ;478
0002e0  b340              CBZ      r0,|L1.820|
0002e2  f1b80f01          CMP      r8,#1                 ;479
0002e6  d125              BNE      |L1.820|
0002e8  f01a0f40          TST      r10,#0x40             ;479
0002ec  d022              BEQ      |L1.820|
0002ee  e9d41003          LDRD     r1,r0,[r4,#0xc]       ;482
0002f2  4401              ADD      r1,r1,r0              ;482
0002f4  60e1              STR      r1,[r4,#0xc]          ;482
0002f6  e9d40102          LDRD     r0,r1,[r4,#8]         ;483
0002fa  4281              CMP      r1,r0                 ;483
0002fc  d315              BCC      |L1.810|
0002fe  2000              MOVS     r0,#0                 ;487
000300  7020              STRB     r0,[r4,#0]            ;487
000302  69e0              LDR      r0,[r4,#0x1c]         ;488
000304  b128              CBZ      r0,|L1.786|
000306  4658              MOV      r0,r11                ;490
000308  69e3              LDR      r3,[r4,#0x1c]         ;490
00030a  e9d41201          LDRD     r1,r2,[r4,#4]         ;490
00030e  4798              BLX      r3                    ;490
000310  4606              MOV      r6,r0                 ;490
                  |L1.786|
000312  b92e              CBNZ     r6,|L1.800|
000314  7820              LDRB     r0,[r4,#0]            ;497
000316  bb28              CBNZ     r0,|L1.868|
000318  4658              MOV      r0,r11                ;499
00031a  f7fffffe          BL       USB_EP_Idle
00031e  e026              B        |L1.878|
                  |L1.800|
000320  2100              MOVS     r1,#0                 ;505
000322  4658              MOV      r0,r11                ;505
000324  f7fffffe          BL       USB_EP_Stall
000328  e021              B        |L1.878|
                  |L1.810|
00032a  2101              MOVS     r1,#1                 ;511
00032c  4658              MOV      r0,r11                ;511
00032e  f7fffffe          BL       USB_EP_sendInDataPortion
000332  e01c              B        |L1.878|
                  |L1.820|
000334  f01a0f0f          TST      r10,#0xf              ;514
000338  d019              BEQ      |L1.878|
00033a  2000              MOVS     r0,#0                 ;521
00033c  7020              STRB     r0,[r4,#0]            ;521
00033e  6aa0              LDR      r0,[r4,#0x28]         ;522
000340  b138              CBZ      r0,|L1.850|
000342  463b              MOV      r3,r7                 ;524
000344  4642              MOV      r2,r8                 ;524
000346  4651              MOV      r1,r10                ;524
000348  4658              MOV      r0,r11                ;524
00034a  f8d4c028          LDR      r12,[r4,#0x28]        ;524
00034e  47e0              BLX      r12                   ;524
000350  4606              MOV      r6,r0                 ;524
                  |L1.850|
000352  b946              CBNZ     r6,|L1.870|
000354  7820              LDRB     r0,[r4,#0]            ;528
000356  b928              CBNZ     r0,|L1.868|
000358  2002              MOVS     r0,#2                 ;532
00035a  7020              STRB     r0,[r4,#0]            ;532
00035c  2100              MOVS     r1,#0                 ;533
00035e  4658              MOV      r0,r11                ;533
000360  f7fffffe          BL       USB_EP_sendInDataPortion
                  |L1.868|
000364  e003              B        |L1.878|
                  |L1.870|
000366  2100              MOVS     r1,#0                 ;539
000368  4658              MOV      r0,r11                ;539
00036a  f7fffffe          BL       USB_EP_Stall
                  |L1.878|
00036e  e088              B        |L1.1154|
000370  f0170f02          TST      r7,#2                 ;549
000374  d13a              BNE      |L1.1004|
000376  7e20              LDRB     r0,[r4,#0x18]         ;549
000378  b370              CBZ      r0,|L1.984|
00037a  2000              MOVS     r0,#0                 ;551
00037c  9000              STR      r0,[sp,#0]            ;551
00037e  4658              MOV      r0,r11                ;554
000380  f7fffffe          BL       USB_GetSEPxRXFDC
000384  4681              MOV      r9,r0                 ;554
000386  2500              MOVS     r5,#0                 ;555
000388  e008              B        |L1.924|
                  |L1.906|
00038a  4658              MOV      r0,r11                ;557
00038c  f7fffffe          BL       USB_GetSEPxRXFD
000390  b2c1              UXTB     r1,r0                 ;557
000392  68e0              LDR      r0,[r4,#0xc]          ;557
000394  4428              ADD      r0,r0,r5              ;557
000396  6862              LDR      r2,[r4,#4]            ;557
000398  5411              STRB     r1,[r2,r0]            ;557
00039a  1c6d              ADDS     r5,r5,#1              ;555
                  |L1.924|
00039c  454d              CMP      r5,r9                 ;555
00039e  d3f4              BCC      |L1.906|
0003a0  2101              MOVS     r1,#1                 ;559
0003a2  4658              MOV      r0,r11                ;559
0003a4  f7fffffe          BL       USB_SetSEPxRXFC
0003a8  68e0              LDR      r0,[r4,#0xc]          ;560
0003aa  eb000109          ADD      r1,r0,r9              ;560
0003ae  60e1              STR      r1,[r4,#0xc]          ;560
0003b0  e9d40102          LDRD     r0,r1,[r4,#8]         ;564
0003b4  4281              CMP      r1,r0                 ;564
0003b6  d315              BCC      |L1.996|
0003b8  2000              MOVS     r0,#0                 ;566
0003ba  7020              STRB     r0,[r4,#0]            ;566
0003bc  6a20              LDR      r0,[r4,#0x20]         ;567
0003be  b128              CBZ      r0,|L1.972|
0003c0  4658              MOV      r0,r11                ;569
0003c2  6a23              LDR      r3,[r4,#0x20]         ;569
0003c4  68e2              LDR      r2,[r4,#0xc]          ;569
0003c6  6861              LDR      r1,[r4,#4]            ;569
0003c8  4798              BLX      r3                    ;569
0003ca  4606              MOV      r6,r0                 ;569
                  |L1.972|
0003cc  b92e              CBNZ     r6,|L1.986|
0003ce  7820              LDRB     r0,[r4,#0]            ;576
0003d0  b910              CBNZ     r0,|L1.984|
0003d2  4658              MOV      r0,r11                ;578
0003d4  f7fffffe          BL       USB_EP_Idle
                  |L1.984|
0003d8  e008              B        |L1.1004|
                  |L1.986|
0003da  2100              MOVS     r1,#0                 ;584
0003dc  4658              MOV      r0,r11                ;584
0003de  f7fffffe          BL       USB_EP_Stall
0003e2  e003              B        |L1.1004|
                  |L1.996|
0003e4  2102              MOVS     r1,#2                 ;590
0003e6  4658              MOV      r0,r11                ;590
0003e8  f7fffffe          BL       USB_EP_SetReady
                  |L1.1004|
0003ec  e049              B        |L1.1154|
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      USB_EPContext
                  |L1.1012|
                          DCD      0x00120001
0003f8  7e20              LDRB     r0,[r4,#0x18]         ;600
0003fa  b308              CBZ      r0,|L1.1088|
0003fc  4658              MOV      r0,r11                ;605
0003fe  f7fffffe          BL       USB_GetSEPxRXFDC
000402  4681              MOV      r9,r0                 ;605
000404  f1b90f08          CMP      r9,#8                 ;606
000408  d120              BNE      |L1.1100|
00040a  2500              MOVS     r5,#0                 ;608
00040c  e006              B        |L1.1052|
                  |L1.1038|
00040e  4658              MOV      r0,r11                ;610
000410  f7fffffe          BL       USB_GetSEPxRXFD
000414  b2c1              UXTB     r1,r0                 ;610
000416  6960              LDR      r0,[r4,#0x14]         ;610
000418  5541              STRB     r1,[r0,r5]            ;610
00041a  1c6d              ADDS     r5,r5,#1              ;608
                  |L1.1052|
00041c  454d              CMP      r5,r9                 ;608
00041e  d3f6              BCC      |L1.1038|
000420  2101              MOVS     r1,#1                 ;612
000422  4658              MOV      r0,r11                ;612
000424  f7fffffe          BL       USB_SetSEPxRXFC
000428  4658              MOV      r0,r11                ;615
00042a  6a62              LDR      r2,[r4,#0x24]         ;615
00042c  6961              LDR      r1,[r4,#0x14]         ;615
00042e  4790              BLX      r2                    ;615
000430  4606              MOV      r6,r0                 ;615
000432  b936              CBNZ     r6,|L1.1090|
000434  7820              LDRB     r0,[r4,#0]            ;621
000436  2804              CMP      r0,#4                 ;621
000438  d111              BNE      |L1.1118|
00043a  4658              MOV      r0,r11                ;623
00043c  f7fffffe          BL       USB_EP_Idle
                  |L1.1088|
000440  e00d              B        |L1.1118|
                  |L1.1090|
000442  2100              MOVS     r1,#0                 ;629
000444  4658              MOV      r0,r11                ;629
000446  f7fffffe          BL       USB_EP_Stall
00044a  e008              B        |L1.1118|
                  |L1.1100|
00044c  2101              MOVS     r1,#1                 ;634
00044e  4658              MOV      r0,r11                ;634
000450  f7fffffe          BL       USB_SetSEPxRXFC
000454  2601              MOVS     r6,#1                 ;635
000456  2100              MOVS     r1,#0                 ;637
000458  4658              MOV      r0,r11                ;637
00045a  f7fffffe          BL       USB_EP_Stall
                  |L1.1118|
00045e  2000              MOVS     r0,#0                 ;640
000460  9000              STR      r0,[sp,#0]            ;640
000462  e00e              B        |L1.1154|
000464  f0170f02          TST      r7,#2                 ;647
000468  d10a              BNE      |L1.1152|
00046a  7860              LDRB     r0,[r4,#1]            ;650
00046c  2801              CMP      r0,#1                 ;650
00046e  d104              BNE      |L1.1146|
000470  2101              MOVS     r1,#1                 ;652
000472  4658              MOV      r0,r11                ;652
000474  f7fffffe          BL       USB_EP_Stall
000478  e002              B        |L1.1152|
                  |L1.1146|
00047a  4658              MOV      r0,r11                ;656
00047c  f7fffffe          BL       USB_EP_Idle
                  |L1.1152|
000480  bf00              NOP                            ;659
                  |L1.1154|
000482  bf00              NOP                            ;471
000484  9800              LDR      r0,[sp,#0]            ;662
000486  2800              CMP      r0,#0                 ;662
000488  f47faefa          BNE      |L1.640|
00048c  4630              MOV      r0,r6                 ;664
00048e  e700              B        |L1.658|
;;;666    
                          ENDP

                  USB_Device_setAddressWork PROC
;;;1290   
;;;1291   static USB_Result USB_Device_setAddressWork(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
000490  b570              PUSH     {r4-r6,lr}
;;;1292   {
000492  4604              MOV      r4,r0
000494  460d              MOV      r5,r1
000496  4616              MOV      r6,r2
;;;1293     /* Set address */
;;;1294     USB_SetSA(USB_DeviceContext.Address);
000498  49f6              LDR      r1,|L1.2164|
00049a  6888              LDR      r0,[r1,#8]  ; USB_DeviceContext
00049c  f7fffffe          BL       USB_SetSA
;;;1295     /* Adjust device state */
;;;1296     USB_DeviceContext.USB_DeviceState = (USB_DeviceContext.Address ? USB_DEV_STATE_ADDRESS : USB_DEV_STATE_DEFAULT);
0004a0  48f4              LDR      r0,|L1.2164|
0004a2  6880              LDR      r0,[r0,#8]  ; USB_DeviceContext
0004a4  b108              CBZ      r0,|L1.1194|
0004a6  2004              MOVS     r0,#4
0004a8  e000              B        |L1.1196|
                  |L1.1194|
0004aa  2003              MOVS     r0,#3
                  |L1.1196|
0004ac  49f1              LDR      r1,|L1.2164|
0004ae  7008              STRB     r0,[r1,#0]
;;;1297   
;;;1298     return USB_SUCCESS;
0004b0  2000              MOVS     r0,#0
;;;1299   }
0004b2  bd70              POP      {r4-r6,pc}
;;;1300   
                          ENDP

                  USB_DeviceSetFeature PROC
;;;1205   
;;;1206   USB_Result USB_DeviceSetFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
0004b4  b570              PUSH     {r4-r6,lr}
;;;1207   {
0004b6  4604              MOV      r4,r0
0004b8  460d              MOV      r5,r1
0004ba  4616              MOV      r6,r2
;;;1208     if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
0004bc  2c02              CMP      r4,#2
0004be  d105              BNE      |L1.1228|
0004c0  b925              CBNZ     r5,|L1.1228|
;;;1209     {
;;;1210       return USB_EP_Stall((USB_EP_TypeDef)wINDEX, USB_STALL_HALT);
0004c2  b2f0              UXTB     r0,r6
0004c4  2101              MOVS     r1,#1
0004c6  f7fffffe          BL       USB_EP_Stall
                  |L1.1226|
;;;1211     }
;;;1212     else
;;;1213     {
;;;1214       return USB_ERROR;
;;;1215     }
;;;1216   }
0004ca  bd70              POP      {r4-r6,pc}
                  |L1.1228|
0004cc  2001              MOVS     r0,#1                 ;1214
0004ce  e7fc              B        |L1.1226|
;;;1217   
                          ENDP

                  USB_DeviceClearFeature PROC
;;;1173   
;;;1174   USB_Result USB_DeviceClearFeature(USB_RequestRecipient_TypeDef Recipient, uint16_t wVALUE, uint16_t wINDEX)
0004d0  b570              PUSH     {r4-r6,lr}
;;;1175   {
0004d2  4604              MOV      r4,r0
0004d4  460d              MOV      r5,r1
0004d6  4616              MOV      r6,r2
;;;1176     if ((Recipient == USB_RECIPIENT_ENDPOINT) && (wVALUE == USB_ENDPOINT_HALT))
0004d8  2c02              CMP      r4,#2
0004da  d104              BNE      |L1.1254|
0004dc  b91d              CBNZ     r5,|L1.1254|
;;;1177     {
;;;1178       return USB_EP_Idle((USB_EP_TypeDef)wINDEX);
0004de  b2f0              UXTB     r0,r6
0004e0  f7fffffe          BL       USB_EP_Idle
                  |L1.1252|
;;;1179     }
;;;1180     else
;;;1181     {
;;;1182       return USB_ERROR;
;;;1183     }
;;;1184   }
0004e4  bd70              POP      {r4-r6,pc}
                  |L1.1254|
0004e6  2001              MOVS     r0,#1                 ;1182
0004e8  e7fc              B        |L1.1252|
;;;1185   
                          ENDP

                  USB_DeviceSetupPacket PROC
;;;940    
;;;941    USB_Result USB_DeviceSetupPacket(USB_EP_TypeDef EPx, const USB_SetupPacket_TypeDef* USB_SetupPacket)
0004ea  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;942    {
0004ee  b081              SUB      sp,sp,#4
0004f0  460c              MOV      r4,r1
;;;943      USB_RequestType_TypeDef requestType;
;;;944      USB_RequestTypeDT_TypeDef requestDirection;
;;;945    
;;;946      USB_Result result = USB_SUCCESS;
0004f2  f04f0800          MOV      r8,#0
;;;947      uint16_t wValue, wIndex, wLength;
;;;948    
;;;949      /* Check the parameters */
;;;950      assert_param(IS_USB_ENDPOINT(EPx));
;;;951    
;;;952      /* Determine request type */
;;;953      requestType = (USB_RequestType_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_TYPE_Msk);
0004f6  7820              LDRB     r0,[r4,#0]
0004f8  f0000b60          AND      r11,r0,#0x60
;;;954      requestDirection = (USB_RequestTypeDT_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_REQUEST_DT_Msk);
0004fc  7820              LDRB     r0,[r4,#0]
0004fe  f0000080          AND      r0,r0,#0x80
000502  9000              STR      r0,[sp,#0]
;;;955    
;;;956      /* Process request */
;;;957      switch (requestType)
000504  f1bb0f00          CMP      r11,#0
000508  d006              BEQ      |L1.1304|
00050a  f1bb0f20          CMP      r11,#0x20
00050e  d077              BEQ      |L1.1536|
000510  f1bb0f40          CMP      r11,#0x40
000514  d175              BNE      |L1.1538|
000516  e108              B        |L1.1834|
                  |L1.1304|
;;;958      {
;;;959        /* Standard request */
;;;960        case USB_TYPE_STANDARD: {
;;;961          USB_RequestRecipient_TypeDef recipient;
;;;962          USB_EP_IO_Handler statusAckHandler = 0;
000518  f04f0a00          MOV      r10,#0
;;;963    
;;;964          wValue = USB_SetupPacket->wValue;
00051c  8867              LDRH     r7,[r4,#2]
;;;965          wIndex = USB_SetupPacket->wIndex;
00051e  88a6              LDRH     r6,[r4,#4]
;;;966          wLength = USB_SetupPacket->wLength;
000520  f8b49006          LDRH     r9,[r4,#6]
;;;967    
;;;968          /* Recipient check */
;;;969          recipient = (USB_RequestRecipient_TypeDef)(USB_SetupPacket->mRequestTypeData & USB_RECIPIENT_TYPE_Msk);
000524  7820              LDRB     r0,[r4,#0]
000526  f000051f          AND      r5,r0,#0x1f
;;;970          if (!IS_VALID_USB_RECIPIENT(recipient)) {
00052a  2d03              CMP      r5,#3
00052c  dd02              BLE      |L1.1332|
;;;971            result = USB_ERR_INV_REQ;
00052e  f04f0802          MOV      r8,#2
;;;972            break;
000532  e100              B        |L1.1846|
                  |L1.1332|
;;;973          }
;;;974          /* Specific requests */
;;;975          switch (USB_SetupPacket->bRequest)
000534  7860              LDRB     r0,[r4,#1]
000536  280d              CMP      r0,#0xd
000538  d272              BCS      |L1.1568|
00053a  e8dff000          TBB      [pc,r0]
00053e  0740              DCB      0x07,0x40
000540  d454d46a          DCB      0xd4,0x54,0xd4,0x6a
000544  72797c8f          DCB      0x72,0x79,0x7c,0x8f
000548  a1b2c000          DCB      0xa1,0xb2,0xc0,0x00
;;;976          {
;;;977            /* GET_STATUS */
;;;978            case USB_GET_STATUS:
;;;979              if (requestDirection != USB_DEVICE_TO_HOST ||
00054c  9800              LDR      r0,[sp,#0]
00054e  2880              CMP      r0,#0x80
000550  d109              BNE      |L1.1382|
;;;980                 (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
000552  48c8              LDR      r0,|L1.2164|
000554  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
000556  2804              CMP      r0,#4
000558  d108              BNE      |L1.1388|
00055a  2d01              CMP      r5,#1
00055c  d003              BEQ      |L1.1382|
;;;981                  recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
00055e  2d02              CMP      r5,#2
000560  d104              BNE      |L1.1388|
000562  2e04              CMP      r6,#4
000564  db02              BLT      |L1.1388|
                  |L1.1382|
;;;982              {
;;;983                result = USB_ERROR;
000566  f04f0801          MOV      r8,#1
00056a  e027              B        |L1.1468|
                  |L1.1388|
;;;984              }
;;;985              else
;;;986              {
;;;987                /* Give user a chance to set flags in the device context */
;;;988                result = USB_DEVICE_HANDLE_GET_STATUS(recipient, wIndex);
00056c  f04f0800          MOV      r8,#0
;;;989                if (result == USB_SUCCESS)
000570  f1b80f00          CMP      r8,#0
000574  d122              BNE      |L1.1468|
;;;990                {
;;;991                  switch (recipient)
000576  b125              CBZ      r5,|L1.1410|
000578  2d01              CMP      r5,#1
00057a  d006              BEQ      |L1.1418|
00057c  2d02              CMP      r5,#2
00057e  d113              BNE      |L1.1448|
000580  e007              B        |L1.1426|
                  |L1.1410|
;;;992                  {
;;;993                    /* Device - return Self Powered and Remote Wakeup status */
;;;994                    case USB_RECIPIENT_DEVICE:
;;;995                      SetupPacketData[0] = 0
000582  2000              MOVS     r0,#0
000584  49bc              LDR      r1,|L1.2168|
000586  7008              STRB     r0,[r1,#0]
;;;996    #ifdef USB_SELF_POWERED_SUPPORTED
;;;997                        | USB_DeviceContext.USB_DeviceStatus.SelfPowered
;;;998    #endif /* USB_SELF_POWERED_SUPPORTED */
;;;999    #ifdef USB_REMOTE_WAKEUP_SUPPORTED
;;;1000                       | (USB_DeviceContext.USB_DeviceStatus.RemoteWakeupEnabled << 1)
;;;1001   #endif /* USB_REMOTE_WAKEUP_SUPPORTED */
;;;1002                       ;
;;;1003                     break;
000588  e00e              B        |L1.1448|
                  |L1.1418|
;;;1004                   /* Interface - return 0 */
;;;1005                   case USB_RECIPIENT_INTERFACE:
;;;1006                     SetupPacketData[0] = 0;
00058a  2000              MOVS     r0,#0
00058c  49ba              LDR      r1,|L1.2168|
00058e  7008              STRB     r0,[r1,#0]
;;;1007                     break;
000590  e00a              B        |L1.1448|
                  |L1.1426|
;;;1008                   /* Endpoint - return Halt status */
;;;1009                   case USB_RECIPIENT_ENDPOINT:
;;;1010                     SetupPacketData[0] = USB_EPContext[wIndex].EP_Halt;
000592  eb060046          ADD      r0,r6,r6,LSL #1
000596  eb0000c6          ADD      r0,r0,r6,LSL #3
00059a  49b8              LDR      r1,|L1.2172|
00059c  eb010080          ADD      r0,r1,r0,LSL #2
0005a0  7840              LDRB     r0,[r0,#1]
0005a2  49b5              LDR      r1,|L1.2168|
0005a4  7008              STRB     r0,[r1,#0]
;;;1011                     break;
0005a6  bf00              NOP      
                  |L1.1448|
0005a8  bf00              NOP                            ;1003
;;;1012                 }
;;;1013                 SetupPacketData[1] = 0;
0005aa  2000              MOVS     r0,#0
0005ac  49b2              LDR      r1,|L1.2168|
0005ae  7048              STRB     r0,[r1,#1]
;;;1014                 result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
0005b0  2300              MOVS     r3,#0
0005b2  2202              MOVS     r2,#2
0005b4  9801              LDR      r0,[sp,#4]
0005b6  f7fffffe          BL       USB_EP_doDataIn
0005ba  4680              MOV      r8,r0
                  |L1.1468|
;;;1015               }
;;;1016             }
;;;1017             break;
0005bc  e096              B        |L1.1772|
;;;1018           /* CLEAR_FEATURE */
;;;1019           case USB_CLEAR_FEATURE:
;;;1020             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
0005be  48ad              LDR      r0,|L1.2164|
0005c0  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
0005c2  2804              CMP      r0,#4
0005c4  d108              BNE      |L1.1496|
0005c6  2d01              CMP      r5,#1
0005c8  d003              BEQ      |L1.1490|
;;;1021                 (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
0005ca  2d02              CMP      r5,#2
0005cc  d104              BNE      |L1.1496|
0005ce  2e04              CMP      r6,#4
0005d0  db02              BLT      |L1.1496|
                  |L1.1490|
;;;1022             {
;;;1023               result = USB_ERROR;
0005d2  f04f0801          MOV      r8,#1
0005d6  e005              B        |L1.1508|
                  |L1.1496|
;;;1024             }
;;;1025             else
;;;1026             {
;;;1027               result = USB_DEVICE_HANDLE_CLEAR_FEATURE(recipient, wValue, wIndex);
0005d8  4632              MOV      r2,r6
0005da  4639              MOV      r1,r7
0005dc  4628              MOV      r0,r5
0005de  f7fffffe          BL       USB_DeviceClearFeature
0005e2  4680              MOV      r8,r0
                  |L1.1508|
;;;1028             }
;;;1029             break;
0005e4  e082              B        |L1.1772|
;;;1030           /* SET_FEATURE */
;;;1031           case USB_SET_FEATURE:
;;;1032             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS && (recipient == USB_RECIPIENT_INTERFACE ||
0005e6  48a3              LDR      r0,|L1.2164|
0005e8  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
0005ea  2804              CMP      r0,#4
0005ec  d10a              BNE      |L1.1540|
0005ee  2d01              CMP      r5,#1
0005f0  d003              BEQ      |L1.1530|
;;;1033                 (recipient == USB_RECIPIENT_ENDPOINT && wIndex >= Num_USB_EndPoints)))
0005f2  2d02              CMP      r5,#2
0005f4  d106              BNE      |L1.1540|
0005f6  2e04              CMP      r6,#4
0005f8  db04              BLT      |L1.1540|
                  |L1.1530|
;;;1034             {
;;;1035               result = USB_ERROR;
0005fa  f04f0801          MOV      r8,#1
0005fe  e007              B        |L1.1552|
                  |L1.1536|
000600  e08f              B        |L1.1826|
                  |L1.1538|
000602  e095              B        |L1.1840|
                  |L1.1540|
;;;1036             }
;;;1037             else
;;;1038             {
;;;1039               result = USB_DEVICE_HANDLE_SET_FEATURE(recipient, wValue, wIndex);
000604  4632              MOV      r2,r6
000606  4639              MOV      r1,r7
000608  4628              MOV      r0,r5
00060a  f7fffffe          BL       USB_DeviceSetFeature
00060e  4680              MOV      r8,r0
                  |L1.1552|
;;;1040             }
;;;1041             break;
000610  e06c              B        |L1.1772|
;;;1042           /* SET_ADDRESS */
;;;1043           case USB_SET_ADDRESS:
;;;1044             result = USB_DEVICE_HANDLE_SET_ADDRESS(wValue);
000612  f04f0800          MOV      r8,#0
;;;1045             /* Set special Status Stage handler that will actually change the address */
;;;1046             USB_DeviceContext.Address = wValue;
000616  4897              LDR      r0,|L1.2164|
000618  6087              STR      r7,[r0,#8]  ; USB_DeviceContext
;;;1047             statusAckHandler = USB_Device_setAddressWork;
00061a  f8dfa264          LDR      r10,|L1.2176|
;;;1048             break;
00061e  e065              B        |L1.1772|
                  |L1.1568|
000620  e061              B        |L1.1766|
;;;1049           /* GET_DESCRIPTOR */
;;;1050           case USB_GET_DESCRIPTOR:
;;;1051             result = USB_DEVICE_HANDLE_GET_DESCRIPTOR(wValue, wIndex, wLength);
000622  464a              MOV      r2,r9
000624  4631              MOV      r1,r6
000626  4638              MOV      r0,r7
000628  f7fffffe          BL       USB_CDC_GetDescriptor
00062c  4680              MOV      r8,r0
;;;1052             break;
00062e  e05d              B        |L1.1772|
;;;1053           /* SET_DESCRIPTOR */
;;;1054           case USB_SET_DESCRIPTOR:
;;;1055             result = USB_DEVICE_HANDLE_SET_DESCRIPTOR(wValue, wIndex, wLength);
000630  f04f0801          MOV      r8,#1
;;;1056             break;
000634  e05a              B        |L1.1772|
;;;1057           /* GET_CONFIGURATION */
;;;1058           case USB_GET_CONFIGURATION:
;;;1059             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
000636  488f              LDR      r0,|L1.2164|
000638  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
00063a  2804              CMP      r0,#4
00063c  d103              BNE      |L1.1606|
;;;1060             {
;;;1061               SetupPacketData[0] = 0;
00063e  2000              MOVS     r0,#0
000640  498d              LDR      r1,|L1.2168|
000642  7008              STRB     r0,[r1,#0]
000644  e002              B        |L1.1612|
                  |L1.1606|
;;;1062             }
;;;1063             else
;;;1064             {
;;;1065               SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_CONFIGURATION;
000646  2001              MOVS     r0,#1
000648  498b              LDR      r1,|L1.2168|
00064a  7008              STRB     r0,[r1,#0]
                  |L1.1612|
;;;1066             }
;;;1067             result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
00064c  2300              MOVS     r3,#0
00064e  2201              MOVS     r2,#1
000650  4989              LDR      r1,|L1.2168|
000652  9801              LDR      r0,[sp,#4]
000654  f7fffffe          BL       USB_EP_doDataIn
000658  4680              MOV      r8,r0
;;;1068             break;
00065a  e047              B        |L1.1772|
;;;1069           /* SET_CONFIGURATION */
;;;1070           case USB_SET_CONFIGURATION:
;;;1071             if (wValue == 0)
00065c  b91f              CBNZ     r7,|L1.1638|
;;;1072             {
;;;1073               USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_ADDRESS;
00065e  2004              MOVS     r0,#4
000660  4984              LDR      r1,|L1.2164|
000662  7008              STRB     r0,[r1,#0]
000664  e00b              B        |L1.1662|
                  |L1.1638|
;;;1074             }
;;;1075             else
;;;1076             {
;;;1077               result = USB_DEVICE_HANDLE_SET_CONFIGURATION(wValue);
000666  2f01              CMP      r7,#1
000668  d001              BEQ      |L1.1646|
00066a  2001              MOVS     r0,#1
00066c  e000              B        |L1.1648|
                  |L1.1646|
00066e  2000              MOVS     r0,#0
                  |L1.1648|
000670  4680              MOV      r8,r0
;;;1078               if (result == USB_SUCCESS)
000672  f1b80f00          CMP      r8,#0
000676  d102              BNE      |L1.1662|
;;;1079               {
;;;1080                 USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_CONFIGURED;
000678  2005              MOVS     r0,#5
00067a  497e              LDR      r1,|L1.2164|
00067c  7008              STRB     r0,[r1,#0]
                  |L1.1662|
;;;1081               }
;;;1082             }
;;;1083             break;
00067e  e035              B        |L1.1772|
;;;1084           /* GET_INTERFACE */
;;;1085           case USB_GET_INTERFACE:
;;;1086             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
000680  487c              LDR      r0,|L1.2164|
000682  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
000684  2804              CMP      r0,#4
000686  d102              BNE      |L1.1678|
;;;1087             {
;;;1088               result = USB_ERROR;
000688  f04f0801          MOV      r8,#1
00068c  e008              B        |L1.1696|
                  |L1.1678|
;;;1089             }
;;;1090             else
;;;1091             {
;;;1092               SetupPacketData[0] = (uint8_t)USB_DEVICE_HANDLE_GET_INTERFACE(wIndex);
00068e  2000              MOVS     r0,#0
000690  4979              LDR      r1,|L1.2168|
000692  7008              STRB     r0,[r1,#0]
;;;1093               result = USB_EP_doDataIn(EPx, SetupPacketData, 1, 0);
000694  2300              MOVS     r3,#0
000696  2201              MOVS     r2,#1
000698  9801              LDR      r0,[sp,#4]
00069a  f7fffffe          BL       USB_EP_doDataIn
00069e  4680              MOV      r8,r0
                  |L1.1696|
;;;1094             }
;;;1095             break;
0006a0  e024              B        |L1.1772|
;;;1096           /* SET_INTERFACE */
;;;1097           case USB_SET_INTERFACE:
;;;1098             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
0006a2  4874              LDR      r0,|L1.2164|
0006a4  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
0006a6  2804              CMP      r0,#4
0006a8  d102              BNE      |L1.1712|
;;;1099             {
;;;1100               result = USB_ERROR;
0006aa  f04f0801          MOV      r8,#1
0006ae  e005              B        |L1.1724|
                  |L1.1712|
;;;1101             }
;;;1102             else
;;;1103             {
;;;1104               result = USB_DEVICE_HANDLE_SET_INTERFACE(wValue, wIndex);
0006b0  b906              CBNZ     r6,|L1.1716|
0006b2  b10f              CBZ      r7,|L1.1720|
                  |L1.1716|
0006b4  2001              MOVS     r0,#1
0006b6  e000              B        |L1.1722|
                  |L1.1720|
0006b8  2000              MOVS     r0,#0
                  |L1.1722|
0006ba  4680              MOV      r8,r0
                  |L1.1724|
;;;1105             }
;;;1106             break;
0006bc  e016              B        |L1.1772|
;;;1107           /* SYNCH_FRAME */
;;;1108           case USB_SYNCH_FRAME:
;;;1109             if (USB_DeviceContext.USB_DeviceState == USB_DEV_STATE_ADDRESS)
0006be  486d              LDR      r0,|L1.2164|
0006c0  7800              LDRB     r0,[r0,#0]  ; USB_DeviceContext
0006c2  2804              CMP      r0,#4
0006c4  d102              BNE      |L1.1740|
;;;1110             {
;;;1111               result = USB_ERROR;
0006c6  f04f0801          MOV      r8,#1
0006ca  e00b              B        |L1.1764|
                  |L1.1740|
;;;1112             }
;;;1113             else
;;;1114             {
;;;1115               result = USB_DEVICE_HANDLE_SYNC_FRAME(wIndex, SetupPacketData);
0006cc  f04f0801          MOV      r8,#1
;;;1116               if (result == USB_SUCCESS)
0006d0  f1b80f00          CMP      r8,#0
0006d4  d106              BNE      |L1.1764|
;;;1117               {
;;;1118                 result = USB_EP_doDataIn(EPx, SetupPacketData, 2, 0);
0006d6  2300              MOVS     r3,#0
0006d8  2202              MOVS     r2,#2
0006da  4967              LDR      r1,|L1.2168|
0006dc  9801              LDR      r0,[sp,#4]
0006de  f7fffffe          BL       USB_EP_doDataIn
0006e2  4680              MOV      r8,r0
                  |L1.1764|
;;;1119               }
;;;1120             }
;;;1121             break;
0006e4  e002              B        |L1.1772|
                  |L1.1766|
;;;1122           default:
;;;1123             result = USB_ERR_INV_REQ;
0006e6  f04f0802          MOV      r8,#2
0006ea  bf00              NOP                            ;975
                  |L1.1772|
0006ec  bf00              NOP                            ;1017
;;;1124         }
;;;1125         /* If there were no DATA stage, initiate Status Stage (IN ACK) */
;;;1126         if (result == USB_SUCCESS && wLength == 0)
0006ee  f1b80f00          CMP      r8,#0
0006f2  d115              BNE      |L1.1824|
0006f4  f1b90f00          CMP      r9,#0
0006f8  d112              BNE      |L1.1824|
;;;1127         {
;;;1128           result = (USB_SetupPacket->mRequestTypeData & 0x80) == USB_DEVICE_TO_HOST ?
0006fa  7820              LDRB     r0,[r4,#0]
0006fc  f0000080          AND      r0,r0,#0x80
000700  2880              CMP      r0,#0x80
000702  d106              BNE      |L1.1810|
;;;1129                           USB_EP_doDataOut(EPx, 0, 0, statusAckHandler) :
000704  4653              MOV      r3,r10
000706  2200              MOVS     r2,#0
000708  4611              MOV      r1,r2
00070a  9801              LDR      r0,[sp,#4]
00070c  f7fffffe          BL       USB_EP_doDataOut
000710  e005              B        |L1.1822|
                  |L1.1810|
;;;1130                           USB_EP_doDataIn(EPx, 0, 0, statusAckHandler);
000712  4653              MOV      r3,r10
000714  2200              MOVS     r2,#0
000716  4611              MOV      r1,r2
000718  9801              LDR      r0,[sp,#4]
00071a  f7fffffe          BL       USB_EP_doDataIn
                  |L1.1822|
00071e  4680              MOV      r8,r0
                  |L1.1824|
;;;1131         }
;;;1132         break;
000720  e009              B        |L1.1846|
                  |L1.1826|
;;;1133       }
;;;1134       /* Class-specific request */
;;;1135       case USB_TYPE_CLASS:
;;;1136         result = USB_DEVICE_HANDLE_CLASS_REQUEST;
000722  f7fffffe          BL       USB_CDC_ClassRequest
000726  4680              MOV      r8,r0
;;;1137         break;
000728  e005              B        |L1.1846|
                  |L1.1834|
;;;1138       /* Vendor-specific request */
;;;1139       case USB_TYPE_VENDOR:
;;;1140         result = USB_DEVICE_HANDLE_VENDOR_REQUEST;
00072a  f04f0801          MOV      r8,#1
;;;1141         break;
00072e  e002              B        |L1.1846|
                  |L1.1840|
;;;1142       default:
;;;1143         result = USB_ERR_INV_REQ;
000730  f04f0802          MOV      r8,#2
000734  bf00              NOP                            ;957
                  |L1.1846|
000736  bf00              NOP                            ;972
;;;1144     }
;;;1145     return result;
000738  4640              MOV      r0,r8
;;;1146   }
00073a  e8bd8ffe          POP      {r1-r11,pc}
;;;1147   
                          ENDP

                  USB_DeviceInit PROC
;;;807    
;;;808    USB_Result USB_DeviceInit(const USB_Clock_TypeDef* USB_Clock_InitStruct, USB_DeviceBUSParam_TypeDef* USB_DeviceBUSParam)
00073e  b570              PUSH     {r4-r6,lr}
;;;809    {
000740  4605              MOV      r5,r0
000742  460c              MOV      r4,r1
;;;810      /* Check the parameters */
;;;811      assert_param(IS_USB_PULL(USB_DeviceBUSParam->PULL));
;;;812      assert_param(IS_USB_SPEED(USB_DeviceBUSParam->SPEED));
;;;813      assert_param(IS_USB_MODE(USB_DeviceBUSParam->MODE));
;;;814    
;;;815      /* Set USB clocks perform controller reset */
;;;816      USB_BRGInit(USB_Clock_InitStruct);
000744  4628              MOV      r0,r5
000746  f7fffffe          BL       USB_BRGInit
;;;817      USB_Reset();
00074a  f7fffffe          BL       USB_Reset
;;;818      /* Set pulls and Device mode */
;;;819      USB_SetHSCR(USB_HSCR_HOST_MODE_Device);
00074e  f44f3080          MOV      r0,#0x10000
000752  f7fffffe          BL       USB_SetHSCR
;;;820      USB_SetHSCR(USB_DeviceBUSParam->PULL);
000756  6820              LDR      r0,[r4,#0]
000758  f7fffffe          BL       USB_SetHSCR
;;;821      /* Set speed, polarity and enable end points */
;;;822      USB_SetSC(USB_DeviceBUSParam->SPEED | USB_DeviceBUSParam->MODE | USB_SC_SCGEN_Set);
00075c  e9d41201          LDRD     r1,r2,[r4,#4]
000760  4311              ORRS     r1,r1,r2
000762  f0410001          ORR      r0,r1,#1
000766  f7fffffe          BL       USB_SetSC
;;;823      /* Setup EP0 */
;;;824      USB_EP_Init(USB_EP0, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1, 0);
00076a  2200              MOVS     r2,#0
00076c  2105              MOVS     r1,#5
00076e  4610              MOV      r0,r2
000770  f7fffffe          BL       USB_EP_Init
;;;825      USB_EP_setSetupHandler(USB_EP0, &USB_CurrentSetupPacket, USB_DEVICE_HANDLE_SETUP);
000774  f2af228d          ADR      r2,USB_DeviceSetupPacket + 1
000778  4942              LDR      r1,|L1.2180|
00077a  2000              MOVS     r0,#0
00077c  f7fffffe          BL       USB_EP_setSetupHandler
;;;826    
;;;827      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
000780  2000              MOVS     r0,#0
000782  493c              LDR      r1,|L1.2164|
000784  7008              STRB     r0,[r1,#0]
;;;828      USB_DeviceContext.Address = 0;
000786  6088              STR      r0,[r1,#8]  ; USB_DeviceContext
;;;829    
;;;830      return USB_SUCCESS;
;;;831    }
000788  bd70              POP      {r4-r6,pc}
;;;832    
                          ENDP

                  USB_DevicePowerOn PROC
;;;840    
;;;841    USB_Result USB_DevicePowerOn(void)
00078a  b510              PUSH     {r4,lr}
;;;842    {
;;;843      USB_SetHSCR(USB_HSCR_EN_RX_Set | USB_HSCR_EN_TX_Set);
00078c  200c              MOVS     r0,#0xc
00078e  f7fffffe          BL       USB_SetHSCR
;;;844      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_POWERED;
000792  2002              MOVS     r0,#2
000794  4937              LDR      r1,|L1.2164|
000796  7008              STRB     r0,[r1,#0]
;;;845    
;;;846      return USB_SUCCESS;
000798  2000              MOVS     r0,#0
;;;847    }
00079a  bd10              POP      {r4,pc}
;;;848    
                          ENDP

                  USB_DevicePowerOff PROC
;;;856    
;;;857    USB_Result USB_DevicePowerOff(void)
00079c  b510              PUSH     {r4,lr}
;;;858    {
;;;859      USB_SetHSCR(USB_HSCR_EN_RX_Reset);
00079e  f44f2000          MOV      r0,#0x80000
0007a2  f7fffffe          BL       USB_SetHSCR
;;;860      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_UNKNOWN;
0007a6  2000              MOVS     r0,#0
0007a8  4932              LDR      r1,|L1.2164|
0007aa  7008              STRB     r0,[r1,#0]
;;;861    
;;;862      return USB_SUCCESS;
;;;863    }
0007ac  bd10              POP      {r4,pc}
;;;864    
                          ENDP

                  USB_DeviceReset PROC
;;;891    
;;;892    USB_Result USB_DeviceReset(void)
0007ae  2003              MOVS     r0,#3
;;;893    {
;;;894      USB_DeviceContext.USB_DeviceState = USB_DEV_STATE_DEFAULT;
0007b0  4930              LDR      r1,|L1.2164|
0007b2  7008              STRB     r0,[r1,#0]
;;;895      return USB_SUCCESS;
0007b4  2000              MOVS     r0,#0
;;;896    }
0007b6  4770              BX       lr
;;;897    
                          ENDP

                  USB_DeviceSuspend PROC
;;;905    
;;;906    USB_Result USB_DeviceSuspend(void)
0007b8  2000              MOVS     r0,#0
;;;907    {
;;;908      return USB_SUCCESS;
;;;909    }
0007ba  4770              BX       lr
;;;910    
                          ENDP

                  USB_DeviceResume PROC
;;;918    
;;;919    USB_Result USB_DeviceResume(void)
0007bc  2000              MOVS     r0,#0
;;;920    {
;;;921      return USB_SUCCESS;
;;;922    }
0007be  4770              BX       lr
;;;923    
                          ENDP

                  USB_DeviceDoStatusInAck PROC
;;;1242   
;;;1243   USB_Result USB_DeviceDoStatusInAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
0007c0  4603              MOV      r3,r0
;;;1244   {
;;;1245     return USB_SUCCESS;
0007c2  2000              MOVS     r0,#0
;;;1246   }
0007c4  4770              BX       lr
;;;1247   
                          ENDP

                  USB_DeviceDoStatusOutAck PROC
;;;1265   
;;;1266   USB_Result USB_DeviceDoStatusOutAck(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
0007c6  b570              PUSH     {r4-r6,lr}
;;;1267   {
0007c8  4604              MOV      r4,r0
0007ca  460d              MOV      r5,r1
0007cc  4616              MOV      r6,r2
;;;1268     return USB_EP_doDataOut(EPx, 0, 0, 0);
0007ce  2300              MOVS     r3,#0
0007d0  461a              MOV      r2,r3
0007d2  4619              MOV      r1,r3
0007d4  4620              MOV      r0,r4
0007d6  f7fffffe          BL       USB_EP_doDataOut
;;;1269   }
0007da  bd70              POP      {r4-r6,pc}
;;;1270   
                          ENDP

                  USB_DeviceDispatchEvent PROC
;;;1313   
;;;1314   USB_Result USB_DeviceDispatchEvent(void)
0007dc  b570              PUSH     {r4-r6,lr}
;;;1315   {
;;;1316     uint32_t i;
;;;1317     uint32_t USB_IT;
;;;1318     USB_Result result = USB_SUCCESS;
0007de  2600              MOVS     r6,#0
;;;1319     static volatile uint32_t bHandling = RESET;
;;;1320   
;;;1321     /* Disable USB interrupts */
;;;1322   #ifdef USB_INT_HANDLE_REQUIRED
;;;1323     NVIC_DisableIRQ(USB_IRQn);
0007e0  2002              MOVS     r0,#2
0007e2  2101              MOVS     r1,#1
0007e4  4081              LSLS     r1,r1,r0
0007e6  4a28              LDR      r2,|L1.2184|
0007e8  0943              LSRS     r3,r0,#5
0007ea  f8421023          STR      r1,[r2,r3,LSL #2]
0007ee  bf00              NOP      
;;;1324   #endif /* USB_INT_HANDLE_REQUIRED */
;;;1325   
;;;1326     if (!bHandling) {
0007f0  4826              LDR      r0,|L1.2188|
0007f2  6800              LDR      r0,[r0,#0]  ; bHandling
0007f4  bb38              CBNZ     r0,|L1.2118|
;;;1327       bHandling = SET;
0007f6  2001              MOVS     r0,#1
0007f8  4924              LDR      r1,|L1.2188|
0007fa  6008              STR      r0,[r1,#0]  ; bHandling
;;;1328   
;;;1329       /* Get masked interrupt flags */
;;;1330       USB_IT = USB_GetSIS();
0007fc  f7fffffe          BL       USB_GetSIS
000800  4604              MOV      r4,r0
;;;1331       /* Handle reset */
;;;1332       if (USB_IT & USB_SIS_SCRESETEV)
000802  f0140f04          TST      r4,#4
000806  d002              BEQ      |L1.2062|
;;;1333       {
;;;1334         result = USB_DeviceReset();
000808  f7fffffe          BL       USB_DeviceReset
00080c  4606              MOV      r6,r0
                  |L1.2062|
;;;1335       }
;;;1336   
;;;1337       /* Invoke End Point dispatchers */
;;;1338       for (i = USB_EP0; i < Num_USB_EndPoints; i++)
00080e  2500              MOVS     r5,#0
000810  e004              B        |L1.2076|
                  |L1.2066|
;;;1339       {
;;;1340         USB_EP_dispatchEvent((USB_EP_TypeDef)i, USB_IT);
000812  b2e8              UXTB     r0,r5
000814  4621              MOV      r1,r4
000816  f7fffffe          BL       USB_EP_dispatchEvent
00081a  1c6d              ADDS     r5,r5,#1              ;1338
                  |L1.2076|
00081c  2d04              CMP      r5,#4                 ;1338
00081e  d3f8              BCC      |L1.2066|
;;;1341       }
;;;1342   
;;;1343       /* Clear pending bits, except for SCTDONE */
;;;1344       USB_SetSIS(USB_IT & (~USB_SIS_SCTDONE_Set));
000820  f0240001          BIC      r0,r4,#1
000824  f7fffffe          BL       USB_SetSIS
;;;1345   
;;;1346       bHandling = RESET;
000828  2000              MOVS     r0,#0
00082a  4918              LDR      r1,|L1.2188|
00082c  6008              STR      r0,[r1,#0]  ; bHandling
;;;1347   
;;;1348       /* Enable USB interrupts (only after the actual work is done) */
;;;1349   #ifdef USB_INT_HANDLE_REQUIRED
;;;1350       NVIC_EnableIRQ(USB_IRQn);
00082e  2002              MOVS     r0,#2
000830  2101              MOVS     r1,#1
000832  4081              LSLS     r1,r1,r0
000834  0942              LSRS     r2,r0,#5
000836  f04f23e0          MOV      r3,#0xe000e000
00083a  eb030282          ADD      r2,r3,r2,LSL #2
00083e  f8c21100          STR      r1,[r2,#0x100]
000842  bf00              NOP      
000844  bf00              NOP      
                  |L1.2118|
;;;1351   #endif /* USB_INT_HANDLE_REQUIRED */
;;;1352     }
;;;1353     return result;
000846  4630              MOV      r0,r6
;;;1354   }
000848  bd70              POP      {r4-r6,pc}
;;;1355   
                          ENDP

                  USB_IRQHandler PROC
;;;1368   
;;;1369   void USB_IRQHandler(void)
00084a  b510              PUSH     {r4,lr}
;;;1370   {
;;;1371     USB_DeviceDispatchEvent();
00084c  f7fffffe          BL       USB_DeviceDispatchEvent
;;;1372   }
000850  bd10              POP      {r4,pc}
;;;1373   #endif /* USB_INT_HANDLE_REQUIRED */
                          ENDP

                  USB_DeviceDummyGetStatus PROC
;;;1397   
;;;1398   USB_Result USB_DeviceDummyGetStatus(USB_RequestRecipient_TypeDef Recipient, uint16_t wINDEX)
000852  4602              MOV      r2,r0
;;;1399   {
;;;1400     return USB_SUCCESS;
000854  2000              MOVS     r0,#0
;;;1401   }
000856  4770              BX       lr
;;;1402   
                          ENDP

                  USB_DeviceDummySetAddress PROC
;;;1414   
;;;1415   USB_Result USB_DeviceDummySetAddress(uint16_t wVALUE)
000858  4601              MOV      r1,r0
;;;1416   {
;;;1417     return USB_SUCCESS;
00085a  2000              MOVS     r0,#0
;;;1418   }
00085c  4770              BX       lr
;;;1419   
                          ENDP

                  USB_DeviceDummyGetDescriptor PROC
;;;1436   
;;;1437   USB_Result USB_DeviceDummyGetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
00085e  4603              MOV      r3,r0
;;;1438   {
;;;1439     return USB_ERROR;
000860  2001              MOVS     r0,#1
;;;1440   }
000862  4770              BX       lr
;;;1441   
                          ENDP

                  USB_DeviceDummySetDescriptor PROC
;;;1458   
;;;1459   USB_Result USB_DeviceDummySetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
000864  4603              MOV      r3,r0
;;;1460   {
;;;1461     return USB_ERROR;
000866  2001              MOVS     r0,#1
;;;1462   }
000868  4770              BX       lr
;;;1463   
                          ENDP

                  USB_DeviceDummyGetConfiguration PROC
;;;1474   
;;;1475   uint8_t USB_DeviceDummyGetConfiguration(void)
00086a  2001              MOVS     r0,#1
;;;1476   {
;;;1477     return 1;
;;;1478   }
00086c  4770              BX       lr
;;;1479   
                          ENDP

                  USB_DeviceDummySetConfiguration PROC
;;;1490   
;;;1491   USB_Result USB_DeviceDummySetConfiguration(uint16_t wVALUE)
00086e  4601              MOV      r1,r0
;;;1492   {
;;;1493     return USB_ERROR;
000870  2001              MOVS     r0,#1
;;;1494   }
000872  4770              BX       lr
                  |L1.2164|
                          DCD      USB_DeviceContext
                  |L1.2168|
                          DCD      SetupPacketData
                  |L1.2172|
                          DCD      USB_EPContext
                  |L1.2176|
                          DCD      USB_Device_setAddressWork
                  |L1.2180|
                          DCD      USB_CurrentSetupPacket
                  |L1.2184|
                          DCD      0xe000e180
                  |L1.2188|
                          DCD      bHandling
                          ENDP

                  USB_DeviceDummyGetInterface PROC
;;;1507   
;;;1508   uint8_t USB_DeviceDummyGetInterface(uint16_t wINDEX)
000890  4601              MOV      r1,r0
;;;1509   {
;;;1510     return 0;
000892  2000              MOVS     r0,#0
;;;1511   }
000894  4770              BX       lr
;;;1512   
                          ENDP

                  USB_DeviceDummySetInterface PROC
;;;1525   
;;;1526   USB_Result USB_DeviceDummySetInterface(uint16_t wVALUE, uint16_t wINDEX)
000896  4602              MOV      r2,r0
;;;1527   {
;;;1528     return USB_SUCCESS;
000898  2000              MOVS     r0,#0
;;;1529   }
00089a  4770              BX       lr
;;;1530   
                          ENDP

                  USB_DeviceDummySyncFrame PROC
;;;1545   
;;;1546   USB_Result USB_DeviceDummySyncFrame(uint16_t wINDEX, uint8_t* DATA)
00089c  4602              MOV      r2,r0
;;;1547   {
;;;1548     return USB_ERROR;
00089e  2001              MOVS     r0,#1
;;;1549   }
0008a0  4770              BX       lr
;;;1550   
                          ENDP

                  USB_DeviceDummyClassRequest PROC
;;;1563   
;;;1564   USB_Result USB_DeviceDummyClassRequest(void)
0008a2  2001              MOVS     r0,#1
;;;1565   {
;;;1566     return USB_ERROR;
;;;1567   }
0008a4  4770              BX       lr
;;;1568   
                          ENDP

                  USB_DeviceDummyVendorRequest PROC
;;;1582   
;;;1583   USB_Result USB_DeviceDummyVendorRequest(void)
0008a6  2001              MOVS     r0,#1
;;;1584   {
;;;1585     return USB_ERROR;
;;;1586   }
0008a8  4770              BX       lr
;;;1587   
                          ENDP

                  USB_DeviceDummyDataError PROC
;;;1611   
;;;1612   USB_Result USB_DeviceDummyDataError(USB_EP_TypeDef EPx, uint32_t STS, uint32_t TS, uint32_t CTRL)
0008aa  b510              PUSH     {r4,lr}
;;;1613   {
0008ac  4604              MOV      r4,r0
;;;1614     return USB_ERROR;
0008ae  2001              MOVS     r0,#1
;;;1615   }
0008b0  bd10              POP      {r4,pc}
;;;1616   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_EPContext
                          %        176
                  USB_DeviceContext
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  bHandling
                          DCD      0x00000000
                  USB_CurrentSetupPacket
                          %        8
                  SetupPacketData
00000c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\USB_Library\\MDR32F9Qx_usb_device.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___22_MDR32F9Qx_usb_device_c_abd3a94f____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___22_MDR32F9Qx_usb_device_c_abd3a94f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___22_MDR32F9Qx_usb_device_c_abd3a94f____REVSH|
#line 144
|__asm___22_MDR32F9Qx_usb_device_c_abd3a94f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
