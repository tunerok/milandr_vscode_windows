; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_uart.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_uart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_uart.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;82       */
;;;83     void UART_DeInit(MDR_UART_TypeDef* UARTx)
000000  2100              MOVS     r1,#0
;;;84     {
;;;85       /* Check the parameters */
;;;86       assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;87     
;;;88       /* Clear UART CR */
;;;89       UARTx->CR = 0;
000002  6301              STR      r1,[r0,#0x30]
;;;90       UARTx->LCR_H = 0;
000004  62c1              STR      r1,[r0,#0x2c]
;;;91       UARTx->RSR_ECR = 0;
000006  6041              STR      r1,[r0,#4]
;;;92       UARTx->FR = UART_FLAG_TXFE | UART_FLAG_RXFE;
000008  2190              MOVS     r1,#0x90
00000a  6181              STR      r1,[r0,#0x18]
;;;93       UARTx->ILPR = 0;
00000c  2100              MOVS     r1,#0
00000e  6201              STR      r1,[r0,#0x20]
;;;94       UARTx->IBRD = 0;
000010  6241              STR      r1,[r0,#0x24]
;;;95       UARTx->FBRD = 0;
000012  6281              STR      r1,[r0,#0x28]
;;;96       UARTx->IFLS = UART_IT_FIFO_LVL_8words;
000014  2102              MOVS     r1,#2
000016  6341              STR      r1,[r0,#0x34]
;;;97       UARTx->IMSC = 0;
000018  2100              MOVS     r1,#0
00001a  6381              STR      r1,[r0,#0x38]
;;;98       UARTx->DMACR = 0;
00001c  6481              STR      r1,[r0,#0x48]
;;;99       /* Set UART CR[RXE] and UART CR[TXE] bits */
;;;100      UARTx->CR = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
00001e  f44f7140          MOV      r1,#0x300
000022  6301              STR      r1,[r0,#0x30]
;;;101    }
000024  4770              BX       lr
;;;102    
                          ENDP

                  UART_Init PROC
;;;112      */
;;;113    BaudRateStatus UART_Init ( MDR_UART_TypeDef* UARTx,
000026  e92d4ff0          PUSH     {r4-r11,lr}
;;;114    						   UART_InitTypeDef* UART_InitStruct )
;;;115    {
00002a  b087              SUB      sp,sp,#0x1c
00002c  4604              MOV      r4,r0
00002e  460d              MOV      r5,r1
;;;116    	uint32_t tmpreg, cpuclock;
;;;117    	uint32_t realspeed, speederror;
;;;118    	uint32_t divider;
;;;119    	uint32_t integerdivider;
;;;120    	uint32_t fractionaldivider;
;;;121    	RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;122    
;;;123    	/* Check the parameters */
;;;124    	assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;125    	assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));
;;;126    	assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLength));
;;;127    	assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
;;;128    	assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
;;;129    	assert_param(IS_UART_FIFOMODE(UART_InitStruct->UART_FIFOMode));
;;;130    	assert_param(IS_UART_HARDWARE_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
;;;131    
;;;132    	/* Configure the UART Baud Rate */
;;;133    	RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
000030  a801              ADD      r0,sp,#4
000032  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;134    	cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
000036  9f01              LDR      r7,[sp,#4]
;;;135    #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;136    	if(( UARTx == MDR_UART3 ) || (UARTx == MDR_UART4))
;;;137    		tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;138    	else
;;;139    		if(( UARTx == MDR_UART1 ) || (UARTx == MDR_UART2))
;;;140    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;141    			tmpreg = MDR_RST_CLK->UART_CLOCK;
000038  4870              LDR      r0,|L1.508|
00003a  6a86              LDR      r6,[r0,#0x28]
;;;142    
;;;143    	if (UARTx == MDR_UART1) {
00003c  4870              LDR      r0,|L1.512|
00003e  4284              CMP      r4,r0
000040  d106              BNE      |L1.80|
;;;144    		cpuclock /= (1 << (tmpreg & UART1_BRG_Mask));
000042  f0060107          AND      r1,r6,#7
000046  2001              MOVS     r0,#1
000048  4088              LSLS     r0,r0,r1
00004a  fbb7f7f0          UDIV     r7,r7,r0
00004e  e008              B        |L1.98|
                  |L1.80|
;;;145    	}
;;;146    	else
;;;147    		if (UARTx == MDR_UART2) {
000050  486c              LDR      r0,|L1.516|
000052  4284              CMP      r4,r0
000054  d105              BNE      |L1.98|
;;;148    			cpuclock /= (1 << ((tmpreg & UART2_BRG_Mask) >> UART2_BRG_Offs));
000056  f3c62102          UBFX     r1,r6,#8,#3
00005a  2001              MOVS     r0,#1
00005c  4088              LSLS     r0,r0,r1
00005e  fbb7f7f0          UDIV     r7,r7,r0
                  |L1.98|
;;;149    		}
;;;150    #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;151    		else
;;;152    			if(UARTx == MDR_UART3) {
;;;153    				cpuclock /= (1 << (tmpreg & UART3_BRG_Mask ));
;;;154    			}
;;;155    			else
;;;156    				if(UARTx == MDR_UART4) {
;;;157    					cpuclock /= (1 << ((tmpreg & UART4_BRG_Mask) >> UART4_BRG_Offs));
;;;158    				}
;;;159    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;160    
;;;161    	/* Determine the integer part */
;;;162    	divider = cpuclock / (UART_InitStruct->UART_BaudRate >> 2);
000062  6828              LDR      r0,[r5,#0]
000064  0880              LSRS     r0,r0,#2
000066  fbb7f9f0          UDIV     r9,r7,r0
;;;163    	integerdivider = divider >> 6;
00006a  ea4f1899          LSR      r8,r9,#6
;;;164    	/* Determine the fractional part */
;;;165    	fractionaldivider = (divider & FBRD_Fract_Mask);
00006e  f0090a3f          AND      r10,r9,#0x3f
;;;166    	/* Determine the speed error */
;;;167    	realspeed = (cpuclock * 4) / ((integerdivider * 64) + fractionaldivider);
000072  00b8              LSLS     r0,r7,#2
000074  eb0a1188          ADD      r1,r10,r8,LSL #6
000078  fbb0fbf1          UDIV     r11,r0,r1
;;;168    	speederror = ((realspeed - UART_InitStruct->UART_BaudRate) * 128)
00007c  6828              LDR      r0,[r5,#0]
00007e  ebab0000          SUB      r0,r11,r0
000082  01c0              LSLS     r0,r0,#7
000084  6829              LDR      r1,[r5,#0]
000086  fbb0f0f1          UDIV     r0,r0,r1
00008a  9006              STR      r0,[sp,#0x18]
;;;169    			/ UART_InitStruct->UART_BaudRate;
;;;170    	if (speederror > 2) {
00008c  9806              LDR      r0,[sp,#0x18]
00008e  2802              CMP      r0,#2
000090  d903              BLS      |L1.154|
;;;171    		return BaudRateInvalid;
000092  2000              MOVS     r0,#0
                  |L1.148|
;;;172    	}
;;;173    	/* Write UART Baud Rate */
;;;174    	UARTx->IBRD = integerdivider;
;;;175    	UARTx->FBRD = fractionaldivider;
;;;176    
;;;177    	/* UART LCR_H configuration */
;;;178    	/* Set the WLEN bits according to UART_WordLength value */
;;;179    	/* Set STP2 bit according to UART_StopBits value */
;;;180    	/* Set PEN, EPS and SPS bits according to UART_Parity value */
;;;181    	/* Set FEN bit according to UART_FIFOMode value */
;;;182    	tmpreg = UARTx->LCR_H;
;;;183    	tmpreg |= UART_InitStruct->UART_WordLength | UART_InitStruct->UART_StopBits
;;;184    			| UART_InitStruct->UART_Parity | UART_InitStruct->UART_FIFOMode;
;;;185    	UARTx->LCR_H = tmpreg;
;;;186    
;;;187    	/* UART CR configuration */
;;;188    	tmpreg = UARTx->CR;
;;;189    	/* Clear UART CR Flow control bits */
;;;190    	tmpreg &= ~CR_FC_Mask;
;;;191    	/* Set UART CR Flow control bits */
;;;192    	tmpreg |= UART_InitStruct->UART_HardwareFlowControl;
;;;193    	/* Write to UART CR */
;;;194    	UARTx->CR = tmpreg;
;;;195    
;;;196    	return BaudRateValid;
;;;197    }
000094  b007              ADD      sp,sp,#0x1c
000096  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.154|
00009a  f8c48024          STR      r8,[r4,#0x24]         ;174
00009e  f8c4a028          STR      r10,[r4,#0x28]        ;175
0000a2  6ae6              LDR      r6,[r4,#0x2c]         ;182
0000a4  88a8              LDRH     r0,[r5,#4]            ;183
0000a6  88e9              LDRH     r1,[r5,#6]            ;183
0000a8  4308              ORRS     r0,r0,r1              ;183
0000aa  8929              LDRH     r1,[r5,#8]            ;183
0000ac  4308              ORRS     r0,r0,r1              ;183
0000ae  8969              LDRH     r1,[r5,#0xa]          ;183
0000b0  4308              ORRS     r0,r0,r1              ;183
0000b2  4306              ORRS     r6,r6,r0              ;183
0000b4  62e6              STR      r6,[r4,#0x2c]         ;185
0000b6  6b26              LDR      r6,[r4,#0x30]         ;188
0000b8  f64f7080          MOV      r0,#0xff80            ;190
0000bc  4386              BICS     r6,r6,r0              ;190
0000be  89a8              LDRH     r0,[r5,#0xc]          ;192
0000c0  4306              ORRS     r6,r6,r0              ;192
0000c2  6326              STR      r6,[r4,#0x30]         ;194
0000c4  2001              MOVS     r0,#1                 ;196
0000c6  e7e5              B        |L1.148|
;;;198    
                          ENDP

                  UART_StructInit PROC
;;;204      */
;;;205    void UART_StructInit(UART_InitTypeDef* UART_InitStruct)
0000c8  f44f5116          MOV      r1,#0x2580
;;;206    {
;;;207      /* UART_InitStruct members default value */
;;;208      UART_InitStruct->UART_BaudRate = 9600;
0000cc  6001              STR      r1,[r0,#0]
;;;209      UART_InitStruct->UART_WordLength = UART_WordLength5b;
0000ce  2100              MOVS     r1,#0
0000d0  8081              STRH     r1,[r0,#4]
;;;210      UART_InitStruct->UART_StopBits = UART_StopBits1;
0000d2  80c1              STRH     r1,[r0,#6]
;;;211      UART_InitStruct->UART_Parity = UART_Parity_No;
0000d4  8101              STRH     r1,[r0,#8]
;;;212      UART_InitStruct->UART_FIFOMode = UART_FIFO_OFF;
0000d6  8141              STRH     r1,[r0,#0xa]
;;;213      UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
0000d8  f44f7140          MOV      r1,#0x300
0000dc  8181              STRH     r1,[r0,#0xc]
;;;214    }
0000de  4770              BX       lr
;;;215    
                          ENDP

                  UART_Cmd PROC
;;;224      */
;;;225    void UART_Cmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
0000e0  b121              CBZ      r1,|L1.236|
;;;226    {
;;;227      /* Check the parameters */
;;;228      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;229      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;230    
;;;231      if (NewState != DISABLE)
;;;232      {
;;;233        /* Enable the selected UART by setting the UARTEN bit in the CR register */
;;;234        UARTx->CR |= CR_EN_Set;
0000e2  6b02              LDR      r2,[r0,#0x30]
0000e4  f0420201          ORR      r2,r2,#1
0000e8  6302              STR      r2,[r0,#0x30]
0000ea  e004              B        |L1.246|
                  |L1.236|
;;;235      }
;;;236      else
;;;237      {
;;;238        /* Disable the selected UART by clearing the UARTEN bit in the CR register */
;;;239        UARTx->CR &= CR_EN_Reset;
0000ec  6b02              LDR      r2,[r0,#0x30]
0000ee  f64f73fe          MOV      r3,#0xfffe
0000f2  401a              ANDS     r2,r2,r3
0000f4  6302              STR      r2,[r0,#0x30]
                  |L1.246|
;;;240      }
;;;241    }
0000f6  4770              BX       lr
;;;242    
                          ENDP

                  UART_ITConfig PROC
;;;264      */
;;;265    void UART_ITConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT, FunctionalState NewState)
0000f8  b11a              CBZ      r2,|L1.258|
;;;266    {
;;;267      /* Check the parameters */
;;;268      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;269      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;270      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;271    
;;;272      if (NewState != DISABLE)
;;;273      {
;;;274        UARTx->IMSC |= UART_IT;
0000fa  6b83              LDR      r3,[r0,#0x38]
0000fc  430b              ORRS     r3,r3,r1
0000fe  6383              STR      r3,[r0,#0x38]
000100  e002              B        |L1.264|
                  |L1.258|
;;;275      }
;;;276      else
;;;277      {
;;;278        UARTx->IMSC &= ~UART_IT;
000102  6b83              LDR      r3,[r0,#0x38]
000104  438b              BICS     r3,r3,r1
000106  6383              STR      r3,[r0,#0x38]
                  |L1.264|
;;;279      }
;;;280    }
000108  4770              BX       lr
;;;281    
                          ENDP

                  UART_GetITStatus PROC
;;;301      */
;;;302    ITStatus UART_GetITStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
00010a  4602              MOV      r2,r0
;;;303    {
;;;304      ITStatus bitstatus;
;;;305    
;;;306      /* Check the parameters */
;;;307      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;308      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;309    
;;;310      if ((UARTx->RIS & UART_IT) == UART_IT)
00010c  6bd3              LDR      r3,[r2,#0x3c]
00010e  400b              ANDS     r3,r3,r1
000110  428b              CMP      r3,r1
000112  d101              BNE      |L1.280|
;;;311      {
;;;312        bitstatus = SET;
000114  2001              MOVS     r0,#1
000116  e000              B        |L1.282|
                  |L1.280|
;;;313      }
;;;314      else
;;;315      {
;;;316        bitstatus = RESET;
000118  2000              MOVS     r0,#0
                  |L1.282|
;;;317      }
;;;318    
;;;319      return bitstatus;
;;;320    }
00011a  4770              BX       lr
;;;321    
                          ENDP

                  UART_GetITStatusMasked PROC
;;;341      */
;;;342    ITStatus UART_GetITStatusMasked(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
00011c  4602              MOV      r2,r0
;;;343    {
;;;344      ITStatus bitstatus;
;;;345    
;;;346      /* Check the parameters */
;;;347      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;348      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;349    
;;;350      if (UARTx->MIS & UART_IT)
00011e  6c13              LDR      r3,[r2,#0x40]
000120  420b              TST      r3,r1
000122  d001              BEQ      |L1.296|
;;;351      {
;;;352        bitstatus = SET;
000124  2001              MOVS     r0,#1
000126  e000              B        |L1.298|
                  |L1.296|
;;;353      }
;;;354      else
;;;355      {
;;;356        bitstatus = RESET;
000128  2000              MOVS     r0,#0
                  |L1.298|
;;;357      }
;;;358    
;;;359      return bitstatus;
;;;360    }
00012a  4770              BX       lr
;;;361    
                          ENDP

                  UART_ClearITPendingBit PROC
;;;381      */
;;;382    void UART_ClearITPendingBit(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
00012c  6c42              LDR      r2,[r0,#0x44]
;;;383    {
;;;384      /* Check the parameters */
;;;385      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;386      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;387    
;;;388      UARTx->ICR |= UART_IT;
00012e  430a              ORRS     r2,r2,r1
000130  6442              STR      r2,[r0,#0x44]
;;;389    }
000132  4770              BX       lr
;;;390    
                          ENDP

                  UART_DMAConfig PROC
;;;411      */
;;;412    void UART_DMAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT_RB_LVL, uint32_t UART_IT_TB_LVL)
000134  ea4203c1          ORR      r3,r2,r1,LSL #3
;;;413    {
;;;414      /* Check the parameters */
;;;415      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;416      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_RB_LVL));
;;;417      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_TB_LVL));
;;;418    
;;;419      UARTx->IFLS = (UART_IT_RB_LVL << 3) | UART_IT_TB_LVL;
000138  6343              STR      r3,[r0,#0x34]
;;;420    }
00013a  4770              BX       lr
;;;421    
                          ENDP

                  UART_DMACmd PROC
;;;436      */
;;;437    void UART_DMACmd(MDR_UART_TypeDef* UARTx, uint32_t UART_DMAReq, FunctionalState NewState)
00013c  b510              PUSH     {r4,lr}
;;;438    {
;;;439      /* Check the parameters */
;;;440      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;441      assert_param(IS_UART_DMAREQ(UART_DMAReq));
;;;442      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;443    
;;;444      if (NewState != DISABLE)
00013e  b11a              CBZ      r2,|L1.328|
;;;445      {
;;;446        /* Enable the DMA transfer for selected requests and DMAONERR bit
;;;447           in the UART DMACR register */
;;;448        UARTx->DMACR |= UART_DMAReq;
000140  6c83              LDR      r3,[r0,#0x48]
000142  430b              ORRS     r3,r3,r1
000144  6483              STR      r3,[r0,#0x48]
000146  e004              B        |L1.338|
                  |L1.328|
;;;449      }
;;;450      else
;;;451      {
;;;452        /* Disable the DMA transfer for selected requests and DMAONERR bit
;;;453           in the UART DMACR register */
;;;454        UARTx->DMACR &= (uint16_t)~UART_DMAReq;
000148  6c83              LDR      r3,[r0,#0x48]
00014a  43cc              MVNS     r4,r1
00014c  b2a4              UXTH     r4,r4
00014e  4023              ANDS     r3,r3,r4
000150  6483              STR      r3,[r0,#0x48]
                  |L1.338|
;;;455      }
;;;456    }
000152  bd10              POP      {r4,pc}
;;;457    
                          ENDP

                  UART_SendData PROC
;;;465      */
;;;466    void UART_SendData(MDR_UART_TypeDef* UARTx, uint16_t Data)
000154  b2ca              UXTB     r2,r1
;;;467    {
;;;468      /* Check the parameters */
;;;469      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;470      assert_param(IS_UART_DATA(Data));
;;;471    
;;;472      /* Transmit Data */
;;;473      UARTx->DR = (Data & (uint16_t)0x0FF);
000156  6002              STR      r2,[r0,#0]
;;;474    }
000158  4770              BX       lr
;;;475    
                          ENDP

                  UART_ReceiveData PROC
;;;482      */
;;;483    uint16_t UART_ReceiveData(MDR_UART_TypeDef* UARTx)
00015a  4601              MOV      r1,r0
;;;484    {
;;;485      /* Check the parameters */
;;;486      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;487    
;;;488      /* Receive Data */
;;;489      return (uint16_t)(UARTx->DR);
00015c  6808              LDR      r0,[r1,#0]
00015e  b280              UXTH     r0,r0
;;;490    }
000160  4770              BX       lr
;;;491    
                          ENDP

                  UART_BreakLine PROC
;;;500      */
;;;501    void UART_BreakLine(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000162  b121              CBZ      r1,|L1.366|
;;;502    {
;;;503      /* Check the parameters */
;;;504      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;505      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;506    
;;;507      if (NewState != DISABLE)
;;;508      {
;;;509        /* Set BRK bit in the UART LCR_H register */
;;;510        UARTx->LCR_H |= LCR_H_BRK_Set;
000164  6ac2              LDR      r2,[r0,#0x2c]
000166  f0420201          ORR      r2,r2,#1
00016a  62c2              STR      r2,[r0,#0x2c]
00016c  e004              B        |L1.376|
                  |L1.366|
;;;511      }
;;;512      else
;;;513      {
;;;514        /* Reset BRK bit in the UART LCR_H register */
;;;515        UARTx->LCR_H |= LCR_H_BRK_Reset;
00016e  6ac2              LDR      r2,[r0,#0x2c]
000170  f64f73fe          MOV      r3,#0xfffe
000174  431a              ORRS     r2,r2,r3
000176  62c2              STR      r2,[r0,#0x2c]
                  |L1.376|
;;;516      }
;;;517    }
000178  4770              BX       lr
;;;518    
                          ENDP

                  UART_IrDAConfig PROC
;;;529      */
;;;530    void UART_IrDAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IrDAMode)
00017a  b570              PUSH     {r4-r6,lr}
;;;531    {
00017c  b086              SUB      sp,sp,#0x18
00017e  4604              MOV      r4,r0
000180  460d              MOV      r5,r1
;;;532      uint32_t cpuclock;
;;;533      RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;534    
;;;535      /* Check the parameters */
;;;536      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;537      assert_param(IS_UART_IRDA_MODE(UART_IrDAMode));
;;;538    
;;;539      if (UART_IrDAMode == UART_IrDAMode_LowPower)
000182  2d04              CMP      r5,#4
000184  d108              BNE      |L1.408|
;;;540      {
;;;541        /* Configure the UART ILPR */
;;;542        RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
000186  a801              ADD      r0,sp,#4
000188  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;543        cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
00018c  9e01              LDR      r6,[sp,#4]
;;;544        UARTx->ILPR = cpuclock / IrLPBaud16;
00018e  f44f10e1          MOV      r0,#0x1c2000
000192  fbb6f0f0          UDIV     r0,r6,r0
000196  6220              STR      r0,[r4,#0x20]
                  |L1.408|
;;;545      }
;;;546      UARTx->CR |= UART_IrDAMode;
000198  6b20              LDR      r0,[r4,#0x30]
00019a  4328              ORRS     r0,r0,r5
00019c  6320              STR      r0,[r4,#0x30]
;;;547    }
00019e  b006              ADD      sp,sp,#0x18
0001a0  bd70              POP      {r4-r6,pc}
;;;548    
                          ENDP

                  UART_IrDACmd PROC
;;;557      */
;;;558    void UART_IrDACmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
0001a2  b121              CBZ      r1,|L1.430|
;;;559    {
;;;560      /* Check the parameters */
;;;561      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;562      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;563    
;;;564      if (NewState != DISABLE)
;;;565      {
;;;566        /* Set SIREN bit in the UART CR register */
;;;567        UARTx->CR |= CR_SIREN_Set;
0001a4  6b02              LDR      r2,[r0,#0x30]
0001a6  f0420202          ORR      r2,r2,#2
0001aa  6302              STR      r2,[r0,#0x30]
0001ac  e004              B        |L1.440|
                  |L1.430|
;;;568      }
;;;569      else
;;;570      {
;;;571        /* Reset SIREN bit in the UART CR register */
;;;572        UARTx->CR |= CR_SIREN_Reset;
0001ae  6b02              LDR      r2,[r0,#0x30]
0001b0  f64f73fd          MOV      r3,#0xfffd
0001b4  431a              ORRS     r2,r2,r3
0001b6  6302              STR      r2,[r0,#0x30]
                  |L1.440|
;;;573      }
;;;574    }
0001b8  4770              BX       lr
;;;575    
                          ENDP

                  UART_GetFlagStatus PROC
;;;593      */
;;;594    FlagStatus UART_GetFlagStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_FLAG)
0001ba  4602              MOV      r2,r0
;;;595    {
;;;596      FlagStatus bitstatus;
;;;597    
;;;598      /* Check the parameters */
;;;599      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;600      assert_param(IS_UART_FLAG(UART_FLAG));
;;;601    
;;;602      if (UARTx->FR & UART_FLAG)
0001bc  6993              LDR      r3,[r2,#0x18]
0001be  420b              TST      r3,r1
0001c0  d001              BEQ      |L1.454|
;;;603      {
;;;604        bitstatus = SET;
0001c2  2001              MOVS     r0,#1
0001c4  e000              B        |L1.456|
                  |L1.454|
;;;605      }
;;;606      else
;;;607      {
;;;608        bitstatus = RESET;
0001c6  2000              MOVS     r0,#0
                  |L1.456|
;;;609      }
;;;610      return bitstatus;
;;;611    }
0001c8  4770              BX       lr
;;;612    
                          ENDP

                  UART_BRGInit PROC
;;;630      */
;;;631    void UART_BRGInit(MDR_UART_TypeDef* UARTx, uint32_t UART_BRG)
0001ca  4602              MOV      r2,r0
;;;632    {
;;;633      uint32_t tmpreg;
;;;634    
;;;635      /* Check the parameters */
;;;636      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;637      assert_param(IS_UART_CLOCK_BRG(UART_BRG));
;;;638    
;;;639      tmpreg = MDR_RST_CLK->UART_CLOCK;
0001cc  4b0b              LDR      r3,|L1.508|
0001ce  6a98              LDR      r0,[r3,#0x28]
;;;640    
;;;641      if (UARTx == MDR_UART1)
0001d0  4b0b              LDR      r3,|L1.512|
0001d2  429a              CMP      r2,r3
0001d4  d105              BNE      |L1.482|
;;;642      {
;;;643        tmpreg |= RST_CLK_UART_CLOCK_UART1_CLK_EN;
0001d6  f0407080          ORR      r0,r0,#0x1000000
;;;644        tmpreg &= ~RST_CLK_UART_CLOCK_UART1_BRG_Msk;
0001da  f02000ff          BIC      r0,r0,#0xff
;;;645        tmpreg |= UART_BRG;
0001de  4308              ORRS     r0,r0,r1
0001e0  e008              B        |L1.500|
                  |L1.482|
;;;646      }
;;;647      else if (UARTx == MDR_UART2)
0001e2  4b08              LDR      r3,|L1.516|
0001e4  429a              CMP      r2,r3
0001e6  d105              BNE      |L1.500|
;;;648      {
;;;649        tmpreg |= RST_CLK_UART_CLOCK_UART2_CLK_EN;
0001e8  f0407000          ORR      r0,r0,#0x2000000
;;;650        tmpreg &= ~RST_CLK_UART_CLOCK_UART2_BRG_Msk;
0001ec  f420407f          BIC      r0,r0,#0xff00
;;;651        tmpreg |= (UART_BRG << 8);
0001f0  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.500|
;;;652      }
;;;653      MDR_RST_CLK->UART_CLOCK = tmpreg;
0001f4  4b01              LDR      r3,|L1.508|
0001f6  6298              STR      r0,[r3,#0x28]
;;;654    }
0001f8  4770              BX       lr
;;;655    
                          ENDP

0001fa  0000              DCW      0x0000
                  |L1.508|
                          DCD      0x40020000
                  |L1.512|
                          DCD      0x40030000
                  |L1.516|
                          DCD      0x40038000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH|
#line 144
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
