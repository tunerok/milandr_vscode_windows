; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_usb_cdc.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_usb_cdc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_usb_cdc.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\USB_Library\MDR32F9Qx_usb_CDC.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USB_CDC_SetReceiveBuffer PROC
;;;306    
;;;307    USB_Result USB_CDC_SetReceiveBuffer(uint8_t* ReceiveBuffer, uint32_t DataPortionLength)
000000  4602              MOV      r2,r0
;;;308    {
;;;309      /* Check the parameters */
;;;310      assert_param(ReceiveBuffer);
;;;311    
;;;312      USB_CDCContext.CDC_ReceiveBuffer = ReceiveBuffer;
000002  4890              LDR      r0,|L1.580|
000004  6002              STR      r2,[r0,#0]  ; USB_CDCContext
;;;313      USB_CDCContext.CDC_DataPortionLength = DataPortionLength;
000006  6041              STR      r1,[r0,#4]  ; USB_CDCContext
;;;314    
;;;315      return USB_SUCCESS;
000008  2000              MOVS     r0,#0
;;;316    }
00000a  4770              BX       lr
;;;317    
                          ENDP

                  USB_CDC_Init PROC
;;;281    
;;;282    USB_Result USB_CDC_Init(uint8_t* ReceiveBuffer, uint32_t DataPortionLength, FlagStatus StartReceiving)
00000c  b530              PUSH     {r4,r5,lr}
;;;283    {
00000e  4604              MOV      r4,r0
000010  460d              MOV      r5,r1
000012  4613              MOV      r3,r2
;;;284      USB_CDC_SetReceiveBuffer(ReceiveBuffer, DataPortionLength);
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USB_CDC_SetReceiveBuffer
;;;285      USB_CDCContext.CDC_SendDataStatus = USB_SUCCESS;
00001c  2000              MOVS     r0,#0
00001e  4989              LDR      r1,|L1.580|
000020  8108              STRH     r0,[r1,#8]
;;;286      USB_CDCContext.CDC_ReceiveDataStatus = StartReceiving ? USB_SUCCESS : USB_ERR_BUSY;
000022  b103              CBZ      r3,|L1.38|
000024  e001              B        |L1.42|
                  |L1.38|
000026  f44f7000          MOV      r0,#0x200
                  |L1.42|
00002a  4986              LDR      r1,|L1.580|
00002c  8148              STRH     r0,[r1,#0xa]
;;;287    
;;;288      return USB_SUCCESS;
00002e  2000              MOVS     r0,#0
;;;289    }
000030  bd30              POP      {r4,r5,pc}
;;;290    
                          ENDP

                  USB_CDC_OnDataReceive PROC
;;;655    
;;;656    static USB_Result USB_CDC_OnDataReceive(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
000032  e92d41f0          PUSH     {r4-r8,lr}
;;;657    {
000036  4607              MOV      r7,r0
000038  460c              MOV      r4,r1
00003a  4615              MOV      r5,r2
;;;658      /* Call user's handler */
;;;659      USB_Result result = USB_CDC_HANDLE_DATA_RECEIVE(Buffer, Length);
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       USB_CDC_RecieveData
000044  4606              MOV      r6,r0
;;;660    
;;;661      /* If handler returns USB_SUCCESS, wait for another portion. Otherwise, stop to receive
;;;662       * incoming data */
;;;663      if (result != USB_SUCCESS)
000046  b11e              CBZ      r6,|L1.80|
;;;664      {
;;;665        USB_CDCContext.CDC_ReceiveDataStatus = USB_ERR_BUSY;
000048  f44f7000          MOV      r0,#0x200
00004c  497d              LDR      r1,|L1.580|
00004e  8148              STRH     r0,[r1,#0xa]
                  |L1.80|
;;;666      }
;;;667      if (USB_CDCContext.CDC_ReceiveDataStatus == USB_SUCCESS)
000050  487c              LDR      r0,|L1.580|
000052  8940              LDRH     r0,[r0,#0xa]  ; USB_CDCContext
000054  b940              CBNZ     r0,|L1.104|
;;;668      {
;;;669        return USB_EP_doDataOut(USB_CDC_EP_RECEIVE, USB_CDCContext.CDC_ReceiveBuffer,
000056  487b              LDR      r0,|L1.580|
000058  6842              LDR      r2,[r0,#4]  ; USB_CDCContext
00005a  4b7b              LDR      r3,|L1.584|
00005c  6801              LDR      r1,[r0,#0]  ; USB_CDCContext
00005e  2003              MOVS     r0,#3
000060  f7fffffe          BL       USB_EP_doDataOut
                  |L1.100|
;;;670                  USB_CDCContext.CDC_DataPortionLength, USB_CDC_OnDataReceive);
;;;671      }
;;;672      else
;;;673      {
;;;674        return USB_SUCCESS;
;;;675      }
;;;676    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L1.104|
000068  2000              MOVS     r0,#0                 ;674
00006a  e7fb              B        |L1.100|
;;;677    
                          ENDP

                  USB_CDC_ReceiveStart PROC
;;;324    
;;;325    USB_Result USB_CDC_ReceiveStart(void)
00006c  b510              PUSH     {r4,lr}
;;;326    {
;;;327      USB_CDCContext.CDC_ReceiveDataStatus = USB_SUCCESS;
00006e  2000              MOVS     r0,#0
000070  4974              LDR      r1,|L1.580|
000072  8148              STRH     r0,[r1,#0xa]
;;;328      return USB_EP_doDataOut(USB_CDC_EP_RECEIVE, USB_CDCContext.CDC_ReceiveBuffer,
000074  4608              MOV      r0,r1
000076  6842              LDR      r2,[r0,#4]  ; USB_CDCContext
000078  4b73              LDR      r3,|L1.584|
00007a  6801              LDR      r1,[r0,#0]  ; USB_CDCContext
00007c  2003              MOVS     r0,#3
00007e  f7fffffe          BL       USB_EP_doDataOut
;;;329                USB_CDCContext.CDC_DataPortionLength, USB_CDC_OnDataReceive);
;;;330    }
000082  bd10              POP      {r4,pc}
;;;331    
                          ENDP

                  USB_CDC_ReceiveStop PROC
;;;338    
;;;339    USB_Result USB_CDC_ReceiveStop(void)
000084  b510              PUSH     {r4,lr}
;;;340    {
;;;341      USB_CDCContext.CDC_ReceiveDataStatus = USB_ERR_BUSY;
000086  f44f7000          MOV      r0,#0x200
00008a  496e              LDR      r1,|L1.580|
00008c  8148              STRH     r0,[r1,#0xa]
;;;342      return USB_EP_Stall(USB_CDC_EP_RECEIVE, USB_STALL_PROTO);
00008e  2100              MOVS     r1,#0
000090  2003              MOVS     r0,#3
000092  f7fffffe          BL       USB_EP_Stall
;;;343    }
000096  bd10              POP      {r4,pc}
;;;344    
                          ENDP

                  USB_CDC_OnDataSent PROC
;;;630    
;;;631    static USB_Result USB_CDC_OnDataSent(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
000098  b510              PUSH     {r4,lr}
;;;632    {
00009a  4603              MOV      r3,r0
;;;633      /* Release "busy" flag and call user's handler */
;;;634      USB_CDCContext.CDC_SendDataStatus = USB_SUCCESS;
00009c  2000              MOVS     r0,#0
00009e  4c69              LDR      r4,|L1.580|
0000a0  8120              STRH     r0,[r4,#8]
;;;635      return USB_CDC_HANDLE_DATA_SENT;
;;;636    }
0000a2  bd10              POP      {r4,pc}
;;;637    
                          ENDP

                  USB_CDC_SendData PROC
;;;357    
;;;358    USB_Result USB_CDC_SendData(uint8_t* Buffer, uint32_t Length)
0000a4  b570              PUSH     {r4-r6,lr}
;;;359    {
0000a6  4604              MOV      r4,r0
0000a8  460d              MOV      r5,r1
;;;360      /* Check if previous data sending is complete */
;;;361      USB_Result result = USB_CDCContext.CDC_SendDataStatus;
0000aa  4866              LDR      r0,|L1.580|
0000ac  8906              LDRH     r6,[r0,#8]  ; USB_CDCContext
;;;362    
;;;363      /* If data can be sent, set "busy" flag and initiate data portion transfer */
;;;364      if (result == USB_SUCCESS)
0000ae  b956              CBNZ     r6,|L1.198|
;;;365      {
;;;366        USB_CDCContext.CDC_SendDataStatus = USB_ERR_BUSY;
0000b0  f44f7000          MOV      r0,#0x200
0000b4  4963              LDR      r1,|L1.580|
0000b6  8108              STRH     r0,[r1,#8]
;;;367        result = USB_EP_doDataIn(USB_CDC_EP_SEND, Buffer, Length, USB_CDC_OnDataSent);
0000b8  4b64              LDR      r3,|L1.588|
0000ba  462a              MOV      r2,r5
0000bc  4621              MOV      r1,r4
0000be  2001              MOVS     r0,#1
0000c0  f7fffffe          BL       USB_EP_doDataIn
0000c4  4606              MOV      r6,r0
                  |L1.198|
;;;368      }
;;;369      return result;
0000c6  4630              MOV      r0,r6
;;;370    }
0000c8  bd70              POP      {r4-r6,pc}
;;;371    
                          ENDP

                  USB_CDC_Reset PROC
;;;409    
;;;410    USB_Result USB_CDC_Reset(void)
0000ca  b510              PUSH     {r4,lr}
;;;411    {
;;;412      USB_Result result;
;;;413    
;;;414      /* Inherited handler call */
;;;415      result = USB_DeviceReset();
0000cc  f7fffffe          BL       USB_DeviceReset
0000d0  4604              MOV      r4,r0
;;;416    
;;;417      if (result == USB_SUCCESS)
0000d2  b9cc              CBNZ     r4,|L1.264|
;;;418      {
;;;419        /* EP1, EP2 and EP3 initialization. Note: DATA1 bit would be toggled to DATA0 on the first
;;;420         * IN transaction */
;;;421        USB_EP_Init(USB_CDC_EP_SEND, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1,
0000d4  2200              MOVS     r2,#0
0000d6  2105              MOVS     r1,#5
0000d8  2001              MOVS     r0,#1
0000da  f7fffffe          BL       USB_EP_Init
;;;422                    USB_CDC_HANDLE_SEND_ERROR);
;;;423        USB_EP_Init(USB_CDC_EP_STATE, USB_SEPx_CTRL_EPEN_Enable | USB_SEPx_CTRL_EPDATASEQ_Data1,
0000de  2200              MOVS     r2,#0
0000e0  2105              MOVS     r1,#5
0000e2  2002              MOVS     r0,#2
0000e4  f7fffffe          BL       USB_EP_Init
;;;424                    USB_CDC_HANDLE_LINE_STATE_REPORT_SEND_ERROR);
;;;425        USB_EP_Init(USB_CDC_EP_RECEIVE, USB_SEPx_CTRL_EPEN_Enable, 0);
0000e8  2200              MOVS     r2,#0
0000ea  2101              MOVS     r1,#1
0000ec  2003              MOVS     r0,#3
0000ee  f7fffffe          BL       USB_EP_Init
;;;426    
;;;427        /* Start to listen for incoming data, if desired */
;;;428        if (USB_CDCContext.CDC_ReceiveDataStatus == USB_SUCCESS)
0000f2  4854              LDR      r0,|L1.580|
0000f4  8940              LDRH     r0,[r0,#0xa]  ; USB_CDCContext
0000f6  b938              CBNZ     r0,|L1.264|
;;;429        {
;;;430          result = USB_EP_doDataOut(USB_CDC_EP_RECEIVE, USB_CDCContext.CDC_ReceiveBuffer,
0000f8  4852              LDR      r0,|L1.580|
0000fa  6842              LDR      r2,[r0,#4]  ; USB_CDCContext
0000fc  4b52              LDR      r3,|L1.584|
0000fe  6801              LDR      r1,[r0,#0]  ; USB_CDCContext
000100  2003              MOVS     r0,#3
000102  f7fffffe          BL       USB_EP_doDataOut
000106  4604              MOV      r4,r0
                  |L1.264|
;;;431                    USB_CDCContext.CDC_DataPortionLength, USB_CDC_OnDataReceive);
;;;432        }
;;;433      }
;;;434      return result;
000108  4620              MOV      r0,r4
;;;435    }
00010a  bd10              POP      {r4,pc}
;;;436    
                          ENDP

                  USB_CDC_GetDescriptor PROC
;;;450    
;;;451    USB_Result USB_CDC_GetDescriptor(uint16_t wVALUE, uint16_t wINDEX, uint16_t wLENGTH)
00010c  e92d47f0          PUSH     {r4-r10,lr}
;;;452    {
000110  4605              MOV      r5,r0
000112  4689              MOV      r9,r1
000114  4616              MOV      r6,r2
;;;453      uint8_t* pDescr = 0;
000116  f04f0800          MOV      r8,#0
;;;454      uint32_t length;
;;;455      USB_Result result = USB_SUCCESS;
00011a  2700              MOVS     r7,#0
;;;456    
;;;457      /* Only 0 configuration is supported; for device request this field must be 0 */
;;;458      if ((wVALUE & 0xFF) != 0)
00011c  f0150fff          TST      r5,#0xff
000120  d001              BEQ      |L1.294|
;;;459      {
;;;460        result = USB_ERROR;
000122  2701              MOVS     r7,#1
000124  e010              B        |L1.328|
                  |L1.294|
;;;461      }
;;;462      else
;;;463      {
;;;464        switch (wVALUE >> 8)      /* Descriptor type */
000126  1228              ASRS     r0,r5,#8
000128  2801              CMP      r0,#1
00012a  d002              BEQ      |L1.306|
00012c  2802              CMP      r0,#2
00012e  d108              BNE      |L1.322|
000130  e003              B        |L1.314|
                  |L1.306|
;;;465        {
;;;466          case USB_DEVICE:
;;;467            pDescr = Usb_CDC_Device_Descriptor;
000132  f8df811c          LDR      r8,|L1.592|
;;;468            length = 0x12;
000136  2412              MOVS     r4,#0x12
;;;469            break;
000138  e005              B        |L1.326|
                  |L1.314|
;;;470          case USB_CONFIGURATION:
;;;471            pDescr = Usb_CDC_Configuration_Descriptor;
00013a  f8df8118          LDR      r8,|L1.596|
;;;472            length = 0x43;
00013e  2443              MOVS     r4,#0x43
;;;473            break;
000140  e001              B        |L1.326|
                  |L1.322|
;;;474          default:
;;;475            result = USB_ERROR;
000142  2701              MOVS     r7,#1
000144  bf00              NOP                            ;464
                  |L1.326|
000146  bf00              NOP                            ;469
                  |L1.328|
;;;476        }
;;;477      }
;;;478    
;;;479      if (result == USB_SUCCESS)
000148  b94f              CBNZ     r7,|L1.350|
;;;480      {
;;;481        if (length > wLENGTH)
00014a  42b4              CMP      r4,r6
00014c  d900              BLS      |L1.336|
;;;482        {
;;;483          length = wLENGTH;
00014e  4634              MOV      r4,r6
                  |L1.336|
;;;484        }
;;;485        result = USB_EP_doDataIn(USB_EP0, pDescr, length, USB_DeviceDoStatusOutAck);
000150  4b41              LDR      r3,|L1.600|
000152  4622              MOV      r2,r4
000154  4641              MOV      r1,r8
000156  2000              MOVS     r0,#0
000158  f7fffffe          BL       USB_EP_doDataIn
00015c  4607              MOV      r7,r0
                  |L1.350|
;;;486      }
;;;487      return result;
00015e  4638              MOV      r0,r7
;;;488    }
000160  e8bd87f0          POP      {r4-r10,pc}
;;;489    
                          ENDP

                  USB_CDC_DoDataOut PROC
;;;697    
;;;698    static USB_Result USB_CDC_DoDataOut(USB_EP_TypeDef EPx, uint8_t* Buffer, uint32_t Length)
000164  e92d41f0          PUSH     {r4-r8,lr}
;;;699    {
000168  4605              MOV      r5,r0
00016a  460e              MOV      r6,r1
00016c  4617              MOV      r7,r2
;;;700      USB_Result result;
;;;701    
;;;702      switch (USB_CurrentSetupPacket.bRequest)
00016e  483b              LDR      r0,|L1.604|
000170  7840              LDRB     r0,[r0,#1]  ; USB_CurrentSetupPacket
000172  2820              CMP      r0,#0x20
000174  d106              BNE      |L1.388|
;;;703      {
;;;704    #ifdef USB_CDC_COMM_FEATURE_SUPPORTED
;;;705        /* USB_CDC_SET_COMM_FEATURE */
;;;706        case USB_CDC_SET_COMM_FEATURE:
;;;707          /* Call user's handler */
;;;708          result = USB_CDC_HANDLE_SET_COMM_FEATURE(USB_CurrentSetupPacket.wValue,
;;;709                                                   USB_CurrentSetupPacket.wIndex,
;;;710                                                   *((uint16_t*)Buffer));
;;;711          break;
;;;712    #endif /* USB_CDC_COMM_FEATURE_SUPPORTED */
;;;713    #ifdef USB_CDC_LINE_CODING_SUPPORTED
;;;714        /* USB_CDC_SET_LINE_CODING */
;;;715        case USB_CDC_SET_LINE_CODING:
;;;716          /* Call user's handler */
;;;717          result = USB_CDC_HANDLE_SET_LINE_CODING(USB_CurrentSetupPacket.wIndex,
000176  4939              LDR      r1,|L1.604|
000178  8888              LDRH     r0,[r1,#4]  ; USB_CurrentSetupPacket
00017a  4631              MOV      r1,r6
00017c  f7fffffe          BL       USB_CDC_SetLineCoding
000180  4604              MOV      r4,r0
;;;718                                                  (const USB_CDC_LineCoding_TypeDef*)Buffer);
;;;719          break;
000182  e001              B        |L1.392|
                  |L1.388|
;;;720    #endif /* USB_CDC_LINE_CODING_SUPPORTED */
;;;721        default:
;;;722          result = USB_ERR_INV_REQ;
000184  2402              MOVS     r4,#2
000186  bf00              NOP                            ;702
                  |L1.392|
000188  bf00              NOP                            ;719
;;;723      }
;;;724      /* Initiate Status Stage */
;;;725      return result == USB_SUCCESS ? USB_EP_doDataIn(EPx, 0, 0, 0) : result;
00018a  b93c              CBNZ     r4,|L1.412|
00018c  2300              MOVS     r3,#0
00018e  461a              MOV      r2,r3
000190  4619              MOV      r1,r3
000192  4628              MOV      r0,r5
000194  f7fffffe          BL       USB_EP_doDataIn
                  |L1.408|
;;;726    }
000198  e8bd81f0          POP      {r4-r8,pc}
                  |L1.412|
00019c  4620              MOV      r0,r4                 ;725
00019e  e7fb              B        |L1.408|
;;;727    
                          ENDP

                  USB_CDC_ClassRequest PROC
;;;497    
;;;498    USB_Result USB_CDC_ClassRequest(void)
0001a0  e92d41f0          PUSH     {r4-r8,lr}
;;;499    {
;;;500      USB_Result result = USB_SUCCESS;
0001a4  2500              MOVS     r5,#0
;;;501    
;;;502      uint16_t wValue = USB_CurrentSetupPacket.wValue,
0001a6  482d              LDR      r0,|L1.604|
0001a8  8847              LDRH     r7,[r0,#2]  ; USB_CurrentSetupPacket
;;;503               wIndex = USB_CurrentSetupPacket.wIndex,
0001aa  8886              LDRH     r6,[r0,#4]  ; USB_CurrentSetupPacket
;;;504               wLength = USB_CurrentSetupPacket.wLength;
0001ac  88c4              LDRH     r4,[r0,#6]  ; USB_CurrentSetupPacket
;;;505    
;;;506      /* Specific requests */
;;;507      switch (USB_CurrentSetupPacket.bRequest)
0001ae  7840              LDRB     r0,[r0,#1]  ; USB_CurrentSetupPacket
0001b0  2820              CMP      r0,#0x20
0001b2  d002              BEQ      |L1.442|
0001b4  2821              CMP      r0,#0x21
0001b6  d11e              BNE      |L1.502|
0001b8  e00b              B        |L1.466|
                  |L1.442|
;;;508      {
;;;509    #ifdef USB_CDC_ENCAPSULATION_SUPPORTED
;;;510        /* SEND_ENCAPSULATED_COMMAND */
;;;511        case USB_CDC_SEND_ENCAPSULATED_COMMAND:
;;;512          result = USB_CDC_HANDLE_SEND_ENCAPSULATED_CMD(wIndex, wLength);
;;;513          break;
;;;514        /* GET_ENCAPSULATED_RESPONSE */
;;;515        case USB_CDC_GET_ENCAPSULATED_RESPONSE:
;;;516          result = USB_CDC_HANDLE_GET_ENCAPSULATED_RESP(wIndex, wLength);
;;;517          break;
;;;518    #endif /* USB_CDC_ENCAPSULATION_SUPPORTED */
;;;519    
;;;520    #ifdef USB_CDC_COMM_FEATURE_SUPPORTED
;;;521        /* SET_COMM_FEATURE */
;;;522        case USB_CDC_SET_COMM_FEATURE:
;;;523          if (wLength == 2)
;;;524          {
;;;525            result = USB_EP_doDataOut(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_CDC_DoDataOut);
;;;526          }
;;;527          else
;;;528          {
;;;529            result = USB_ERR_INV_REQ;
;;;530          }
;;;531          break;
;;;532        /* GET_COMM_FEATURE */
;;;533        case USB_CDC_GET_COMM_FEATURE:
;;;534          if (wLength == 2)
;;;535          {
;;;536            result = USB_CDC_HANDLE_GET_COMM_FEATURE(wValue, wIndex, &CDC_ClassPacketData.CommFeature);
;;;537            if (result == USB_SUCCESS)
;;;538            {
;;;539              result = USB_EP_doDataIn(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_DeviceDoStatusOutAck);
;;;540            }
;;;541          }
;;;542          else
;;;543          {
;;;544            result = USB_ERR_INV_REQ;
;;;545          }
;;;546          break;
;;;547        /* CLEAR_COMM_FEATURE */
;;;548        case USB_CDC_CLEAR_COMM_FEATURE:
;;;549          result = USB_CDC_HANDLE_CLEAR_COMM_FEATURE(wValue, wIndex);
;;;550          break;
;;;551    #endif /* USB_CDC_COMM_FEATURE_SUPPORTED */
;;;552    
;;;553    #ifdef USB_CDC_LINE_CODING_SUPPORTED
;;;554        /* SET_LINE_CODING */
;;;555        case USB_CDC_SET_LINE_CODING:
;;;556          if (wLength == 7)
0001ba  2c07              CMP      r4,#7
0001bc  d107              BNE      |L1.462|
;;;557          {
;;;558            result = USB_EP_doDataOut(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_CDC_DoDataOut);
0001be  4b28              LDR      r3,|L1.608|
0001c0  4622              MOV      r2,r4
0001c2  4928              LDR      r1,|L1.612|
0001c4  2000              MOVS     r0,#0
0001c6  f7fffffe          BL       USB_EP_doDataOut
0001ca  4605              MOV      r5,r0
0001cc  e000              B        |L1.464|
                  |L1.462|
;;;559          }
;;;560          else
;;;561          {
;;;562            result = USB_ERR_INV_REQ;
0001ce  2502              MOVS     r5,#2
                  |L1.464|
;;;563          }
;;;564          break;
0001d0  e013              B        |L1.506|
                  |L1.466|
;;;565        /* GET_LINE_CODING */
;;;566        case USB_CDC_GET_LINE_CODING:
;;;567          if (wLength == 7)
0001d2  2c07              CMP      r4,#7
0001d4  d10d              BNE      |L1.498|
;;;568          {
;;;569            result = USB_CDC_HANDLE_GET_LINE_CODING(wIndex, &CDC_ClassPacketData.LineCoding);
0001d6  4923              LDR      r1,|L1.612|
0001d8  4630              MOV      r0,r6
0001da  f7fffffe          BL       USB_CDC_GetLineCoding
0001de  4605              MOV      r5,r0
;;;570            if (result == USB_SUCCESS)
0001e0  b945              CBNZ     r5,|L1.500|
;;;571            {
;;;572              result = USB_EP_doDataIn(USB_EP0, (uint8_t*)&CDC_ClassPacketData, wLength, USB_DeviceDoStatusOutAck);
0001e2  4b1d              LDR      r3,|L1.600|
0001e4  4622              MOV      r2,r4
0001e6  491f              LDR      r1,|L1.612|
0001e8  2000              MOVS     r0,#0
0001ea  f7fffffe          BL       USB_EP_doDataIn
0001ee  4605              MOV      r5,r0
0001f0  e000              B        |L1.500|
                  |L1.498|
;;;573            }
;;;574          }
;;;575          else
;;;576          {
;;;577            result = USB_ERR_INV_REQ;
0001f2  2502              MOVS     r5,#2
                  |L1.500|
;;;578          }
;;;579          break;
0001f4  e001              B        |L1.506|
                  |L1.502|
;;;580    #endif /* USB_CDC_LINE_CODING_SUPPORTED */
;;;581    
;;;582    #ifdef USB_CDC_CONTROL_LINE_STATE_SUPPORTED
;;;583          /* SET_CONTROL_LINE_STATE */
;;;584          case USB_CDC_SET_CONTROL_LINE_STATE:
;;;585            result = USB_CDC_HANDLE_CONTROL_LINE_STATE(wValue, wIndex);
;;;586            break;
;;;587    #endif /* USB_CDC_CONTROL_LINE_STATE_SUPPORTED */
;;;588    
;;;589    #ifdef USB_CDC_LINE_BREAK_SUPPORTED
;;;590          /* SEND_BREAK */
;;;591          case USB_CDC_SEND_BREAK:
;;;592            result = USB_CDC_HANDLE_BREAK(wValue, wIndex);
;;;593            break;
;;;594    #endif /* USB_CDC_LINE_BREAK_SUPPORTED */
;;;595    
;;;596          default:
;;;597            result = USB_ERROR;
0001f6  2501              MOVS     r5,#1
0001f8  bf00              NOP                            ;507
                  |L1.506|
0001fa  bf00              NOP                            ;564
;;;598      }
;;;599      /* If there were no DATA stage, initiate Status Stage (IN ACK) */
;;;600      if (result == USB_SUCCESS && wLength == 0)
0001fc  b9a5              CBNZ     r5,|L1.552|
0001fe  b99c              CBNZ     r4,|L1.552|
;;;601      {
;;;602        result = (USB_CurrentSetupPacket.mRequestTypeData & 0x80) == USB_DEVICE_TO_HOST ?
000200  4816              LDR      r0,|L1.604|
000202  7800              LDRB     r0,[r0,#0]  ; USB_CurrentSetupPacket
000204  f0000080          AND      r0,r0,#0x80
000208  2880              CMP      r0,#0x80
00020a  d106              BNE      |L1.538|
;;;603                        USB_EP_doDataOut(USB_EP0, 0, 0, 0) :
00020c  2300              MOVS     r3,#0
00020e  461a              MOV      r2,r3
000210  4619              MOV      r1,r3
000212  4618              MOV      r0,r3
000214  f7fffffe          BL       USB_EP_doDataOut
000218  e005              B        |L1.550|
                  |L1.538|
;;;604                        USB_EP_doDataIn(USB_EP0, 0, 0, 0);
00021a  2300              MOVS     r3,#0
00021c  461a              MOV      r2,r3
00021e  4619              MOV      r1,r3
000220  4618              MOV      r0,r3
000222  f7fffffe          BL       USB_EP_doDataIn
                  |L1.550|
000226  4605              MOV      r5,r0
                  |L1.552|
;;;605      }
;;;606    
;;;607      return result;
000228  4628              MOV      r0,r5
;;;608    }
00022a  e8bd81f0          POP      {r4-r8,pc}
;;;609    
                          ENDP

                  USB_CDC_DummyDataReceive PROC
;;;743    
;;;744    USB_Result USB_CDC_DummyDataReceive(uint8_t* Buffer, uint32_t Length)
00022e  4602              MOV      r2,r0
;;;745    {
;;;746      return USB_ERROR;
000230  2001              MOVS     r0,#1
;;;747    }
000232  4770              BX       lr
;;;748    
                          ENDP

                  USB_CDC_DummyDataSent PROC
;;;756    
;;;757    USB_Result USB_CDC_DummyDataSent(void)
000234  2001              MOVS     r0,#1
;;;758    {
;;;759      return USB_ERROR;
;;;760    }
000236  4770              BX       lr
;;;761    
                          ENDP

                  USB_CDC_DummyGetLineCoding PROC
;;;864    
;;;865    USB_Result USB_CDC_DummyGetLineCoding(uint16_t wINDEX, USB_CDC_LineCoding_TypeDef* DATA)
000238  4602              MOV      r2,r0
;;;866    {
;;;867      return USB_ERROR;
00023a  2001              MOVS     r0,#1
;;;868    }
00023c  4770              BX       lr
;;;869    
                          ENDP

                  USB_CDC_DummySetLineCoding PROC
;;;880    
;;;881    USB_Result USB_CDC_DummySetLineCoding(uint16_t wINDEX, const USB_CDC_LineCoding_TypeDef* DATA)
00023e  4602              MOV      r2,r0
;;;882    {
;;;883      return USB_ERROR;
000240  2001              MOVS     r0,#1
;;;884    }
000242  4770              BX       lr
;;;885    #endif /* USB_CDC_LINE_CODING_SUPPORTED */
                          ENDP

                  |L1.580|
                          DCD      USB_CDCContext
                  |L1.584|
                          DCD      USB_CDC_OnDataReceive
                  |L1.588|
                          DCD      USB_CDC_OnDataSent
                  |L1.592|
                          DCD      Usb_CDC_Device_Descriptor
                  |L1.596|
                          DCD      Usb_CDC_Configuration_Descriptor
                  |L1.600|
                          DCD      USB_DeviceDoStatusOutAck
                  |L1.604|
                          DCD      USB_CurrentSetupPacket
                  |L1.608|
                          DCD      USB_CDC_DoDataOut
                  |L1.612|
                          DCD      CDC_ClassPacketData

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_CDCContext
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  Usb_CDC_Device_Descriptor
000000  12011001          DCB      0x12,0x01,0x10,0x01
000004  02000020          DCB      0x02,0x00,0x00,0x20
000008  830425f1          DCB      0x83,0x04,0x25,0xf1
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  0001              DCB      0x00,0x01
                  Usb_CDC_Configuration_Descriptor
000012  0902              DCB      0x09,0x02
000014  43000201          DCB      0x43,0x00,0x02,0x01
000018  00803209          DCB      0x00,0x80,0x32,0x09
00001c  04000001          DCB      0x04,0x00,0x00,0x01
000020  02020100          DCB      0x02,0x02,0x01,0x00
000024  05240010          DCB      0x05,0x24,0x00,0x10
000028  01052401          DCB      0x01,0x05,0x24,0x01
00002c  00010424          DCB      0x00,0x01,0x04,0x24
000030  02060524          DCB      0x02,0x06,0x05,0x24
000034  06000107          DCB      0x06,0x00,0x01,0x07
000038  05820320          DCB      0x05,0x82,0x03,0x20
00003c  00020904          DCB      0x00,0x02,0x09,0x04
000040  0100020a          DCB      0x01,0x00,0x02,0x0a
000044  00000007          DCB      0x00,0x00,0x00,0x07
000048  05810220          DCB      0x05,0x81,0x02,0x20
00004c  00000705          DCB      0x00,0x00,0x07,0x05
000050  03022000          DCB      0x03,0x02,0x20,0x00
000054  00000000          DCB      0x00,0x00,0x00,0x00
                  CDC_ClassPacketData
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\USB_Library\\MDR32F9Qx_usb_CDC.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_usb_CDC_c_6a2e2986____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___19_MDR32F9Qx_usb_CDC_c_6a2e2986____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_usb_CDC_c_6a2e2986____REVSH|
#line 144
|__asm___19_MDR32F9Qx_usb_CDC_c_6a2e2986____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
