; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\Debug\Exe\mdr32f9qx_rst_clk.o --asm_dir=.\Debug\Lst\ --list_dir=.\Debug\Lst\ --depend=.\Debug\Exe\mdr32f9qx_rst_clk.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\inc\USB_Library -I..\..\inc -I..\..\Config -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\Debug\Exe\mdr32f9qx_rst_clk.crf ..\..\..\..\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_rst_clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RST_CLK_PCLKcmd PROC
;;;1408     */
;;;1409   void RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState)
000000  b129              CBZ      r1,|L1.14|
;;;1410   {
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1413     assert_param(IS_RST_CLK_PCLK(RST_CLK_PCLK));
;;;1414     if (NewState != DISABLE)
;;;1415     {
;;;1416       MDR_RST_CLK->PER_CLOCK |= RST_CLK_PCLK;
000002  4af8              LDR      r2,|L1.996|
000004  69d2              LDR      r2,[r2,#0x1c]
000006  4302              ORRS     r2,r2,r0
000008  4bf6              LDR      r3,|L1.996|
00000a  61da              STR      r2,[r3,#0x1c]
00000c  e004              B        |L1.24|
                  |L1.14|
;;;1417     }
;;;1418     else
;;;1419     {
;;;1420       MDR_RST_CLK->PER_CLOCK &= ~RST_CLK_PCLK;
00000e  4af5              LDR      r2,|L1.996|
000010  69d2              LDR      r2,[r2,#0x1c]
000012  4382              BICS     r2,r2,r0
000014  4bf3              LDR      r3,|L1.996|
000016  61da              STR      r2,[r3,#0x1c]
                  |L1.24|
;;;1421     }
;;;1422   }
000018  4770              BX       lr
;;;1423   
                          ENDP

                  RST_CLK_CPUclkSelection PROC
;;;779      */
;;;780    void RST_CLK_CPUclkSelection(uint32_t CPU_CLK)
00001a  4601              MOV      r1,r0
;;;781    {
;;;782      uint32_t temp;
;;;783    
;;;784      /* Check the parameters */
;;;785      assert_param(IS_RST_CPU_CLK(CPU_CLK));
;;;786    
;;;787      temp = MDR_RST_CLK->CPU_CLOCK;
00001c  4af1              LDR      r2,|L1.996|
00001e  68d0              LDR      r0,[r2,#0xc]
;;;788      /* Clear CPU_C3_SEL bits */
;;;789      temp &= CPU_HCLK_SELclr;
000020  f4207040          BIC      r0,r0,#0x300
;;;790      /* Set the CPU_C3_SEL bits */
;;;791      temp |= CPU_CLK;
000024  4308              ORRS     r0,r0,r1
;;;792      /* Store the new value */
;;;793      MDR_RST_CLK->CPU_CLOCK = temp;
000026  60d0              STR      r0,[r2,#0xc]
;;;794    }
000028  4770              BX       lr
;;;795    
                          ENDP

                  RST_CLK_GetFlagStatus PROC
;;;1650     */
;;;1651   FlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG)
00002a  b510              PUSH     {r4,lr}
;;;1652   {
00002c  4601              MOV      r1,r0
;;;1653     uint32_t statusreg;
;;;1654     FlagStatus bitstatus;
;;;1655   
;;;1656     /* Check the parameters */
;;;1657     assert_param(IS_RST_CLK_FLAG(RST_CLK_FLAG));
;;;1658   
;;;1659     /* Get the register */
;;;1660     if ((FLAG_SFR_MASK & RST_CLK_FLAG) == (uint32_t)0x20) /* The flag to check is in CLOCK_STATUS register */
00002e  f00103e0          AND      r3,r1,#0xe0
000032  2b20              CMP      r3,#0x20
000034  d102              BNE      |L1.60|
;;;1661     {
;;;1662       statusreg = MDR_RST_CLK->CLOCK_STATUS;
000036  4beb              LDR      r3,|L1.996|
000038  681a              LDR      r2,[r3,#0]
00003a  e001              B        |L1.64|
                  |L1.60|
;;;1663     }
;;;1664     else                                                  /* The flag to check is in REG_0F register */
;;;1665     {
;;;1666       statusreg = MDR_BKP->REG_0F;
00003c  4bea              LDR      r3,|L1.1000|
00003e  6bda              LDR      r2,[r3,#0x3c]
                  |L1.64|
;;;1667     }
;;;1668   
;;;1669     /* Get the flag status on proper position */
;;;1670     if ((statusreg & ((uint32_t)1 << (RST_CLK_FLAG & FLAG_MASK))) != (uint32_t)0x00)
000040  f001041f          AND      r4,r1,#0x1f
000044  2301              MOVS     r3,#1
000046  40a3              LSLS     r3,r3,r4
000048  4213              TST      r3,r2
00004a  d001              BEQ      |L1.80|
;;;1671     {
;;;1672       bitstatus = SET;
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L1.82|
                  |L1.80|
;;;1673     }
;;;1674     else
;;;1675     {
;;;1676       bitstatus = RESET;
000050  2000              MOVS     r0,#0
                  |L1.82|
;;;1677     }
;;;1678   
;;;1679     /* Return the flag status */
;;;1680     return bitstatus;
;;;1681   }
000052  bd10              POP      {r4,pc}
;;;1682   
                          ENDP

                  RST_CLK_HSIstatus PROC
;;;468      */
;;;469    ErrorStatus RST_CLK_HSIstatus(void)
000054  b570              PUSH     {r4-r6,lr}
;;;470    {
;;;471      __IO uint32_t startCounter = 0;
000056  2600              MOVS     r6,#0
;;;472      ErrorStatus state;
;;;473      FlagStatus flag;
;;;474    
;;;475      /* Wait until HSI is ready or time out is occure */
;;;476      do
000058  bf00              NOP      
                  |L1.90|
;;;477      {
;;;478        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY);
00005a  2017              MOVS     r0,#0x17
00005c  f7fffffe          BL       RST_CLK_GetFlagStatus
000060  4605              MOV      r5,r0
;;;479        startCounter++;
000062  1c76              ADDS     r6,r6,#1
;;;480      } while ((startCounter < HSIonTimeOut) && (flag == RESET));
000064  f5b66fc0          CMP      r6,#0x600
000068  d201              BCS      |L1.110|
00006a  2d00              CMP      r5,#0
00006c  d0f5              BEQ      |L1.90|
                  |L1.110|
;;;481    
;;;482      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY) != RESET)
00006e  2017              MOVS     r0,#0x17
000070  f7fffffe          BL       RST_CLK_GetFlagStatus
000074  b108              CBZ      r0,|L1.122|
;;;483      {
;;;484        state = SUCCESS;
000076  2401              MOVS     r4,#1
000078  e000              B        |L1.124|
                  |L1.122|
;;;485      }
;;;486      else
;;;487      {
;;;488        state = ERROR;
00007a  2400              MOVS     r4,#0
                  |L1.124|
;;;489      }
;;;490      return state;
00007c  4620              MOV      r0,r4
;;;491    }
00007e  bd70              POP      {r4-r6,pc}
;;;492    
                          ENDP

                  RST_CLK_HSIcmd PROC
;;;414      */
;;;415    void RST_CLK_HSIcmd(FunctionalState NewState)
000080  49da              LDR      r1,|L1.1004|
;;;416    {
;;;417    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;418      uint32_t temp = 0;
;;;419    #endif
;;;420      /* Check the parameters */
;;;421      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;422    
;;;423    #if defined  (USE_MDR1986VE9x)
;;;424      *(__IO uint32_t *) HSION_BB = (uint32_t)NewState;
000082  6008              STR      r0,[r1,#0]
;;;425    #endif
;;;426    
;;;427    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;428    
;;;429        temp = MDR_BKP->REG_0F;
;;;430      /* Form new value */
;;;431      if (NewState != DISABLE){
;;;432        /* Enable HSI clk by setting the HSE_ON bit in the BKP_REG_0F register */
;;;433        temp |= BKP_REG_0F_HSI_ON;
;;;434      }
;;;435      else{
;;;436        /* Disable HSI clk by resetting the HSE_ON bit in the BKP_REG_0F register */
;;;437        temp &= ~BKP_REG_0F_HSI_ON;
;;;438      }
;;;439      /* Configure REG_0F register with new value */
;;;440      MDR_BKP->REG_0F = temp;
;;;441    #endif /* defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) */
;;;442    }
000084  4770              BX       lr
;;;443    
                          ENDP

                  RST_CLK_WarmDeInit PROC
;;;190      */
;;;191    void RST_CLK_WarmDeInit(void)
000086  b500              PUSH     {lr}
;;;192    {
;;;193      /* Prepare HSI clk */
;;;194      RST_CLK_HSIcmd(ENABLE);
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       RST_CLK_HSIcmd
;;;195      RST_CLK_HSIstatus();
00008e  f7fffffe          BL       RST_CLK_HSIstatus
;;;196      RST_CLK_CPUclkSelection(RST_CLK_CPUclkHSI);
000092  2000              MOVS     r0,#0
000094  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;197    
;;;198      /* Reset CPU_CLOCK bits */
;;;199      MDR_RST_CLK->CPU_CLOCK   &= (uint32_t)0x00000000;
000098  48d2              LDR      r0,|L1.996|
00009a  68c0              LDR      r0,[r0,#0xc]
00009c  2000              MOVS     r0,#0
00009e  49d1              LDR      r1,|L1.996|
0000a0  60c8              STR      r0,[r1,#0xc]
;;;200    
;;;201      /* Reset PLL_CONTROL bits */
;;;202      MDR_RST_CLK->PLL_CONTROL &= (uint32_t)0x00000000;
0000a2  4608              MOV      r0,r1
0000a4  6840              LDR      r0,[r0,#4]
0000a6  2000              MOVS     r0,#0
0000a8  6048              STR      r0,[r1,#4]
;;;203    
;;;204      /* Reset HSEON and HSEBYP bits */
;;;205      MDR_RST_CLK->HS_CONTROL  &= (uint32_t)0x00000000;
0000aa  4608              MOV      r0,r1
0000ac  6880              LDR      r0,[r0,#8]
0000ae  2000              MOVS     r0,#0
0000b0  6088              STR      r0,[r1,#8]
;;;206    
;;;207      /* Reset USB_CLOCK bits */
;;;208      MDR_RST_CLK->USB_CLOCK   &= (uint32_t)0x00000000;
0000b2  4608              MOV      r0,r1
0000b4  6900              LDR      r0,[r0,#0x10]
0000b6  2000              MOVS     r0,#0
0000b8  6108              STR      r0,[r1,#0x10]
;;;209    
;;;210      /* Reset ADC_MCO_CLOCK bits */
;;;211      MDR_RST_CLK->ADC_MCO_CLOCK   &= (uint32_t)0x00000000;
0000ba  4608              MOV      r0,r1
0000bc  6940              LDR      r0,[r0,#0x14]
0000be  2000              MOVS     r0,#0
0000c0  6148              STR      r0,[r1,#0x14]
;;;212    
;;;213      /* Reset RTC_CLOCK bits */
;;;214      MDR_RST_CLK->RTC_CLOCK   &= (uint32_t)0x00000000;
0000c2  4608              MOV      r0,r1
0000c4  6980              LDR      r0,[r0,#0x18]
0000c6  2000              MOVS     r0,#0
0000c8  6188              STR      r0,[r1,#0x18]
;;;215    
;;;216      /* Reset all clock but RTC_CLK bit */
;;;217      MDR_RST_CLK->PER_CLOCK   = (uint32_t)PCLK_BIT(MDR_RST_CLK_BASE) | (uint32_t)PCLK_BIT(MDR_BKP_BASE);
0000ca  48c9              LDR      r0,|L1.1008|
0000cc  61c8              STR      r0,[r1,#0x1c]
;;;218    }
0000ce  bd00              POP      {pc}
;;;219    
                          ENDP

                  RST_CLK_DeInit PROC
;;;175      */
;;;176    void RST_CLK_DeInit(void)
0000d0  b500              PUSH     {lr}
;;;177    {
;;;178      RST_CLK_WarmDeInit();
0000d2  f7fffffe          BL       RST_CLK_WarmDeInit
;;;179      /* Reset REG_0F bits to zero but HSION bit */
;;;180      RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP, ENABLE);
0000d6  2101              MOVS     r1,#1
0000d8  06c8              LSLS     r0,r1,#27
0000da  f7fffffe          BL       RST_CLK_PCLKcmd
;;;181      MDR_BKP->REG_0F |= (uint32_t)((1<<22)|(1<<15)); /* HSION & LSION */
0000de  48c2              LDR      r0,|L1.1000|
0000e0  6bc0              LDR      r0,[r0,#0x3c]
0000e2  f4400081          ORR      r0,r0,#0x408000
0000e6  49c0              LDR      r1,|L1.1000|
0000e8  63c8              STR      r0,[r1,#0x3c]
;;;182      MDR_BKP->REG_0F &= (uint32_t)((1<<22)|(1<<15));
0000ea  4608              MOV      r0,r1
0000ec  6bc0              LDR      r0,[r0,#0x3c]
0000ee  f4000081          AND      r0,r0,#0x408000
0000f2  63c8              STR      r0,[r1,#0x3c]
;;;183    }
0000f4  bd00              POP      {pc}
;;;184    
                          ENDP

                  RST_CLK_HSEconfig PROC
;;;227      */
;;;228    void RST_CLK_HSEconfig(uint32_t RST_CLK_HSE)
0000f6  49bb              LDR      r1,|L1.996|
;;;229    {
;;;230      /* Check the parameters */
;;;231      assert_param(IS_RST_CLK_HSE(RST_CLK_HSE));
;;;232      /* Reset HSEON and HSEBYP bits before configuring the HSE */
;;;233      MDR_RST_CLK->HS_CONTROL &= ~((uint32_t)(RST_CLK_HSE_ON | RST_CLK_HSE_Bypass));
0000f8  6889              LDR      r1,[r1,#8]
0000fa  f0210103          BIC      r1,r1,#3
0000fe  4ab9              LDR      r2,|L1.996|
000100  6091              STR      r1,[r2,#8]
;;;234      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;235      switch (RST_CLK_HSE)
000102  2801              CMP      r0,#1
000104  d002              BEQ      |L1.268|
000106  2802              CMP      r0,#2
000108  d10e              BNE      |L1.296|
00010a  e006              B        |L1.282|
                  |L1.268|
;;;236      {
;;;237        case RST_CLK_HSE_ON:
;;;238          /* Set HSEON bit */
;;;239          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON;
00010c  49b5              LDR      r1,|L1.996|
00010e  6889              LDR      r1,[r1,#8]
000110  f0410101          ORR      r1,r1,#1
000114  4ab3              LDR      r2,|L1.996|
000116  6091              STR      r1,[r2,#8]
;;;240          break;
000118  e007              B        |L1.298|
                  |L1.282|
;;;241    
;;;242        case RST_CLK_HSE_Bypass:
;;;243          /* Set HSEBYP and HSEON bits */
;;;244          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON | RST_CLK_HSE_Bypass;
00011a  49b2              LDR      r1,|L1.996|
00011c  6889              LDR      r1,[r1,#8]
00011e  f0410103          ORR      r1,r1,#3
000122  4ab0              LDR      r2,|L1.996|
000124  6091              STR      r1,[r2,#8]
;;;245          break;
000126  e000              B        |L1.298|
                  |L1.296|
;;;246    
;;;247        default:
;;;248          break;
000128  bf00              NOP      
                  |L1.298|
00012a  bf00              NOP                            ;240
;;;249      }
;;;250    }
00012c  4770              BX       lr
;;;251    
                          ENDP

                  RST_CLK_HSEstatus PROC
;;;292      */
;;;293    ErrorStatus RST_CLK_HSEstatus(void)
00012e  b570              PUSH     {r4-r6,lr}
;;;294    {
;;;295      __IO uint32_t startCounter = 0;
000130  2600              MOVS     r6,#0
;;;296      ErrorStatus state;
;;;297      FlagStatus flag;
;;;298    
;;;299      /* Wait until HSE is ready or time out is occure */
;;;300      do
000132  bf00              NOP      
                  |L1.308|
;;;301      {
;;;302        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY);
000134  2022              MOVS     r0,#0x22
000136  f7fffffe          BL       RST_CLK_GetFlagStatus
00013a  4605              MOV      r5,r0
;;;303        startCounter++;
00013c  1c76              ADDS     r6,r6,#1
;;;304      } while ((startCounter < HSEonTimeOut) && (flag == RESET));
00013e  f5b66fc0          CMP      r6,#0x600
000142  d201              BCS      |L1.328|
000144  2d00              CMP      r5,#0
000146  d0f5              BEQ      |L1.308|
                  |L1.328|
;;;305    
;;;306      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY) != RESET)
000148  2022              MOVS     r0,#0x22
00014a  f7fffffe          BL       RST_CLK_GetFlagStatus
00014e  b108              CBZ      r0,|L1.340|
;;;307      {
;;;308        state = SUCCESS;
000150  2401              MOVS     r4,#1
000152  e000              B        |L1.342|
                  |L1.340|
;;;309      }
;;;310      else
;;;311      {
;;;312        state = ERROR;
000154  2400              MOVS     r4,#0
                  |L1.342|
;;;313      }
;;;314      return state;
000156  4620              MOV      r0,r4
;;;315    }
000158  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

                  RST_CLK_LSEconfig PROC
;;;355      */
;;;356    void RST_CLK_LSEconfig(uint32_t RST_CLK_LSE)
00015a  49a3              LDR      r1,|L1.1000|
;;;357    {
;;;358      /* Check the parameters */
;;;359      assert_param(IS_RST_CLK_LSE(RST_CLK_LSE));
;;;360      /* Reset LSEON and LSEBYP bits before configuring the LSE */
;;;361      MDR_BKP->REG_0F &= ~((uint32_t)(RST_CLK_LSE_ON | RST_CLK_LSE_Bypass));
00015c  6bc9              LDR      r1,[r1,#0x3c]
00015e  f0210103          BIC      r1,r1,#3
000162  4aa1              LDR      r2,|L1.1000|
000164  63d1              STR      r1,[r2,#0x3c]
;;;362      switch (RST_CLK_LSE)
000166  2801              CMP      r0,#1
000168  d002              BEQ      |L1.368|
00016a  2802              CMP      r0,#2
00016c  d10e              BNE      |L1.396|
00016e  e006              B        |L1.382|
                  |L1.368|
;;;363      {
;;;364        case RST_CLK_LSE_ON:
;;;365          /* Set LSEON bit */
;;;366          MDR_BKP->REG_0F |= RST_CLK_LSE_ON;
000170  499d              LDR      r1,|L1.1000|
000172  6bc9              LDR      r1,[r1,#0x3c]
000174  f0410101          ORR      r1,r1,#1
000178  4a9b              LDR      r2,|L1.1000|
00017a  63d1              STR      r1,[r2,#0x3c]
;;;367          break;
00017c  e007              B        |L1.398|
                  |L1.382|
;;;368    
;;;369        case RST_CLK_LSE_Bypass:
;;;370          /* Set LSEBYP and LSEON bits */
;;;371          MDR_BKP->REG_0F |= (RST_CLK_LSE_ON | RST_CLK_LSE_Bypass);
00017e  499a              LDR      r1,|L1.1000|
000180  6bc9              LDR      r1,[r1,#0x3c]
000182  f0410103          ORR      r1,r1,#3
000186  4a98              LDR      r2,|L1.1000|
000188  63d1              STR      r1,[r2,#0x3c]
;;;372          break;
00018a  e000              B        |L1.398|
                  |L1.396|
;;;373    
;;;374        default:
;;;375          break;
00018c  bf00              NOP      
                  |L1.398|
00018e  bf00              NOP                            ;367
;;;376      }
;;;377    }
000190  4770              BX       lr
;;;378    
                          ENDP

                  RST_CLK_LSEstatus PROC
;;;383      */
;;;384    ErrorStatus RST_CLK_LSEstatus(void)
000192  b570              PUSH     {r4-r6,lr}
;;;385    {
;;;386      __IO uint32_t startCounter = 0;
000194  2600              MOVS     r6,#0
;;;387      ErrorStatus state;
;;;388      FlagStatus flag;
;;;389    
;;;390     /* Wait until LSE is ready or time out is occure */
;;;391     do
000196  bf00              NOP      
                  |L1.408|
;;;392      {
;;;393        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY);
000198  200d              MOVS     r0,#0xd
00019a  f7fffffe          BL       RST_CLK_GetFlagStatus
00019e  4605              MOV      r5,r0
;;;394        startCounter++;
0001a0  1c76              ADDS     r6,r6,#1
;;;395      } while ((startCounter < LSEonTimeOut) && (flag == RESET));
0001a2  f5b66fc0          CMP      r6,#0x600
0001a6  d201              BCS      |L1.428|
0001a8  2d00              CMP      r5,#0
0001aa  d0f5              BEQ      |L1.408|
                  |L1.428|
;;;396    
;;;397      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY) != RESET)
0001ac  200d              MOVS     r0,#0xd
0001ae  f7fffffe          BL       RST_CLK_GetFlagStatus
0001b2  b108              CBZ      r0,|L1.440|
;;;398      {
;;;399        state = SUCCESS;
0001b4  2401              MOVS     r4,#1
0001b6  e000              B        |L1.442|
                  |L1.440|
;;;400      }
;;;401      else
;;;402      {
;;;403        state = ERROR;
0001b8  2400              MOVS     r4,#0
                  |L1.442|
;;;404      }
;;;405      return state;
0001ba  4620              MOV      r0,r4
;;;406    }
0001bc  bd70              POP      {r4-r6,pc}
;;;407    
                          ENDP

                  RST_CLK_HSIadjust PROC
;;;449      */
;;;450    void RST_CLK_HSIadjust(uint32_t HSItrimValue)
0001be  4601              MOV      r1,r0
;;;451    {
;;;452      uint32_t temp;
;;;453      /* Check the parameters */
;;;454      assert_param(IS_RCC_CLK_HSI_TRIM_VALUE(HSItrimValue));
;;;455      temp = MDR_BKP->REG_0F;
0001c0  4a89              LDR      r2,|L1.1000|
0001c2  6bd0              LDR      r0,[r2,#0x3c]
;;;456      /* Clear HSITRIM[5:0] bits */
;;;457      temp &= ~HSITRIM_MASK;
0001c4  f020507c          BIC      r0,r0,#0x3f000000
;;;458      /* Set the HSITRIM[5:0] bits according to HSItrimValue value */
;;;459      temp |= (uint32_t)HSItrimValue << HSITRIM_OFFSET;
0001c8  ea406001          ORR      r0,r0,r1,LSL #24
;;;460      /* Store the new value */
;;;461      MDR_BKP->REG_0F = temp;
0001cc  63d0              STR      r0,[r2,#0x3c]
;;;462    }
0001ce  4770              BX       lr
;;;463    
                          ENDP

                  RST_CLK_LSIcmd PROC
;;;499      */
;;;500    void RST_CLK_LSIcmd(FunctionalState NewState)
0001d0  4986              LDR      r1,|L1.1004|
;;;501    {
;;;502    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;503      uint32_t temp = 0;
;;;504    #endif
;;;505      /* Check the parameters */
;;;506      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;507    
;;;508    #if defined  (USE_MDR1986VE9x)
;;;509      *(__IO uint32_t *) LSION_BB = (uint32_t) NewState;
0001d2  391c              SUBS     r1,r1,#0x1c
0001d4  6008              STR      r0,[r1,#0]
;;;510    #endif
;;;511    
;;;512    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;513    
;;;514      temp = MDR_BKP->REG_0F;
;;;515      /* Form new value */
;;;516      if (NewState != DISABLE) {
;;;517        /* Enable LSI clk by setting the LSE_ON bit in the BKP_REG_0F register */
;;;518        temp |= BKP_REG_0F_LSI_ON;
;;;519      }
;;;520      else {
;;;521        /* Disable LSI clk by resetting the LSE_ON bit in the BKP_REG_0F register */
;;;522        temp &= ~BKP_REG_0F_LSI_ON;
;;;523      }
;;;524      /* Configure REG_0F register with new value */
;;;525      MDR_BKP->REG_0F = temp;
;;;526    #endif
;;;527    }
0001d6  4770              BX       lr
;;;528    
                          ENDP

                  RST_CLK_LSIadjust PROC
;;;534      */
;;;535    void RST_CLK_LSIadjust(uint32_t LSItrimValue)
0001d8  4601              MOV      r1,r0
;;;536    {
;;;537      uint32_t temp;
;;;538      /* Check the parameters */
;;;539      assert_param(IS_RCC_CLK_LSI_TRIM_VALUE(LSItrimValue));
;;;540      temp = MDR_BKP->REG_0F;
0001da  4a83              LDR      r2,|L1.1000|
0001dc  6bd0              LDR      r0,[r2,#0x3c]
;;;541      /* Clear LSITRIM[4:0] bits */
;;;542      temp &= ~LSITRIM_MASK;
0001de  f42010f8          BIC      r0,r0,#0x1f0000
;;;543      /* Set the LSITRIM[4:0] bits according to LSItrimValue value */
;;;544      temp |= (uint32_t)LSItrimValue << LSITRIM_OFFSET;
0001e2  ea404001          ORR      r0,r0,r1,LSL #16
;;;545      /* Store the new value */
;;;546      MDR_BKP->REG_0F = temp;
0001e6  63d0              STR      r0,[r2,#0x3c]
;;;547    }
0001e8  4770              BX       lr
;;;548    
                          ENDP

                  RST_CLK_LSIstatus PROC
;;;553      */
;;;554    ErrorStatus RST_CLK_LSIstatus(void)
0001ea  b570              PUSH     {r4-r6,lr}
;;;555    {
;;;556      __IO uint32_t startCounter = 0;
0001ec  2600              MOVS     r6,#0
;;;557      ErrorStatus state;
;;;558      FlagStatus flag;
;;;559    
;;;560      /* Wait until LSI is ready or time out is occure */
;;;561      do
0001ee  bf00              NOP      
                  |L1.496|
;;;562      {
;;;563        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY);
0001f0  2015              MOVS     r0,#0x15
0001f2  f7fffffe          BL       RST_CLK_GetFlagStatus
0001f6  4605              MOV      r5,r0
;;;564        startCounter++;
0001f8  1c76              ADDS     r6,r6,#1
;;;565      } while ((startCounter < LSIonTimeOut) && (flag == RESET));
0001fa  f5b66fc0          CMP      r6,#0x600
0001fe  d201              BCS      |L1.516|
000200  2d00              CMP      r5,#0
000202  d0f5              BEQ      |L1.496|
                  |L1.516|
;;;566    
;;;567      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY) != RESET)
000204  2015              MOVS     r0,#0x15
000206  f7fffffe          BL       RST_CLK_GetFlagStatus
00020a  b108              CBZ      r0,|L1.528|
;;;568      {
;;;569        state = SUCCESS;
00020c  2401              MOVS     r4,#1
00020e  e000              B        |L1.530|
                  |L1.528|
;;;570      }
;;;571      else
;;;572      {
;;;573        state = ERROR;
000210  2400              MOVS     r4,#0
                  |L1.530|
;;;574      }
;;;575      return (state);
000212  4620              MOV      r0,r4
;;;576    }
000214  bd70              POP      {r4-r6,pc}
;;;577    
                          ENDP

                  RST_CLK_CPU_PLLconfig PROC
;;;604      */
;;;605    void RST_CLK_CPU_PLLconfig ( uint32_t RST_CLK_CPU_PLLsource,
000216  b510              PUSH     {r4,lr}
;;;606                             uint32_t RST_CLK_CPU_PLLmul )
;;;607    {
000218  4602              MOV      r2,r0
;;;608      uint32_t temp;
;;;609    
;;;610      /* Check the parameters */
;;;611      assert_param(IS_RST_CLK_CPU_PLL_SOURCE(RST_CLK_CPU_PLLsource));
;;;612      assert_param(IS_RST_CLK_CPU_PLL_MUL(RST_CLK_CPU_PLLmul));
;;;613    
;;;614      /* Select CPUPLL source */
;;;615      temp = MDR_RST_CLK->CPU_CLOCK;
00021a  4b72              LDR      r3,|L1.996|
00021c  68d8              LDR      r0,[r3,#0xc]
;;;616      /* Clear CPU_C1_SEL bits */
;;;617      temp &= CPU_C1_SELclr;
00021e  f0200003          BIC      r0,r0,#3
;;;618      /* Set the CPU_C1_SEL bits */
;;;619      temp |= RST_CLK_CPU_PLLsource;
000222  4310              ORRS     r0,r0,r2
;;;620      /* Store the new value */MDR_RST_CLK->CPU_CLOCK = temp;
000224  60d8              STR      r0,[r3,#0xc]
;;;621    
;;;622      /* Set CPUPLL multiplier */
;;;623      temp = MDR_RST_CLK->PLL_CONTROL;
000226  6858              LDR      r0,[r3,#4]
;;;624      /* Clear PLLMUL[3:0] bits */
;;;625      temp &= PLLCPUmulclr;
000228  f4206070          BIC      r0,r0,#0xf00
;;;626      /* Set the PLLMUL[3:0] bits */
;;;627      temp |= (RST_CLK_CPU_PLLmul << PLLCPUMUL_OFFSET);
00022c  ea402001          ORR      r0,r0,r1,LSL #8
;;;628      /* Store the new value */MDR_RST_CLK->PLL_CONTROL = temp;
000230  6058              STR      r0,[r3,#4]
;;;629    
;;;630    #if defined ( USE_MDR1986VE9x )/* For Cortex M3 */
;;;631      if (*(__IO uint32_t *) PLLCPUON_BB) {
000232  4b70              LDR      r3,|L1.1012|
000234  681b              LDR      r3,[r3,#0]
000236  b13b              CBZ      r3,|L1.584|
;;;632        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x01;
000238  2301              MOVS     r3,#1
00023a  4c6f              LDR      r4,|L1.1016|
00023c  6023              STR      r3,[r4,#0]
;;;633        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x00;
00023e  f04f0300          MOV      r3,#0
000242  4c6e              LDR      r4,|L1.1020|
000244  f8c4308c          STR      r3,[r4,#0x8c]
                  |L1.584|
;;;634      }
;;;635    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;636      if( (MDR_RST_CLK->PLL_CONTROL & RST_CLK_PLL_CONTROL_PLL_CPU_ON) == RST_CLK_PLL_CONTROL_PLL_CPU_ON ) {
;;;637        temp = MDR_RST_CLK->PLL_CONTROL;
;;;638        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;639        MDR_RST_CLK->PLL_CONTROL = temp;
;;;640        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;641        MDR_RST_CLK->PLL_CONTROL = temp;
;;;642      }
;;;643    #endif
;;;644    }
000248  bd10              POP      {r4,pc}
;;;645    
                          ENDP

                  RST_CLK_CPU_PLLuse PROC
;;;650      */
;;;651    void RST_CLK_CPU_PLLuse(FunctionalState UsePLL)
00024a  496d              LDR      r1,|L1.1024|
;;;652    {
;;;653    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;654      uint32_t temp = 0;
;;;655    #endif
;;;656      /* Check the parameters */
;;;657      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;658    
;;;659    #if defined  (USE_MDR1986VE9x)
;;;660      *(__IO uint32_t *) CPU_C2_SEL_BB = (uint32_t) UsePLL;
00024c  6008              STR      r0,[r1,#0]
;;;661    #endif
;;;662    
;;;663    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;664    
;;;665      temp = MDR_RST_CLK->CPU_CLOCK;
;;;666      /* Form new value */
;;;667      if (UsePLL != DISABLE){
;;;668        /* Use the CPU PLL output as input for CPU_C3_SEL
;;;669         * by setting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;670        temp |= (1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;671      }
;;;672      else{
;;;673        /* Use the CPU_C1 output as input for CPU_C3_SEL
;;;674         * by resetting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;675        temp &= ~(1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;676      }
;;;677      /* Configure CPU_CLOCK register with new value */
;;;678      MDR_RST_CLK->CPU_CLOCK = temp;
;;;679    #endif
;;;680    }
00024e  4770              BX       lr
;;;681    
                          ENDP

                  RST_CLK_CPU_PLLcmd PROC
;;;686      */
;;;687    void RST_CLK_CPU_PLLcmd ( FunctionalState NewState )
000250  4968              LDR      r1,|L1.1012|
;;;688    {
;;;689    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;690      uint32_t temp;
;;;691    #endif
;;;692      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;693    
;;;694    #if defined  (USE_MDR1986VE9x)
;;;695      *(__IO uint32_t *) PLLCPUON_BB = (uint32_t) NewState;
000252  6008              STR      r0,[r1,#0]
;;;696    #endif
;;;697    
;;;698    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;699      temp = MDR_RST_CLK->PLL_CONTROL;
;;;700    
;;;701      if(NewState == ENABLE){
;;;702        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;703      }
;;;704      else{
;;;705        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;706      }
;;;707      MDR_RST_CLK->PLL_CONTROL = temp;
;;;708    
;;;709    #endif
;;;710    }
000254  4770              BX       lr
;;;711    
                          ENDP

                  RST_CLK_CPU_PLLstatus PROC
;;;716      */
;;;717    ErrorStatus RST_CLK_CPU_PLLstatus(void)
000256  b570              PUSH     {r4-r6,lr}
;;;718    {
;;;719      __IO uint32_t startCounter = 0;
000258  2600              MOVS     r6,#0
;;;720      ErrorStatus state;
;;;721      FlagStatus flag;
;;;722    
;;;723      /* Wait until CPUPLL is ready or time out is occure */
;;;724      do
00025a  bf00              NOP      
                  |L1.604|
;;;725      {
;;;726        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY);
00025c  2021              MOVS     r0,#0x21
00025e  f7fffffe          BL       RST_CLK_GetFlagStatus
000262  4605              MOV      r5,r0
;;;727        startCounter++;
000264  1c76              ADDS     r6,r6,#1
;;;728      } while ((startCounter < PLLCPUonTimeOut) && (flag == RESET));
000266  f5b66fc0          CMP      r6,#0x600
00026a  d201              BCS      |L1.624|
00026c  2d00              CMP      r5,#0
00026e  d0f5              BEQ      |L1.604|
                  |L1.624|
;;;729    
;;;730      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY) != RESET)
000270  2021              MOVS     r0,#0x21
000272  f7fffffe          BL       RST_CLK_GetFlagStatus
000276  b108              CBZ      r0,|L1.636|
;;;731      {
;;;732        state = SUCCESS;
000278  2401              MOVS     r4,#1
00027a  e000              B        |L1.638|
                  |L1.636|
;;;733      }
;;;734      else
;;;735      {
;;;736        state = ERROR;
00027c  2400              MOVS     r4,#0
                  |L1.638|
;;;737      }
;;;738      return state;
00027e  4620              MOV      r0,r4
;;;739    }
000280  bd70              POP      {r4-r6,pc}
;;;740    
                          ENDP

                  RST_CLK_CPUclkPrescaler PROC
;;;754      */
;;;755    void RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue)
000282  4601              MOV      r1,r0
;;;756    {
;;;757      uint32_t temp;
;;;758    
;;;759      /* Check the parameters */
;;;760      assert_param(IS_RST_CLK_CPUclkDIV(CPUclkDivValue));
;;;761    
;;;762      temp = MDR_RST_CLK->CPU_CLOCK;
000284  4a57              LDR      r2,|L1.996|
000286  68d0              LDR      r0,[r2,#0xc]
;;;763      /* Clear CPU_C3_SEL bits */
;;;764      temp &= CPU_C3_SELclr;
000288  f02000f0          BIC      r0,r0,#0xf0
;;;765      /* Set the CPU_C3_SEL bits */
;;;766      temp |= (CPUclkDivValue << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos);
00028c  ea401001          ORR      r0,r0,r1,LSL #4
;;;767      /* Store the new value */
;;;768      MDR_RST_CLK->CPU_CLOCK = temp;
000290  60d0              STR      r0,[r2,#0xc]
;;;769    }
000292  4770              BX       lr
;;;770    
                          ENDP

                  RST_CLK_USB_PLLconfig PROC
;;;822      */
;;;823    void RST_CLK_USB_PLLconfig ( uint32_t RST_CLK_USB_PLLsource,
000294  b510              PUSH     {r4,lr}
;;;824                             uint32_t RST_CLK_USB_PLLmul )
;;;825    {
000296  4602              MOV      r2,r0
;;;826      uint32_t temp;
;;;827    
;;;828      /* Check the parameters */
;;;829      assert_param(IS_RST_CLK_USB_PLL_SOURCE(RST_CLK_USB_PLLsource));
;;;830      assert_param(IS_RST_CLK_USB_PLL_MUL(RST_CLK_USB_PLLmul));
;;;831    
;;;832      /* Select USBPLL source */
;;;833      temp = MDR_RST_CLK->USB_CLOCK;
000298  4b52              LDR      r3,|L1.996|
00029a  6918              LDR      r0,[r3,#0x10]
;;;834      /* Clear USB_C1_SEL bits */
;;;835      temp &= USB_C1_SELclr;
00029c  f0200003          BIC      r0,r0,#3
;;;836      /* Set the USB_C1_SEL bits */
;;;837      temp |= RST_CLK_USB_PLLsource;
0002a0  4310              ORRS     r0,r0,r2
;;;838      /* Store the new value */MDR_RST_CLK->USB_CLOCK = temp;
0002a2  6118              STR      r0,[r3,#0x10]
;;;839    
;;;840      /* Set USBPLL multiplier */
;;;841      temp = MDR_RST_CLK->PLL_CONTROL;
0002a4  6858              LDR      r0,[r3,#4]
;;;842      /* Clear PLLMUL[3:0] bits */
;;;843      temp &= PLLUSBmulclr;
0002a6  f02000f0          BIC      r0,r0,#0xf0
;;;844      /* Set the PLLMUL[3:0] bits */
;;;845      temp |= (RST_CLK_USB_PLLmul << PLLUSBMUL_OFFSET);
0002aa  ea401001          ORR      r0,r0,r1,LSL #4
;;;846      /* Store the new value */MDR_RST_CLK->PLL_CONTROL = temp;
0002ae  6058              STR      r0,[r3,#4]
;;;847    
;;;848    #if defined  (USE_MDR1986VE9x)
;;;849      if (*(__IO uint32_t *) PLLUSBON_BB) {
0002b0  4b54              LDR      r3,|L1.1028|
0002b2  681b              LDR      r3,[r3,#0]
0002b4  b13b              CBZ      r3,|L1.710|
;;;850        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x01;
0002b6  2301              MOVS     r3,#1
0002b8  4c53              LDR      r4,|L1.1032|
0002ba  6023              STR      r3,[r4,#0]
;;;851        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x00;
0002bc  f04f0300          MOV      r3,#0
0002c0  4c4e              LDR      r4,|L1.1020|
0002c2  f8c43084          STR      r3,[r4,#0x84]
                  |L1.710|
;;;852      }
;;;853    #endif
;;;854    
;;;855    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;856      if( MDR_RST_CLK->PLL_CONTROL & (RST_CLK_PLL_CONTROL_PLL_USB_ON) ) {
;;;857        temp = MDR_RST_CLK->PLL_CONTROL;
;;;858        temp |= RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;859        MDR_RST_CLK->PLL_CONTROL = temp;
;;;860        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;861        MDR_RST_CLK->PLL_CONTROL = temp;
;;;862      }
;;;863    #endif
;;;864    }
0002c6  bd10              POP      {r4,pc}
;;;865    
                          ENDP

                  RST_CLK_USB_PLLuse PROC
;;;870      */
;;;871    void RST_CLK_USB_PLLuse ( FunctionalState UsePLL )
0002c8  4950              LDR      r1,|L1.1036|
;;;872    {
;;;873    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;874      uint32_t temp = 0;
;;;875    #endif
;;;876      /* Check the parameters */
;;;877      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;878    
;;;879    #ifdef USE_MDR1986VE9x /* for Cortex M3 series */
;;;880      *(__IO uint32_t *) USB_C2_SEL_BB = (uint32_t) UsePLL;
0002ca  6008              STR      r0,[r1,#0]
;;;881    #endif // #ifdef USE_MDR1986VE9x /* for Cortex M3 series */
;;;882    
;;;883    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;884    
;;;885      temp = MDR_RST_CLK->USB_CLOCK;
;;;886      /* Form new value */
;;;887      if (UsePLL != DISABLE){
;;;888        /* Use the USB PLL output as input for USB_C3_SEL
;;;889         * by setting the USB_C2_SEL bit in the USB_CLOCK register */
;;;890        temp |= (1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;891      }
;;;892      else{
;;;893        /* Use the USB_C1 output as input for USB_C3_SEL
;;;894         * by resetting the USB_C2_SEL bit in the USB_CLOCK register */
;;;895        temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;896      }
;;;897      /* Configure USB_CLOCK register with new value */
;;;898      MDR_RST_CLK->USB_CLOCK = temp;
;;;899    #endif
;;;900    }
0002cc  4770              BX       lr
;;;901    
                          ENDP

                  RST_CLK_USB_PLLcmd PROC
;;;906      */
;;;907    void RST_CLK_USB_PLLcmd ( FunctionalState NewState )
0002ce  494d              LDR      r1,|L1.1028|
;;;908    {
;;;909    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;910      uint32_t temp = 0;
;;;911    #endif
;;;912      /* Check the parameters */
;;;913      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;914    #if defined  (USE_MDR1986VE9x)
;;;915      *(__IO uint32_t *) PLLUSBON_BB = (uint32_t) NewState;
0002d0  6008              STR      r0,[r1,#0]
;;;916    #endif
;;;917    
;;;918    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;919    
;;;920      temp = MDR_RST_CLK->PLL_CONTROL;
;;;921      /* Form a new value */
;;;922      if( NewState != DISABLE ) {
;;;923        temp |= RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;924      }
;;;925      else {
;;;926        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;927      }
;;;928      MDR_RST_CLK->PLL_CONTROL = temp;
;;;929    #endif
;;;930    
;;;931    }
0002d2  4770              BX       lr
;;;932    
                          ENDP

                  RST_CLK_USB_PLLstatus PROC
;;;937      */
;;;938    ErrorStatus RST_CLK_USB_PLLstatus(void)
0002d4  b570              PUSH     {r4-r6,lr}
;;;939    {
;;;940      __IO uint32_t startCounter = 0;
0002d6  2600              MOVS     r6,#0
;;;941      ErrorStatus state;
;;;942      FlagStatus flag;
;;;943    
;;;944      /* Wait until USBPLL is ready or time out is occure */
;;;945      do
0002d8  bf00              NOP      
                  |L1.730|
;;;946      {
;;;947        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY);
0002da  2020              MOVS     r0,#0x20
0002dc  f7fffffe          BL       RST_CLK_GetFlagStatus
0002e0  4605              MOV      r5,r0
;;;948        startCounter++;
0002e2  1c76              ADDS     r6,r6,#1
;;;949      } while ((startCounter < PLLUSBonTimeOut) && (flag == RESET));
0002e4  f5b66fc0          CMP      r6,#0x600
0002e8  d201              BCS      |L1.750|
0002ea  2d00              CMP      r5,#0
0002ec  d0f5              BEQ      |L1.730|
                  |L1.750|
;;;950    
;;;951      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY) != RESET)
0002ee  2020              MOVS     r0,#0x20
0002f0  f7fffffe          BL       RST_CLK_GetFlagStatus
0002f4  b108              CBZ      r0,|L1.762|
;;;952      {
;;;953        state = SUCCESS;
0002f6  2401              MOVS     r4,#1
0002f8  e000              B        |L1.764|
                  |L1.762|
;;;954      }
;;;955      else
;;;956      {
;;;957        state = ERROR;
0002fa  2400              MOVS     r4,#0
                  |L1.764|
;;;958      }
;;;959      return state;
0002fc  4620              MOV      r0,r4
;;;960    }
0002fe  bd70              POP      {r4-r6,pc}
;;;961    
                          ENDP

                  RST_CLK_USBclkPrescaler PROC
;;;968      */
;;;969    void RST_CLK_USBclkPrescaler(FunctionalState NewState)
000300  4943              LDR      r1,|L1.1040|
;;;970    {
;;;971    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;972      uint32_t temp = 0;
;;;973    #endif
;;;974      /* Check the parameters */
;;;975      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;976    
;;;977    #if defined  (USE_MDR1986VE9x)
;;;978       *(__IO uint32_t *) USB_C3_SEL_BB = (uint32_t)NewState;
000302  6008              STR      r0,[r1,#0]
;;;979    #endif
;;;980    
;;;981    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;982    
;;;983      temp = MDR_RST_CLK->USB_CLOCK;
;;;984    
;;;985      /* Form new value */
;;;986      if (NewState != DISABLE){
;;;987        /* Enable the USB prescaler by setting the USB_C3_SEL bit in the USB_CLOCK register */
;;;988        temp |= (1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;989      }
;;;990      else{
;;;991        /* Disable the USB prescaler by resetting the USB_C3_SEL bit in the USB_CLOCK register */
;;;992        temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;993      }
;;;994      /* Configure USB_CLOCK register with new value */
;;;995      MDR_RST_CLK->USB_CLOCK = temp;
;;;996    #endif
;;;997    
;;;998    }
000304  4770              BX       lr
;;;999    
                          ENDP

                  RST_CLK_USBclkEnable PROC
;;;1006     */
;;;1007   void RST_CLK_USBclkEnable ( FunctionalState NewState )
000306  4943              LDR      r1,|L1.1044|
;;;1008   {
;;;1009   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1010     uint32_t temp = 0;
;;;1011   #endif
;;;1012     /* Check the parameters */
;;;1013     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1014   
;;;1015   #if defined  (USE_MDR1986VE9x)
;;;1016     *(__IO uint32_t *) USB_CLK_EN_BB = (uint32_t) NewState;
000308  6008              STR      r0,[r1,#0]
;;;1017   #endif
;;;1018   
;;;1019   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1020   
;;;1021     temp = MDR_RST_CLK->USB_CLOCK;
;;;1022   
;;;1023     /* Form new value */
;;;1024     if (NewState != DISABLE){
;;;1025       /* Enable the USB clk by setting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1026       temp |= (1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1027     }
;;;1028     else{
;;;1029       /* Disable the USB clk by resetting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1030       temp &= ~(1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1031     }
;;;1032     /* Configure USB_CLOCK register with new value */
;;;1033     MDR_RST_CLK->USB_CLOCK = temp;
;;;1034   #endif
;;;1035   }
00030a  4770              BX       lr
;;;1036   
                          ENDP

                  RST_CLK_ADCclkSelection PROC
;;;1048     */
;;;1049   void RST_CLK_ADCclkSelection(uint32_t ADC_CLK)
00030c  4601              MOV      r1,r0
;;;1050   {
;;;1051     uint32_t temp;
;;;1052   
;;;1053     /* Check the parameters */
;;;1054     assert_param(IS_RST_CLK_ADCclk(ADC_CLK));
;;;1055   
;;;1056     /* Select ADC_CLK source */
;;;1057     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
00030e  4a35              LDR      r2,|L1.996|
000310  6950              LDR      r0,[r2,#0x14]
;;;1058     /* Clear ADC_C1,C2 SEL bits */
;;;1059     temp &= ADC_C12_SELclr;
000312  f0200033          BIC      r0,r0,#0x33
;;;1060     /* Set the ADC_C1,C2 SEL bits */
;;;1061     temp |= ADC_CLK;
000316  4308              ORRS     r0,r0,r1
;;;1062     /* Store the new value */
;;;1063     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
000318  6150              STR      r0,[r2,#0x14]
;;;1064   }
00031a  4770              BX       lr
;;;1065   
                          ENDP

                  RST_CLK_ADCclkPrescaler PROC
;;;1080     */
;;;1081   void RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue)
00031c  4601              MOV      r1,r0
;;;1082   {
;;;1083     uint32_t temp;
;;;1084   
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_RST_CLK_ADCclkDivValue(ADCclkDivValue));
;;;1087   
;;;1088     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
00031e  4a31              LDR      r2,|L1.996|
000320  6950              LDR      r0,[r2,#0x14]
;;;1089     /* Clear ADC_C3_SEL bits */
;;;1090     temp &= ADC_C3_SELclr;
000322  f4206070          BIC      r0,r0,#0xf00
;;;1091     /* Set the ADC_C3_SEL bits */
;;;1092     temp |= ADCclkDivValue<<ADC_C3_SEL_OFFSET;
000326  ea402001          ORR      r0,r0,r1,LSL #8
;;;1093     /* Store the new value */
;;;1094     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
00032a  6150              STR      r0,[r2,#0x14]
;;;1095   }
00032c  4770              BX       lr
;;;1096   
                          ENDP

                  RST_CLK_ADCclkEnable PROC
;;;1103     */
;;;1104   void RST_CLK_ADCclkEnable ( FunctionalState NewState )
00032e  493a              LDR      r1,|L1.1048|
;;;1105   {
;;;1106   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1107     uint32_t temp = 0;
;;;1108   #endif
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1111   
;;;1112   #if defined  (USE_MDR1986VE9x)
;;;1113     *(__IO uint32_t *) ADC_CLK_EN_BB = (uint32_t) NewState;
000330  6008              STR      r0,[r1,#0]
;;;1114   #endif
;;;1115   
;;;1116   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1117   
;;;1118     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
;;;1119     /* Form new value */
;;;1120     if (NewState != DISABLE){
;;;1121       /* Enable the ADC CLK by setting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1122       temp |= RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1123     }
;;;1124     else{
;;;1125       /* Disable the ADC CLK by resetting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1126       temp &= ~RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1127     }
;;;1128     /* Configure CPU_CLOCK register with new value */
;;;1129     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
;;;1130   #endif
;;;1131   
;;;1132   }
000332  4770              BX       lr
;;;1133   
                          ENDP

                  RST_CLK_HSIclkPrescaler PROC
;;;1252     */
;;;1253   void RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue)
000334  4601              MOV      r1,r0
;;;1254   {
;;;1255     uint32_t temp;
;;;1256   
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_RST_CLK_HSIclkDivValue(HSIclkDivValue));
;;;1259   
;;;1260     temp = MDR_RST_CLK->RTC_CLOCK;
000336  4a2b              LDR      r2,|L1.996|
000338  6990              LDR      r0,[r2,#0x18]
;;;1261     /* Clear HSI_SEL bits */
;;;1262     temp &= HSI_SELclr;
00033a  f02000f0          BIC      r0,r0,#0xf0
;;;1263     /* Set the HSI_SEL bits */
;;;1264     temp |= HSIclkDivValue<<HSI_SEL_OFFSET;
00033e  ea401001          ORR      r0,r0,r1,LSL #4
;;;1265     /* Store the new value */
;;;1266     MDR_RST_CLK->RTC_CLOCK = temp;
000342  6190              STR      r0,[r2,#0x18]
;;;1267   }
000344  4770              BX       lr
;;;1268   
                          ENDP

                  RST_CLK_RTC_HSIclkEnable PROC
;;;1275     */
;;;1276   void RST_CLK_RTC_HSIclkEnable ( FunctionalState NewState )
000346  4935              LDR      r1,|L1.1052|
;;;1277   {
;;;1278   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1279     uint32_t temp = 0;
;;;1280   #endif
;;;1281     /* Check the parameters */
;;;1282     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1283   
;;;1284   #if defined  (USE_MDR1986VE9x)
;;;1285     *(__IO uint32_t *) HSI_RTC_EN_BB = (uint32_t) NewState;
000348  6008              STR      r0,[r1,#0]
;;;1286   #endif
;;;1287   
;;;1288   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1289   
;;;1290       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1291     /* Form new value */
;;;1292     if (NewState != DISABLE){
;;;1293       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1294       temp |= RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1295     }
;;;1296     else{
;;;1297       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1298       temp &= ~RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1299     }
;;;1300     /* Configure RTC_CLOCK register with new value */
;;;1301     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1302   
;;;1303   #endif
;;;1304   }
00034a  4770              BX       lr
;;;1305   
                          ENDP

                  RST_CLK_HSEclkPrescaler PROC
;;;1320     */
;;;1321   void RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue)
00034c  4601              MOV      r1,r0
;;;1322   {
;;;1323     uint32_t temp;
;;;1324   
;;;1325     /* Check the parameters */
;;;1326     assert_param(IS_RST_CLK_HSEclkDivValue(HSEclkDivValue));
;;;1327   
;;;1328     temp = MDR_RST_CLK->RTC_CLOCK;
00034e  4a25              LDR      r2,|L1.996|
000350  6990              LDR      r0,[r2,#0x18]
;;;1329     /* Clear HSE_SEL bits */
;;;1330     temp &= HSE_SELclr;
000352  f020000f          BIC      r0,r0,#0xf
;;;1331     /* Set the HSE_SEL bits */
;;;1332     temp |= HSEclkDivValue<<HSE_SEL_OFFSET;
000356  4308              ORRS     r0,r0,r1
;;;1333     /* Store the new value */
;;;1334     MDR_RST_CLK->RTC_CLOCK = temp;
000358  6190              STR      r0,[r2,#0x18]
;;;1335   }
00035a  4770              BX       lr
;;;1336   
                          ENDP

                  RST_CLK_RTC_HSEclkEnable PROC
;;;1343     */
;;;1344   void RST_CLK_RTC_HSEclkEnable(FunctionalState NewState)
00035c  4930              LDR      r1,|L1.1056|
;;;1345   {
;;;1346   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1347     uint32_t temp = 0;
;;;1348   #endif
;;;1349     /* Check the parameters */
;;;1350     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1351   
;;;1352   #if defined  (USE_MDR1986VE9x)
;;;1353     *(__IO uint32_t *) HSE_RTC_EN_BB = (uint32_t)NewState;
00035e  6008              STR      r0,[r1,#0]
;;;1354   #endif
;;;1355   
;;;1356   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1357   
;;;1358       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1359     /* Form new value */
;;;1360     if (NewState != DISABLE){
;;;1361       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1362       temp |= RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1363     }
;;;1364     else{
;;;1365       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1366       temp &= ~RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1367     }
;;;1368     /* Configure RTC_CLOCK register with new value */
;;;1369     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1370   
;;;1371   #endif
;;;1372   }
000360  4770              BX       lr
;;;1373   
                          ENDP

                  RST_CLK_GetClocksFreq PROC
;;;1458     */
;;;1459   void RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks)
000362  e92d4ffc          PUSH     {r2-r11,lr}
;;;1460   {
000366  4601              MOV      r1,r0
;;;1461     uint32_t cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
;;;1462     uint32_t usb_c1_freq, usb_c2_freq, usb_c3_freq;
;;;1463     uint32_t adc_c1_freq, adc_c2_freq, adc_c3_freq;
;;;1464     uint32_t hsi_c1_freq, hse_c1_freq;
;;;1465     uint32_t pll_mul;
;;;1466     uint32_t temp;
;;;1467   
;;;1468     /* Check the parameter */
;;;1469     assert_param(RST_CLK_Clocks != 0);
;;;1470   
;;;1471     /* Compute CPU_CLK, USB_CLK, ADC_CLK, RTCHSI, RTCHSE clocks frequencies */
;;;1472   
;;;1473     /* Compute CPU_CLK frequency */
;;;1474   
;;;1475     /* Determine CPU_C1 frequency */
;;;1476     if( MDR_RST_CLK->CPU_CLOCK & (2 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
000368  f8dfb078          LDR      r11,|L1.996|
00036c  f8dbb00c          LDR      r11,[r11,#0xc]
000370  f01b0f02          TST      r11,#2
000374  d001              BEQ      |L1.890|
;;;1477       cpu_c1_freq = HSE_Value;
000376  4b2b              LDR      r3,|L1.1060|
000378  e000              B        |L1.892|
                  |L1.890|
;;;1478     }
;;;1479     else {
;;;1480       cpu_c1_freq = HSI_Value;
00037a  4b2a              LDR      r3,|L1.1060|
                  |L1.892|
;;;1481     }
;;;1482     if( MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
00037c  f8dfb064          LDR      r11,|L1.996|
000380  f8dbb00c          LDR      r11,[r11,#0xc]
000384  f01b0f01          TST      r11,#1
000388  d000              BEQ      |L1.908|
;;;1483       cpu_c1_freq /= 2;
00038a  085b              LSRS     r3,r3,#1
                  |L1.908|
;;;1484     }
;;;1485   
;;;1486     /* Determine CPU_C2 frequency */
;;;1487     cpu_c2_freq = cpu_c1_freq;
00038c  461c              MOV      r4,r3
;;;1488   
;;;1489     if (MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos)) {
00038e  f8dfb054          LDR      r11,|L1.996|
000392  f8dbb00c          LDR      r11,[r11,#0xc]
000396  f01b0f04          TST      r11,#4
00039a  d00d              BEQ      |L1.952|
;;;1490       /* Determine CPU PLL output frequency */
;;;1491       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
00039c  f8dfb044          LDR      r11,|L1.996|
0003a0  f8dbb004          LDR      r11,[r11,#4]
0003a4  f3cb2b03          UBFX     r11,r11,#8,#4
0003a8  f10b0b01          ADD      r11,r11,#1
0003ac  f8cdb000          STR      r11,[sp,#0]
;;;1492           >> RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1493       cpu_c2_freq *= pll_mul;
0003b0  f8ddb000          LDR      r11,[sp,#0]
0003b4  fb04f40b          MUL      r4,r4,r11
                  |L1.952|
;;;1494     }
;;;1495   
;;;1496     /*Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases */
;;;1497     switch ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_HCLK_SEL_Pos)
0003b8  f8dfb028          LDR      r11,|L1.996|
0003bc  f8dbb00c          LDR      r11,[r11,#0xc]
0003c0  f3cb2b01          UBFX     r11,r11,#8,#2
0003c4  f1bb0f00          CMP      r11,#0
0003c8  d006              BEQ      |L1.984|
0003ca  f1bb0f01          CMP      r11,#1
0003ce  d02b              BEQ      |L1.1064|
0003d0  f1bb0f02          CMP      r11,#2
0003d4  d149              BNE      |L1.1130|
0003d6  e043              B        |L1.1120|
                  |L1.984|
;;;1498         & (uint32_t) 0x03) {
;;;1499       case 0:
;;;1500         /* HSI */
;;;1501         RST_CLK_Clocks->CPU_CLK_Frequency = HSI_Value;
0003d8  f8dfb048          LDR      r11,|L1.1060|
0003dc  f8c1b000          STR      r11,[r1,#0]
;;;1502         break;
0003e0  e048              B        |L1.1140|
0003e2  0000              DCW      0x0000
                  |L1.996|
                          DCD      0x40020000
                  |L1.1000|
                          DCD      0x400d8000
                  |L1.1004|
                          DCD      0x43b007d8
                  |L1.1008|
                          DCD      0x08000010
                  |L1.1012|
                          DCD      0x42400088
                  |L1.1016|
                          DCD      0x4240008c
                  |L1.1020|
                          DCD      0x42400000
                  |L1.1024|
                          DCD      0x42400188
                  |L1.1028|
                          DCD      0x42400080
                  |L1.1032|
                          DCD      0x42400084
                  |L1.1036|
                          DCD      0x42400208
                  |L1.1040|
                          DCD      0x42400210
                  |L1.1044|
                          DCD      0x42400220
                  |L1.1048|
                          DCD      0x424002b4
                  |L1.1052|
                          DCD      0x42400324
                  |L1.1056|
                          DCD      0x42400320
                  |L1.1060|
                          DCD      0x007a1200
                  |L1.1064|
;;;1503       case 1:
;;;1504         /* CPU_C3 */
;;;1505         /* Determine CPU_C3 frequency */
;;;1506         if ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
000428  f8dfb1b8          LDR      r11,|L1.1508|
00042c  f8dbb00c          LDR      r11,[r11,#0xc]
000430  f04f0e08          MOV      lr,#8
000434  ea1e1f1b          TST      lr,r11,LSR #4
000438  d101              BNE      |L1.1086|
;;;1507             & (uint32_t) 0x08) == 0x00) {
;;;1508           cpu_c3_freq = cpu_c2_freq;
00043a  46a0              MOV      r8,r4
00043c  e00d              B        |L1.1114|
                  |L1.1086|
;;;1509         }
;;;1510         else {
;;;1511           cpu_c3_freq = cpu_c2_freq
00043e  f8dfb1a4          LDR      r11,|L1.1508|
000442  f8dbb00c          LDR      r11,[r11,#0xc]
000446  f3cb1b02          UBFX     r11,r11,#4,#3
00044a  f10b0b01          ADD      r11,r11,#1
00044e  f04f0e01          MOV      lr,#1
000452  fa0efe0b          LSL      lr,lr,r11
000456  fbb4f8fe          UDIV     r8,r4,lr
                  |L1.1114|
;;;1512               / (1
;;;1513                   << ((MDR_RST_CLK->CPU_CLOCK
;;;1514                       >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
;;;1515                       & (uint32_t) 0x07) + 1));
;;;1516         }
;;;1517         RST_CLK_Clocks->CPU_CLK_Frequency = cpu_c3_freq;
00045a  f8c18000          STR      r8,[r1,#0]
;;;1518         break;
00045e  e009              B        |L1.1140|
                  |L1.1120|
;;;1519       case 2:
;;;1520         /* LSE */
;;;1521         RST_CLK_Clocks->CPU_CLK_Frequency = LSE_Value;
000460  f44f4b00          MOV      r11,#0x8000
000464  f8c1b000          STR      r11,[r1,#0]
;;;1522         break;
000468  e004              B        |L1.1140|
                  |L1.1130|
;;;1523       default: /* case 3 */
;;;1524         /* LSI */
;;;1525         RST_CLK_Clocks->CPU_CLK_Frequency = LSI_Value;
00046a  f6494b40          MOV      r11,#0x9c40
00046e  f8c1b000          STR      r11,[r1,#0]
;;;1526         break;
000472  bf00              NOP      
                  |L1.1140|
000474  bf00              NOP                            ;1502
;;;1527     }
;;;1528   
;;;1529     /* Compute USB_CLK frequency */
;;;1530   
;;;1531     /* Determine USB_C1 frequency */
;;;1532     if( MDR_RST_CLK->USB_CLOCK & (2 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
000476  f8dfb16c          LDR      r11,|L1.1508|
00047a  f8dbb010          LDR      r11,[r11,#0x10]
00047e  f01b0f02          TST      r11,#2
000482  d001              BEQ      |L1.1160|
;;;1533       usb_c1_freq = HSE_Value;
000484  4d58              LDR      r5,|L1.1512|
000486  e000              B        |L1.1162|
                  |L1.1160|
;;;1534     }
;;;1535     else {
;;;1536       usb_c1_freq = HSI_Value;
000488  4d57              LDR      r5,|L1.1512|
                  |L1.1162|
;;;1537     }
;;;1538   
;;;1539     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
00048a  f8dfb158          LDR      r11,|L1.1508|
00048e  f8dbb010          LDR      r11,[r11,#0x10]
000492  f01b0f01          TST      r11,#1
000496  d000              BEQ      |L1.1178|
;;;1540       usb_c1_freq /= 2;
000498  086d              LSRS     r5,r5,#1
                  |L1.1178|
;;;1541     }
;;;1542   
;;;1543     /* Determine USB_C2 frequency */
;;;1544     usb_c2_freq = usb_c1_freq;
00049a  462f              MOV      r7,r5
;;;1545   
;;;1546     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C2_SEL_Pos) ){
00049c  f8dfb144          LDR      r11,|L1.1508|
0004a0  f8dbb010          LDR      r11,[r11,#0x10]
0004a4  f01b0f04          TST      r11,#4
0004a8  d00d              BEQ      |L1.1222|
;;;1547       /* Determine USB PLL output frequency */
;;;1548       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
0004aa  f8dfb138          LDR      r11,|L1.1508|
0004ae  f8dbb004          LDR      r11,[r11,#4]
0004b2  f3cb1b03          UBFX     r11,r11,#4,#4
0004b6  f10b0b01          ADD      r11,r11,#1
0004ba  f8cdb000          STR      r11,[sp,#0]
;;;1549           >> RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1550       usb_c2_freq *= pll_mul;
0004be  f8ddb000          LDR      r11,[sp,#0]
0004c2  fb07f70b          MUL      r7,r7,r11
                  |L1.1222|
;;;1551     }
;;;1552   
;;;1553     /* Determine USB_C3 frequency */
;;;1554     usb_c3_freq = usb_c2_freq;
0004c6  46b9              MOV      r9,r7
;;;1555     if(MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C3_SEL_Pos)){
0004c8  f8dfb118          LDR      r11,|L1.1508|
0004cc  f8dbb010          LDR      r11,[r11,#0x10]
0004d0  f01b0f10          TST      r11,#0x10
0004d4  d001              BEQ      |L1.1242|
;;;1556       usb_c3_freq /= 2;
0004d6  ea4f0959          LSR      r9,r9,#1
                  |L1.1242|
;;;1557     }
;;;1558   
;;;1559     RST_CLK_Clocks->USB_CLK_Frequency = usb_c3_freq;
0004da  f8c19004          STR      r9,[r1,#4]
;;;1560   
;;;1561     /* Compute RTCHSI_CLK frequency */
;;;1562     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSI_SEL_Pos;
0004de  f8dfb104          LDR      r11,|L1.1508|
0004e2  f8dbb018          LDR      r11,[r11,#0x18]
0004e6  ea4f101b          LSR      r0,r11,#4
;;;1563     if ((temp & 0x08U) == 0) {
0004ea  f0100f08          TST      r0,#8
0004ee  d102              BNE      |L1.1270|
;;;1564       hsi_c1_freq = HSI_Value;
0004f0  f8dfc0f4          LDR      r12,|L1.1512|
0004f4  e00b              B        |L1.1294|
                  |L1.1270|
;;;1565     }
;;;1566     else {
;;;1567       temp = 1 << ((temp & 0x07U) + 1);
0004f6  f0000b07          AND      r11,r0,#7
0004fa  f10b0b01          ADD      r11,r11,#1
0004fe  f04f0e01          MOV      lr,#1
000502  fa0ef00b          LSL      r0,lr,r11
;;;1568       hsi_c1_freq = HSI_Value / temp;
000506  f8dfb0e0          LDR      r11,|L1.1512|
00050a  fbbbfcf0          UDIV     r12,r11,r0
                  |L1.1294|
;;;1569     }
;;;1570     RST_CLK_Clocks->RTCHSI_Frequency = hsi_c1_freq;
00050e  f8c1c00c          STR      r12,[r1,#0xc]
;;;1571   
;;;1572     /* Compute RTCHSE_CLK frequency */
;;;1573     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSE_SEL_Pos;
000512  f8dfb0d0          LDR      r11,|L1.1508|
000516  f8db0018          LDR      r0,[r11,#0x18]
;;;1574     if ((temp & 0x08U) == 0) {
00051a  f0100f08          TST      r0,#8
00051e  d104              BNE      |L1.1322|
;;;1575       hse_c1_freq = HSE_Value;
000520  f8dfb0c4          LDR      r11,|L1.1512|
000524  f8cdb004          STR      r11,[sp,#4]
000528  e00d              B        |L1.1350|
                  |L1.1322|
;;;1576     }
;;;1577     else {
;;;1578       temp = 1 << ((temp & 0x07U) + 1);
00052a  f0000b07          AND      r11,r0,#7
00052e  f10b0b01          ADD      r11,r11,#1
000532  f04f0e01          MOV      lr,#1
000536  fa0ef00b          LSL      r0,lr,r11
;;;1579       hse_c1_freq = HSE_Value / temp;
00053a  f8dfb0ac          LDR      r11,|L1.1512|
00053e  fbbbfbf0          UDIV     r11,r11,r0
000542  f8cdb004          STR      r11,[sp,#4]
                  |L1.1350|
;;;1580     }
;;;1581     RST_CLK_Clocks->RTCHSE_Frequency = hse_c1_freq;
000546  f8ddb004          LDR      r11,[sp,#4]
00054a  f8c1b010          STR      r11,[r1,#0x10]
;;;1582   
;;;1583     /* Compute ADC_CLK frequency */
;;;1584   
;;;1585     /* Select ADC_C1 from CPU_C1, LSI, USB_C1, CPU_C2, USB_C2 cases */
;;;1586     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos)
00054e  f8dfb094          LDR      r11,|L1.1508|
000552  f8dbb014          LDR      r11,[r11,#0x14]
000556  f01b0b03          ANDS     r11,r11,#3
00055a  d006              BEQ      |L1.1386|
00055c  f1bb0f01          CMP      r11,#1
000560  d005              BEQ      |L1.1390|
000562  f1bb0f02          CMP      r11,#2
000566  d106              BNE      |L1.1398|
000568  e003              B        |L1.1394|
                  |L1.1386|
;;;1587         & (uint32_t) 0x03) {
;;;1588       case 0:
;;;1589         /* CPU_C1 */
;;;1590         adc_c1_freq = cpu_c1_freq;
00056a  461e              MOV      r6,r3
;;;1591         break;
00056c  e005              B        |L1.1402|
                  |L1.1390|
;;;1592       case 1:
;;;1593         /* USB_C1 */
;;;1594         adc_c1_freq = usb_c1_freq;
00056e  462e              MOV      r6,r5
;;;1595         break;
000570  e003              B        |L1.1402|
                  |L1.1394|
;;;1596       case 2:
;;;1597         /* CPU_C2 */
;;;1598         adc_c1_freq = cpu_c2_freq;
000572  4626              MOV      r6,r4
;;;1599         break;
000574  e001              B        |L1.1402|
                  |L1.1398|
;;;1600       default: /* case 3 */
;;;1601         /* USB_C2 */
;;;1602         adc_c1_freq = usb_c2_freq;
000576  463e              MOV      r6,r7
;;;1603         break;
000578  bf00              NOP      
                  |L1.1402|
00057a  bf00              NOP                            ;1591
;;;1604     }
;;;1605   
;;;1606     /* Select ADC_C2 from LSE, LSI, ADC_C1, HSI_C1 cases */
;;;1607     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos)
00057c  f8dfb064          LDR      r11,|L1.1508|
000580  f8dbb014          LDR      r11,[r11,#0x14]
000584  f3cb1b01          UBFX     r11,r11,#4,#2
000588  f1bb0f00          CMP      r11,#0
00058c  d006              BEQ      |L1.1436|
00058e  f1bb0f01          CMP      r11,#1
000592  d006              BEQ      |L1.1442|
000594  f1bb0f02          CMP      r11,#2
000598  d108              BNE      |L1.1452|
00059a  e005              B        |L1.1448|
                  |L1.1436|
;;;1608         & (uint32_t) 0x03) {
;;;1609       case 0:
;;;1610         /* LSE */
;;;1611         adc_c2_freq = LSE_Value;
00059c  f44f4200          MOV      r2,#0x8000
;;;1612         break;
0005a0  e006              B        |L1.1456|
                  |L1.1442|
;;;1613       case 1:
;;;1614         /* LSI */
;;;1615         adc_c2_freq = LSI_Value;
0005a2  f6494240          MOV      r2,#0x9c40
;;;1616         break;
0005a6  e003              B        |L1.1456|
                  |L1.1448|
;;;1617       case 2:
;;;1618         /* ADC_C1 */
;;;1619         adc_c2_freq = adc_c1_freq;
0005a8  4632              MOV      r2,r6
;;;1620         break;
0005aa  e001              B        |L1.1456|
                  |L1.1452|
;;;1621       default: /* case 3 */
;;;1622         /* HSI_C1 */
;;;1623         adc_c2_freq = hsi_c1_freq;
0005ac  4662              MOV      r2,r12
;;;1624         break;
0005ae  bf00              NOP      
                  |L1.1456|
0005b0  bf00              NOP                            ;1612
;;;1625     }
;;;1626   
;;;1627     temp = MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos;
0005b2  f8dfb030          LDR      r11,|L1.1508|
0005b6  f8dbb014          LDR      r11,[r11,#0x14]
0005ba  ea4f201b          LSR      r0,r11,#8
;;;1628     if ((temp & 0x08U) == 0) {
0005be  f0100f08          TST      r0,#8
0005c2  d101              BNE      |L1.1480|
;;;1629       adc_c3_freq = adc_c2_freq;
0005c4  4692              MOV      r10,r2
0005c6  e009              B        |L1.1500|
                  |L1.1480|
;;;1630     }
;;;1631     else {
;;;1632       temp = 1 << ((temp & 0x07U) + 1);
0005c8  f0000b07          AND      r11,r0,#7
0005cc  f10b0b01          ADD      r11,r11,#1
0005d0  f04f0e01          MOV      lr,#1
0005d4  fa0ef00b          LSL      r0,lr,r11
;;;1633       adc_c3_freq = adc_c2_freq / temp;
0005d8  fbb2faf0          UDIV     r10,r2,r0
                  |L1.1500|
;;;1634     }
;;;1635   
;;;1636     RST_CLK_Clocks->ADC_CLK_Frequency = adc_c3_freq;
0005dc  f8c1a008          STR      r10,[r1,#8]
;;;1637   }
0005e0  e8bd8ffc          POP      {r2-r11,pc}
;;;1638   
                          ENDP

                  |L1.1508|
                          DCD      0x40020000
                  |L1.1512|
                          DCD      0x007a1200

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_rst_clk.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16|
#line 129 "..\\..\\..\\..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH|
#line 144
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
